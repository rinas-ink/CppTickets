### Термины

**Свободная функция**

* Функция, не являющаяся функцией-членом (т.е. не принадлежащая никакому классу)

**Функция-член**

* Функция, являющаяся членом какого-либо класса

**Время жизни объекта**

* **Автоматическое ("на стеке")**

    * Просто взяли и объявили локальную переменную, память под неё автоматически выделяется
      компилятором и автоматически же удаляется, когда её больше не видно.
      `Automatic storage duration` относится ко всем локальным переменным, которые не помечены
      как `static` . Если зашедовить переменную, она не умирает.

* **Статическое**
    * Глобальные переменные и всё, что на них похоже. Она создаётся в момент запуска программы и
      живёт до конца её работы. Может существовать только один экземпляр такого объекта. Любая
      глобальная переменная, а так же переменные, помеченные как `static`, 
      обладают `Static storage duration`. Если создать статическую переменную внутри функции, она
      создаётся во время первого прохода по этой функции и дальше живёт. Инициализируется один раз,
      затем для всех вызовов функции значение общее (аналогично поля классов). [Пример](https://github.com/hse-spb-2021-cpp/lectures/blob/master/07-211013/03-storage-duration/04-static-func-ok.cpp)

* **Динамическое ("на куче")**
    * `new`/`delete`. Синтаксис: `foo *f = new foo`, читается как "создай новый объект `foo` где-то
      там на куче и верни на него указатель". Это обычный объект, но с одной важной оговоркой:
      теперь за него нужно отвечать (удалить после использования ручками).

**Undefined Behaviour**

* **Почему у неинициализированной переменной нет никакого значения?**

    * При создании переменной выделяется память, но если за этим не последовала инициализация, туда
      не записывается никакого нового значения. Значит, при обращении к этой переменной можно
      получить ВОТ ВАЩЕ ЧТО УГОДНО, в зависимости от того, что лежало в той ячейке памяти, куда её
      записали. Из-за этого велика вероятность, что от запуска к запуску значение переменной будет
      меняться, причём совершенно рандомным образом.

* **Выход за границы массива**
    * Аналогично: для массива выделяется некоторый участок памяти, где хранятся его значения. При
      попытке обратиться к значению вне этого участка, мы залезем куда-то, где может лежать какой-то
      мусор или информация от другой части программы (или вообще другой программы).

* **Dangling reference (висячая ссылка)**

    * Возникает, когда удалили объект, на который указывала ссылка, но не удалили саму ссылку.
      Память, на которую указывает ссылка, может быть к тому времени уже перераспределена, поэтому
      получаем
      UB. [Пример](https://github.com/hse-spb-2021-cpp/lectures/blob/master/04-210923/06-const-wtf/01-dangling.cpp)

* **Разыменовывание `nullptr`**

    * При разыменовывании указателя мы пытаемся получить значение, лежащее по адресу, на который
      ссылается указатель. У `nullptr` такого адреса нет, поэтому получаем UB (вероятнее - краш
      программы).
    * Из стандарта: Если указателю присвоили некорректное значение, поведение унарного
      оператора * не определено. Среди некорректных значений - нулевой указатель, адрес памяти с
      неверным для типа смещением или адрес удаленного объекта.
