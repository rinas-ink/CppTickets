# STL

**Использование `vector` как динамического массива фиксированной длины, `push_back`
, `emplace_back`**

* Обычные сишные массивы не могут быть динамическими (есть расширение `VLA - variable-length array`,
  но оно не входит в стандарт и может входить не во все компиляторы)
  .
* Вектор умеет удалять (`pop_back()`) и добавлять (`push_back()`) элементы, ему можно заранее
  зарезервировать память `vec.reserve()`, поэтому его можно использовать как динамический массив,
  чей размер не превышает заданный (а удаление/добавление в конец работает за единичку).
* `push_back(val)` - сначала создаёт временный объект, затем создает его копию в памяти контейнера и
  пытается мувнуть (скопировать) туда значение объекта, в конце вызывает деструктор.
* `emplace_back(args)` - вызывает конструктор типа, который лежит в векторе, передавая ему
  аргументы `args`. Конструктор может быть любым, работает в целом быстрее, т.к. не создает
  временного объекта (в случае, если передавать именно аргументы для конструктора, а не сам объект;
  в иных случаях проще `std::move(object)`, для которого `push_back()` потребуется сделать меньше
  работы).

Пример: [source](https://ru.stackoverflow.com/questions/570042/%D0%A0%D0%B0%D0%B7%D0%BD%D0%B8%D1%86%D0%B0-%D0%BC%D0%B5%D0%B6%D0%B4%D1%83-push-back-%D0%B8-emplace-back/570080)

```c++
struct Item {
    int a, b, c;
    Item(int a, int b, int c) : a(a), b(b), c(c) {}
}; 

int main() {
    std::vector<Item> x;
    // x.push_back(1, 2, 3); // won't compile
    x.emplace_back(1, 2, 3); // ok
}
```

**Использование `map` со стандартным компаратором, особенность `operator[]`**

* `map` умеет сортировать элементы в соответствии с функциональным объектом `compare`, который
  передаётся как третий аргумент в шаблоне типа. Стандартный компаратор -- `std::less` - пытается
  сравнивать ключи на `<`, результат сортировки - ключи упорядочены по возрастанию.
* `operator[key]` обращается по ключу `key` к `map`. Если ключа не существует, создаётся ключ, по
  нему кладётся значение по-умолчанию для того типа, который лежит в `map` (вызывается конструктор
  по-умолчанию для этого типа). Он должен создать новый объект, т.к. возвращается ссылка, а она
  должна на что-то указывать.
* Из-за такого поведения `[]` не работают на `const map`, поэтому в таком случае нужно
  использовать `.at()` (и ловить несуществующие ключи либо обработчиком, либо `.count()`).

**`lower_bound`/`upper_bound`: параметры, возвращаемое значение**

* Обе функции принимают итератор начала, итератор конца и элемент, который нужно найти. Итератор
  начала - откуда начать бинпоиск, итератор конца - перед каким элементом остановиться (
  полуинтервал)
* Полуинтервал должен быть отсортирован, иначе UB.
* Обе функции возвращают **итератор**, чтобы получить интересующий индекс, надо
  вычесть `container.begin()` из результата.
* `lower_bound():` итератор на первый элемент, который `>=` искомого элемента (предыдущий
  элемент `<`). Если элемента нет, возвращается первый, который строго больше. Если ищем слишком
  большой элемент, возвращается `end()`
  . [Егор](https://github.com/hse-spb-2021-cpp/lectures/blob/master/03-210916/01-extra-stl/05-lower-bound.cpp)
* `upper_bound():` итератор на первый элемент, который `>` искомого элемента (предыдущий `<=`)),
  остальное
  совпадает. [Егор](https://github.com/hse-spb-2021-cpp/lectures/blob/master/03-210916/01-extra-stl/06-upper-bound.cpp)
* Если запустим обе функции на одном элементе, вернется полуинтервал из этого элемента.
* Если запустим обе функции на каком-то массиве, где этого элемента не было, вернётся пустой
  полуинтервал, где этот элемент мог бы находиться.
