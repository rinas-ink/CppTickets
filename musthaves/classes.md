# Классы

**Определение класса, конструктор, методы**

* Определение: сказали слово `struct` (или `class`), завели какое-то количество полей/членов (
  members)
  . [Пример](https://github.com/hse-spb-2021-cpp/lectures/blob/master/03-210916/02-struct/01-struct.cpp)
* Для классов работает объявление, в таком случае внутри объявляем функции и переменные, но потом
  определяем их через `Point::smth`.
* Конструктор создаёт объект класса и инициализирует его поля. Конструкторы можно объявлять от
  разных типов и от разного количества переменных, это всё перегрузки. Синтаксис:

```c++
struct Point {
    int x, y;
    
    Point(int x_, int y_) { // конструктор от двух интов
        x = x_;
        y = y_;
    }
};
```

* Методы (member functions, функции-члены) - это функции, определенные в классе. Они имеют доступ к
  его полям и особый синтаксис: `p.dist()` - вызвали метод `dist` у объекта `p` класса `Point` из
  примера. У методов есть неявный аргумент - объект класса, на котором мы его вызываем.
* `class` и `struct` отличаются друг от друга только уровнем защиты: все мемберы `class` - `private`
  по-умолчанию, все мемберы `struct` - `public` по-умолчанию.

**Приватные, публичные и защищенные поля/методы**

* `public:` такие поля и методы видны всем и отовсюду, для них работает обращение
  через `class_object.smth`. Проблема: кто угодно может залезть внутрь класса и, например, случайно
  попортить важный инвариант.
* `private:` видны только самому объекту класса, его методам, функциям-друзьям и
  классам-друзьям(`friend`), но не детям.
* `protected:` видны только самому классу и его наследникам (а что там с друзьями происходит, никто
  не знает (даже Егор)).
* Друзья: внутри класса объявляется функция (или класс; как обычное объявление, только начинается со
  специального слова `friend`), теперь она имеет доступ ко всем его приватным полям.

**Наследование**

* Синтаксис: `struct Derived : Base {};`. У `Derived` есть свои поля/методы и дополнительно всё то,
  что было у `Base` (по модулю уровня доступа)
  . [Пример](https://github.com/hse-spb-2021-cpp/lectures/blob/master/09-211110/01-basic.cpp)
* Конструкторы не наследуются. Если хотим для `Derived` добавить конструктор, то в нём обязаны
  сконструировать базовый класс. Синтаксис: `Derived(params) : Base(base_params), other_members {}`
  . [Пример](https://github.com/hse-spb-2021-cpp/lectures/blob/master/09-211110/05-ctors.cpp)
* Если ничего не конструировать в явном виде, в конструкторе `Derived` вызовется конструктор `Base` по-умолчанию.
* Типы
  наследования: [Пример](https://github.com/hse-spb-2021-cpp/lectures/blob/master/10-211117/02-extra/20-inheritance-visibility.cpp)
    * `public`: по-умолчанию для структур, наследнику видны все поля и методы.
    * `protected`: делает тот факт, что мы унаследовались, защищенным. Внутри наследников
      пользоваться полями и методами предков можно (если они не приватные), а снаружи - нет. Также
      снаружи нет совместимости по ссылкам: наследник не кастится к базовому классу (нормальными
      плюсовыми кастами, сишным кастом получится).
    * `private`: по-умолчанию для класса. Факт, что мы унаследовались, известен только самому
      наследнику и никому больше (даже его наследникам). Внутри можно пользоваться полями и методами
      базового класса (не приватными), снаружи - нет. Апкасты к `Base` тоже недоступны снаружи.
