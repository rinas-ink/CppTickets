# Использование move-семантики

**Эффективная инициализация полей класса из аргументов по
значению** [Егор](https://github.com/hse-spb-2021-cpp/lectures/blob/master/13-211208/02-move-objects/03-move-to-field.cpp)

* Принимаем в конструкторе аргумент по значению, а затем муваем его в поле. Таким образом мы
  разделяем процесс: аргумент разрешаем инициализировать как угодно (самым быстрым образом), а потом
  бесплатно муваем его в поле и удаляем пустой объект. Итого получили одну потенциально долгую
  инициализацию и две бесплатных штуки (если, конечно, мув и удаление для такого объекта работают
  быстро)
  . [Пример](https://github.com/hse-spb-2021-cpp/lectures/blob/master/13-211208/02-move-objects/03-move-to-field.cpp)
* Вызов такого конструктора от:
    * переменной - 1 копирование + 1 мув + 1 удаление (+- норм)
    * временного объекта - 1 инициализация + 1 мув + 1 удаление (быстро)
    * функции, которая возвращает объект - 1 инициализация в функции, 1-3 мува, 1-2 удаления (
      быстро)

**Moved-from
состояние** [Егор](https://github.com/hse-spb-2021-cpp/lectures/blob/master/13-211208/02-move-objects/04-moved-from-state.cpp)

* Перемещение происходит только из объекта куда-то. Простой `std::move(smth)` ничего не делает.
* Мув из `unique-ptr` в `unique-ptr` гарантирует, что первый станет `nullptr`.
* Для всего остального такой гарантии нет, они входят в `moved-from` состояние. Содержание таких
  объектов не гарантируется (могут быть пустыми, половинчатыми, полными и вообще какими угодно), но
  гарантируется их корректность.

**Отсутствие необходимости `move` из результата функции, возвращенного по значению**

* Если мы возвращаем локальную переменную из функции, компилятор видит это и мувает автоматически,
  т.к. локальная переменная в любом случае умрёт после `return`.

**Необходимость `move` для передачи владения `unique_ptr`**

* Копировать `unique_prt` нельзя, потому что он `unique`, очев же (это сделано, чтобы случайно не
  скопировать значение и не вызвать конфликты). `std::move(foo)` говорит, что из переменной `foo`
  можно забрать значение (передать владение), тогда `foo` занулится.
