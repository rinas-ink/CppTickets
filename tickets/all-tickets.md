<details>
<summary>
 Билет 10. Базовый синтаксис
</summary>


### Встроенные типы

[типы](https://en.cppreference.com/w/cpp/language/types)
int - целые числа, в стандарте - минимум 2 байта, обычно 4. Диапазон значений от -2^31 до 2^31 (от −2 · 10^9 до 2 ·
10^9).

double - вещественные, обычно 8 байт, диапазон приблизительно 18 единиц. Двоичные числа хранятся приблизительно +
двоичной системе счисления, поэтому стоит быть аккуратными, например 0.1 + 0.2 != 0.3

long long - обычно 8 байт, от -2^63 до 2^63  (−9 · 10^18 до 9 · 10^18)

bool - обычно 1 байт, true(1) / false(0), по историческим причинам причисляется к
целочисленным   [примеры](https://github.com/hse-spb-2021-cpp/lectures/blob/master/02-210909/01-trivial-types/01-bool.cpp)

char - обычно 1 байт и знаковый, диапазон от -128 до 127, в арифметике ведет себя как
целочисленный: [примеры](https://github.com/hse-spb-2021-cpp/lectures/blob/master/02-210909/01-trivial-types/03-char.cpp)

signed - знаковый, обычно не надо дополнительно это указывать

unsigned - беззнаковый, значения из отрицательного диапазона перекидываются в положительный (unsigned int от 0 до 2^32),
переполнение - берется по модулю (переполнение знакового - UB!).

### Литералы

Литералы - это значения, которые вставляются непосредственно в код.
[примеры](https://github.com/hse-spb-2021-cpp/lectures/blob/master/02-210909/01-trivial-types/04-literals.cpp)

#### Целочисленные

* префикс - основание (СС). Есть 0b, 0 (просто 0), 0x.
    * 0b -- двоичная система счисления,
    * 0 -- восьмеричная система счисления,
    * 0x -- шестнадцатеричная система счисления.
* суффикс: U -- unsigned, L -- long, LL -- long long

К примеру: `0xdeadbeefU` -- беззнаковый инт 3735928559.

#### Вещественный

По умолчанию вещественные числа имеют тип `double`, можно добавить суффикс `f` для `float` и `L` для `long double`.

#### Символьный

Символьная константа в ' ' или обратный слеш + символ (
например [escape-последовательности](https://en.cppreference.com/w/cpp/language/escape)), применяются коды из ASCII или
Unicode.

### Строковые литералы

[строковые и символьные литералы](https://docs.microsoft.com/ru-ru/cpp/cpp/string-and-character-literals-cpp?view=msvc-170)
Строковый литерал – последовательность символов в " " с завершающим нулем. raw string literal - необработанные строковые
литералы [пример](https://www.geeksforgeeks.org/raw-string-literal-c/)

### Склейка подряд написанных строковых литералов на этапе компиляции

```c++
    std::string s1 = "hello" "world"; //препроцессор склеит в один строковый литерал
    std::string s2 = "he\n\t\xFF" R"foo(Hello World)foo"; //и обработает все эти штуки 
    "AB" + "CD"; //не скомпилируется
```

### static_cast<>

Приведения типов, есть еще вариант в стиле C - (int), но со сложными типами static_cast<> безопаснее Пример избавления
от переполнения при умножении int'ов.

```c++
int x = 1e9; 
long long y = x * x; 
```

Будет UB, тк выполнится вначале правая часть int * int = int, а тут переполнение типа. Решение:

```c++
int x = 1e9; 
long long y = static_cast<long long> (x) * x; 
```

### Разница между i++ и ++i.

i++ - возвращает значение, увеличивает  
++i - наоборот

```c++
a = b++; // a = b; b++;
a = ++b; // b++; a = b;
```

### Составные операторы присваивания

сокращенные операторы присваивания типа *=, /=, %= Возвращают ссылку на объект
` y = x += 10; // x+= 10; y = x;`

### Expression и statement

expression - выражение, что-то вычисляющее значение: выражения, вызовы функций, обращения к
переменной [примеры](https://en.cppreference.com/w/cpp/language/expressions)
statement - инструкция, команда. Что-то типа if, while, for, объявления
переменных [примеры](https://en.cppreference.com/w/cpp/language/statements)
[пример с лекции](https://github.com/hse-spb-2021-cpp/lectures/blob/master/05-210930/00-before/00-comma.cpp)
[типы expression](https://docs.microsoft.com/en-us/cpp/cpp/types-of-expressions?view=msvc-170)

### Оператор ,

[этот же пример с лекции](https://github.com/hse-spb-2021-cpp/lectures/blob/master/05-210930/00-before/00-comma.cpp)
Объединяет выражения, вычисляет их, возвращает результат правого. Циклы через запятую не записать, тк это statement. Еще
используется, когда несколько параметров в цикле. Еще пример (у запятой низкий приоритет):

```c++
a = b, c; // a = b
a = (b,c); // a = c
```

### Синтаксис: for, while, if.

E - expression, S - statement

```c++
for(E,E,E)
    S
```

[цикл](https://en.cppreference.com/w/cpp/language/for)
например:

```c++
for (int i = 0; //происходит перед циклом 
i < n; //проверяется перед каждой итерацией 
i++) { //выполняется в конце каждой итерации 
} 
```

break - выход из цикла continue - следующая итерация

```c++
while(E)
    S
```

```c++
if(E) // еще может быть if(<создание переменной>; E)
    S1
else 
    S2
```

### Тернарный оператор

<проверяемое условие> ? <оператор выбора 1> : <оператор выбора 2>
Может возникнуть проблема,когда ветки разных типов, тогда непонятно, какой тип возвращать:
[пример с лекции](https://github.com/hse-spb-2021-cpp/lectures/blob/master/04-210923/01-functions/02-lcm.cpp)
[таймкод](https://youtu.be/f2aiF6dQQ7c?t=217)

### Range-based for

[cppreference](https://en.cppreference.com/w/cpp/language/range-for)
Вместо for (int i = 0; i < n; ++i) - for (int x : vec) - инициализируется новая переменная x на каждой итерации, в
которую копируется элемент вектора. Если взять по ссылке:
for (int &x : vec)
то можно изменить значение переменной в векторе, копирования не происходит. Константная ссылка - нельзя изменить
значение переменной, копирования не происходит.

auto - в некоторых контейнерах удобнее писать auto it, чем typename std::set<int>::iterator it; Каким типом будет auto
определяется во время компиляции Можно использовать auto, когда храним пары или некоторые структуры, итерируемся по map.
[примеры](https://github.com/hse-spb-2021-cpp/lectures/blob/master/03-210916/01-extra-stl/03-map.cpp)
`auto a; // не скомпилируется`

### Порядок вычислений

[ссылка](https://notes.algoprog.ru/cpp/additional.html#id4)
Если вкратце:
порядок вычислений аргументов функций происходит на усмотрение компилятора, когда он хочет что-то соптимизировать в
логических операторах  `if(i < v.size() && v[i] == 0)` - порядок слева направо инициализация переменных в порядке
объявления
`f(), b() // через запятую тоже все в порядке`
при инициализации при помощи {} (обычно у вектора) порядок тоже слева направо в стандарте C++17 в некоторых выражениях
зафиксирован порядок вычислений: слева-направо вычисляются выражения при вводе через >> и выводе через << . При
присваивании через =, += и похожие операторы: сначала вычисляется часть справа, а потом часть слева. Пример:

```c++
int a,b;
a = b = 5; // b = 5; a = b;
```

если бы порядок был другой, получили бы UB


</details>

<details>
<summary>
 Билет 11. Объявление объектов внутри одного файла
</summary>


* ### Объявление и определение: функции, класса

Компилятор - штука старая, совместимая с Си, поэтому компиляция идет по файлу сверху вниз. (в общем это правда, НО в
структурках сделали, как у нормальных людей, тк тут на надо было в обратную совместимость)

**Declaration**(forward) - объявление для того, чтобы показать компилятору, что существует такая функция/класс, чтобы
можно было использовать раньше, чем мы написали реализацию.

**Definition** - определение, прописываем реализацию

В этом примере можно просто поменять порядок и не нужно будет объявлять

```c++
    void foo(); // declaration
    // еслли без этого, мы хз че такое foo в print() ниже
    
    struct Iam{ // definition
        void print(){
            cout << "I am";
            foo();
        }
    };
    
    void foo() { // definition
        cout << "tired";
    }
```

* ### Взаимная рекурсия для: функций, классов, методов внутри одного класса, методов между классами (A::foo() возвращает B и наоборот).

    * Функции

      Могут быть кеки, вида одна фукнция запускает дургую и наоборот, тогда без forward declaration мы не скомпилимся.

        ```c++
        void bar(int n);  // declaration, объявление
        // void bar(int = 10);  // declaration, объявление
        // Default arguments are better be specified in declaration.
        
        void foo(int n) {  // definition, определение
            std::cout << "foo " << n << "\n";
            bar(n - 1);
        }
        
        void bar(int n) {  // definition, определение
            std::cout << "bar " << n << "\n";
            if (n == 0) {
                return;
            }
            foo(n - 1);
        }
        
        int main() {
            bar(10);
        }
        ```
    * Методы внутри класса

      Как я писал выше, в структурках сделали как у белых людей, те мы видим все, что лежит у нас в структуре:
        ```c++
        struct Foo{
            void foo() {
                cout << 1;
                bar();
            }
            void bar() {
                cout << 2;
            }
            struct Bar{};
        };
        
        int main(){
            Foo::Bar b; // 
        }
        ```
    * Классы

      Ну кста методы можно просто объявить в структурке, а объявлять в наруже(через Foo::)

      Можем хранить только указатели, ветора... кароче штуки, котрым пофиг на размер того, что ты им подсунул(вектора
      там чет себе на куче делает, указатель - и в Африке указатель)
        ```c++
        struct Bar;

        struct Foo {
            // Bar b - так нельзя, тк мы не знаем сколько байтов занимает Bar, да и вообще бесконечная глубина
            Bar *b;
            std::vector<Bar> bs;
        };
        
        struct Bar {
            Foo f;
        };
        ```

      А теперь бахнем взаимную рекурсию:

      Было(не работает шо пипец):
        ```c++
            struct Foo {
                operator Bar() {
                    return Bar{};
                }
            };

            struct Bar {
                Bar() {}
                Bar(Foo /*arg*/) {}
            };
            
            int main() {
                Foo f;
                Bar b = f;  // ambiguous
            }
        ```
      Сначала мы не знаем, что Bar() - тип, для этого fwd declaration.  
      Получилось, что Bar - incomplete, мы не знаем что за мусор в Bar, когда пытаемся сделать оператор преобразования к
      Bar. Ну тогда просто реализуем этот метод после того, как узнаем про Bar(в Питере - пить!). Получили, что и
      хотели, что преобразование типов(в мэйне) неоднозначно(надо еще explicit куда-нибдь бахнуть и норм)         
      Стало:

        ```c++
            
            struct Bar;  // incomplete type

            struct Foo {
                operator Bar();
            };

            struct Bar {
                Bar() {}
                Bar(Foo /*arg*/) {}
            };
            
            Foo::operator Bar() {
                return Bar{};
            }
            
            int main() {
            Foo f;
            Bar b = f;  // ambiguous
            }
        ```
* ## Incomplete type: как объявить, что можно сделать с неполным типом.

Incomplete - это тип, который описывает идентификатор, но не содержит информацию, необходимую для определения размера
идентификатора. Типо мы не знаем его размер, тк пока только объявили, но можем указатели тыкнуть или в векторочек
положить, ссылками на него побаловаться итп
смотри [сюда](https://github.com/hse-spb-2021-cpp/lectures/tree/master/06-211006/09-incomplete). Мы можем просто
объявить не полный тип, пожонглировать его ссылками, не заглядывая под капот чего там происходит.

* ## Namespaces

Если есть две одинковые по назавнию и параметрам функции, переменные итп, которые делают что-то разное, то мы можем из
обернуть в пространства имен, чтобы уметь обращаться к нужной.

```c++
void foo(){
    cout << "global foo";
};
void  some_glob(){
    cout << "global kek";
};
namespace ns1{
void bar(){
    cout << "В Питере - пить!";
}
void foo(){
    cout << "foo1";
    bar();
    some_glob();
};

}
namespace ns2{
void foo(){
    cout << "foo2";
};
}
int main() {
    ns1::foo();
    ns2::foo();
    ::foo() // то же самое, что foo() - в глабольном namespace
}
```
Кста в нэймспейсах важен порядок в котором мы объявляем функции(те не как в классах), идем сверзу вниз.

Можем сделать их вложенными(читаем комментики):

```c++
void foo() {
    std::cout << "foo global\n";
}

void some_global() {
    std::cout << "some_global\n";
}

namespace ns1 {
void bar() {
    std::cout << "ns1::bar()\n";
}

namespace ns2 {
void bar() {
    std::cout << "ns1::ns2::bar\n";
}
}  // namespace ns2

namespace ns3 {
void botva_ns3() {
    std::cout << "botva_ns3()\n";
}
}  // namespace ns3

namespace ns3::ns4 { // просто сделали короче, чтобы не писать ns3 внутри котрого писать ns4
namespace ns1 {  // ns1::ns3::ns4::ns1 
    // !!!ДА, просто такое же имя, но другой namespace
}

void baz() {
    botva_ns3();  // unqualified name lookup for 'botva_ns3'
    ns2::bar();  // unqualified name lookup for 'ns2', qualified name lookup bar()
    // ns2::foo();  // compilation error: no 'foo' inside 'ns2'
    // ns1::ns2::bar();  // thinks that 'ns1' is 'ns1::ns3::ns4::ns1', 'n2' not found
    ::ns1::ns2::bar(); // qualified 
}
}  // namespace ns3::ns4
}  // namespace ns1

int main() {
ns1::ns3::ns4::baz();
}
```

Кста qualified - это найти при помощи unqualified нужное место, а потом просто посмотреть внутрь.

Unqualified - он поднимается по уровнням наверх, когда найдет - остановится.(а лол это 13 билет, но тут без этого - никуда)

Мем: если namespce на одном уровне вложенности и называются одинаково, то это один namespace(ns3), если на разных, но название совпало, то это разные(s1 и s1::s3::s4::s1) 

Читаем комменты, кто проникся? 

По факту надо что запомнить: если без двоеточия в начале, то мы поднимаемся наверх, пока не найдем че хотели(интересует первый раз когда найдем первый наймспейс в пути(самую левую в объявлении)) потом - тупо идем вниз по остатку пути

Если есть двоеточие, то идем на самый верх(глобальную мусорку) и спускаемся с нее по пути
* ### Псевдонимы типов typedef, using

Кароче просто хотим по-своему типы называть, есть 2 способа(дефайн для лохов), который чисто синтаксически различаются(
typedef неудобный, но обратная совместимость). После компиляции - не отличить псведоним от исходного

Егор на вопрос в чем разница: "Но вроде есть какой-то баг в
GCC: https://stackoverflow.com/questions/48613758/using-vs-typedef-is-there-a-subtle-lesser-known-difference"

```c++
#include <vector>
#include <utility>
#include <typeinfo>
#include <iostream>

typedef std::vector<int> vi;
using pii = std::pair<int, int>;
// Please do not #define: it does not respect namespaces/private/public
// https://stackoverflow.com/a/1666375/767632

int main() {
    vi v1(10);
    std::vector<int> &v2 = v1;
    std::cout << typeid(v1).name() << "\n";
    std::cout << typeid(v2).name() << "\n";

    pii p1(10, 20);
    std::pair<int, int> &p2 = p1;
}
```

* ### Че по using namespace

Обычно пишется внутри какого-то отдельного кусочка программы (то есть не глобально), потому что иначе можем произойти
коллизия имен. Прикольны пример [04-210923/01-functions/02-lcm](https://github.com/hse-spb-2021-cpp/lectures/blob/master/04-210923/01-functions/02-lcm.cpp). Там мы делаем лонговый лцм, но вызываем от интов,
вызовется стандтартная функция(спс namespace std), мы там переполняемся и дохнем.

</details>

<details>
<summary>
 Билет 12. Объявление переменных
</summary>

Скраденно подчистую
* ###Объявление нескольких переменных, указателей, ссылок, в том числе константных.
Скомунизжено у нынешнего 2го курса
```c++
int a = 10, b = 11;
int lol = 5, kek = lol; 
const int c = 12;
int &x = a;
const int &y = b; //нельзя менять значение по ссылке
int *z = &a;
const int *w = &a; //нельзя менять значение по указателю
int * const q = &a; //нельзя перекинуть указатель на другой объект
const int * const e = &c; //нельзя два пункта выше
int * const r = &c;
//не компилируется, так как нет запрета на изменение значения
int &g = c;
//не компилируется, так как нет запрета на изменение значения
```
* ###Создание временного объекта.
Хз че тут рассказать, вот [статья](https://docs.microsoft.com/en-us/cpp/cpp/temporary-objects?view=msvc-160)
Ну а по факту - мы когда что-то вычисляем(a + b + c) или возвращаем из фукнций по значению, создаются временные объекты, куда эта радасть складывается, чтобы доделать вычисления и сдохнуть, как оно больше не нужно.

* ###Инициализация
[тут вроде нормас(нужно читать до The most vexing parse, он в некст билете)](https://github.com/vladnosiv/hse-spb-conspects-2020/blob/master/C%2B%2B/ticket32.md#%D0%B1%D0%B8%D0%BB%D0%B5%D1%82-32-%D0%B2%D0%B8%D0%B4%D1%8B-%D0%B8%D0%BD%D0%B8%D1%86%D0%B8%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8)
* ###Неинициализированные переменные/поля.
Кароче стандарт не гарантирует, что если вы не проинициализировали свои буковки, то там не будет мусора, полезете туда - UB. Хотя в случае глобального простравнста имен это кажется правда, что там стандартное значение
* ###Инициализация при помощи {}:
    * Для тривиальных типов. (заполняет стандартным занчением)
    * Для нетривиальных типов. (вызывает соответствующий конструктор)
    * Для массивов/векторов, в том числе вложенных. 
    * Временных объектов: с указанием типа (T{}, T()) и без указания типа ({}).
 
Опять воруем:
```c++
struct foo() {
int x, y, z;
}
int a{}; // a = 0(дефолтное значение инта)
int a{12}; //a == 12
vector<int> b = {3, 2}; //b[0] = 3, b[1] = 2
vector<int> b{3, 2}; //b[0] = 3, b[1] = 2
vector<vector<int>> mas{{1, 2}, {3, 4}};
vector<vector<int>> mas = {{1, 2}, {3, 4}};
foo f{1, 2} //f.x = 1, f.y = 2, f.z непроинициализированно
foo g{1, 2, 3}; //g.x = 1, g.y = 2, g.z = 3
vector<pair<int, int>> c;
c.push_back({2, 3});
//создали временный объект, компилятор сам понял, какой тип
c.push_back(std::pair<int, int>(2, 4));
c.push_back(std::pair<int, int>{2, 4});
```
* ###Пример, где инициализация через {} и () компилируются и ведут себя по-разному.
```c++
vector<int> a(3, 2); - вектор из трех двоек
vector<int> a{3, 2}; - вектор из тройки и двойки.
```
* ###Ссылки.
  * Можно ли отличить ссылку от объекта, на который она указывает.
    
    Ссылки обычно ведут себя идентично значениям, на которые они ссылаются. В этом смысле ссылка работает как псевдоним объекта, на который она ссылается. Еще можно воспользоваться `std::is_reference(T)` ([ссылка](https://en.cppreference.com/w/cpp/types/is_reference))
  * Использование константных ссылок.
    
    Они же ссылки на константные значения
    ```c++
        const int value = 7;
        const int &ref = value; // ref - это ссылка на константную переменную value
    ``` 
    
  * Константная ссылка не обещает, что объект не меняется (если ссылка на мутабельный объект).

    Как и в случае с указателями, константные ссылки также могут ссылаться и на неконстантные переменные. При доступе к значению через константную ссылку, это значение автоматически считается const, даже если исходная переменная таковой не является:
    ```c++
    int value = 7;
    const int &ref = value; // создаем константную ссылку на переменную value

    value = 8; // ок: value - это не константа
    ref = 9; // нельзя: ref - это константа
    ```
* ###auto и его модификации, как выводится тип(Вывод приватного типа или типа лямбды)
Авто откидывает всю константость и ссылки(если это хотим надо явно прописать).
Есть исключения.
```c++
int val = 10;
int &foo() {
    return val;
}
const int &bar() {
    return val;
}

int main() {
    {
        [[maybe_unused]] auto x = foo();  // int
        [[maybe_unused]] auto &y = foo();  // int&
        [[maybe_unused]] const auto &z = foo();  // const int&
    }
    {
        [[maybe_unused]] auto x = bar();  // int
        [[maybe_unused]] auto &y = bar();  // const int&
        [[maybe_unused]] const auto &z = bar();  // const int&
    }
}
```
Про тип лямбды:

У лямбды просто так нельзя выписать тип, так как лямбда -- синтаксический сахар над функторами, поэтому каждая лямбда имеет свой тип.

Поэтому можно либо пользоваться `std::function`, либо `decltype` (который, кстати, работает во время компиляции): 
```c++
int main() {
    auto l1 = [](int a, int b) { return a > b; };
    auto l2 = [](int a, int b) { return a > b; };
    std::set<int, decltype(l1)> s1(l1);
    // std::set<int, decltype(l1)> s2(l2); - сдохнет, тк типы разные, хоть лямбды и одинаковы
}
```

</details>

<details>
<summary>
 Билет 13. Подробности именования сущностей
</summary>

- ###[[maybe_unused]] 
используется для уведомления компилятора о том, что
сущность может быть не использована в программе и следует подавлять
соответствующее предупреждение.
- ###The most vexing parse
    Текста внутри оч мало, не боимся.
    - [сэнкс что уже есть](https://github.com/vladnosiv/hse-spb-conspects-2020/blob/master/C%2B%2B/ticket32.md#the-most-vexing-parse)
    - [примеры с наших лекций, нужен 2 файл](https://github.com/hse-spb-2021-cpp/lectures/tree/master/05-210930/02-declare-define)
    - [про структурки, с лекции](https://github.com/hse-spb-2021-cpp/lectures/tree/master/06-211006/00-past)
- ###Допустимые имена переменных, функций, констант, классов:
    - Нельзя начинать с цифры.
    - Ключевые слова - бан([список](https://en.cppreference.com/w/cpp/keyword))
    - C `_` кеки(UB)([все ошибки](https://stackoverflow.com/questions/228783/what-are-the-rules-about-using-an-underscore-in-a-c-identifier)):
        * Нельзя с него начинать глобальные имена
        * Двойное => бан(только компилятор так может)
        * Начинаем с `_`, а потом заглавная буква.
        * `_t` - не UB(по стандарту), но POSIX(бубнта и макосось) по кеку зарезервировал некоторые имена, можно огрести
    - Последствия - повезло/UB самые разные кеки[(пример с кфа про _end)](https://codeforces.com/blog/entry/17747)
- ###Structured binding для пар, простых структур, массивов, со ссылкой
    [ссыль на пример лекции](https://github.com/hse-spb-2021-cpp/lectures/blob/master/03-210916/01-extra-stl/02-structured-binding.cpp)
    ```c++
    auto [a, b, c] = std::tuple(32, "hello"s, 13.9);
    auto [a, b] = foo();//foo() возвращает пару
    ///пара со ссылкой
    std::pair<int,int> f;
    auto &[a, b] = f; //тогда a/b привяжутся к её first/second
    /////простые структуры
    struct Point {int x, y;};
    Point p = { 1,2 };
    auto[ x, y] = p;
    //фиксированные массивы
    int arr[3] = { 1, 2, 3 };
    auto[x, y, z] = arr;
    ```
    - minmax trouble
    
    Функция возвращает пару, но паруу ссылок на значения, а биндинг просто копирует, ну молодец, огребай
    ```c++
    {
        std::pair<int, int> p = std::minmax(30, 20);
        std::cout << p.first << " " << p.second << "\n";  // Ok!
    }
    {
        auto [x, y] = std::minmax(30, 20);
        std::cout << x << " " << y << "\n";  // UB
    }
    ```
- ###Поиск имён
    - Квалифицированный и неквалифицированный поиск, порядок обхода вложенных namespace
        
        [вай +10 минут сна мне](https://github.com/vladnosiv/hse-spb-conspects-2020/blob/master/C%2B%2B/all-tickets.md#%D0%B1%D0%B8%D0%BB%D0%B5%D1%82-03-%D0%BF%D1%80%D0%B0%D0%B2%D0%B8%D0%BB%D0%B0-%D0%BF%D0%BE%D0%B8%D1%81%D0%BA%D0%B0-%D0%B8%D0%BC%D1%91%D0%BD-%D0%B3%D0%BB%D0%BE%D0%B1%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D1%85-%D0%B8-%D0%B2%D0%BD%D1%83%D1%82%D1%80%D0%B8-%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%BE%D0%B2)
    - Отличие между std:: и ::std::
      Если вы пишете нормальный код и его не будут исопльзовать через левое ухо, то это одно и тоже. 
      
      НО если кто-то сделает стурктуру/namespace с именем std(он обязательно в каком-то namespace, тк в std нельзя ничего вставлять, это UB)
      То может произойти примерно вот такой кек: 
      ```c++
        #include <iostream>
        int main() {
          struct std{};
          std::cout << "fail\n"; // Error: unqualified lookup for 'std' finds the struct
          ::std::cout << "ok\n"; // OK: ::std finds the namespace std
        }

      ```
    - ADL (argument-dependent lookup) для операторов и функций
      Видимо мы еще не прошли таааак глубоко [Версия от Влада](https://github.com/vladnosiv/hse-spb-conspects-2020/blob/master/C%2B%2B/all-tickets.md#%D0%B1%D0%B8%D0%BB%D0%B5%D1%82-04-adl) - Там чет сильно больше, чем у нас было(вроде), 
      
    попробую нашу версию:
      
      ```c++
      // Argument-Dependent Lookup aka Koenig Lookup

        namespace ns {
        struct Foo {};
        
        void do_something() {}
        void do_something(Foo) {}
        bool operator==(const Foo&, const Foo&) { return true; } // то ради чего все
        };
        
      int main() {
        // do_something(); - а шо ты хочешь когда так пишешь?
        ns::do_something(); // ну так можно
    
        // Foo f;
        ns::Foo f; // Так заработает тк теперь мы будем смотреть на все наймспейсы где лежат аргументы
        do_something(f);  // unqualified name lookup, ADL enabled
       
        // вот он, настоящий пельмень:
        // f == f;
        // operator==(f, f)
        // ns::operator==(f, f);
    
        // Example:
        // getline(std::cin, str)
        // Better: std::getline
        //
        // std::vector<int> v{1, 2, 3};
        // sort(v.begin(), v.end());  // v.begin() ~ std::vector<int>::iterator ~(?) int*
        // Better: std::sort
      }
    
      ```
    - Hidden friend
      
      friend-function's внутри пространства имен, которые объявлены в связанном классе видны для ADL, даже если не видны для других поисков.
      
      [Влад гений](https://github.com/vladnosiv/hse-spb-conspects-2020/blob/master/C%2B%2B/all-tickets.md#hidden-friend-%D0%BF%D1%80%D0%B0%D0%BA%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5-%D0%BF%D0%BE%D1%81%D0%BE%D0%B1%D0%B8%D0%B5-%D0%BF%D0%BE-%D0%BF%D0%BE%D0%B8%D1%81%D0%BA%D1%83-%D0%B4%D1%80%D1%83%D0%B7%D0%B5%D0%B9)
      
      [Еще в 23 билете про это классно написали, ну и просто инфа про друзей итп есть](https://github.com/khbminus/CppTickets/blob/master/tickets/ticket23.md#%D0%B4%D1%80%D1%83%D0%B7%D1%8C%D1%8F-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8)
- ###Shadowing переменных в рамках одной функции

(скоммуниздил с [хабра](https://habr.com/ru/company/vk/blog/341584/), use ctrl+f)
  
Скрытие переменной (Variable shadowing) происходит, когда переменная, объявленная в одной области видимости (например, блоке или функции), имеет такое же имя, как и другая переменная, определённая во внешней области видимости. Тогда внешняя переменная будет скрыта внутренней
```c++
bool x = true;                                              // x is a bool
auto f(float x = 5.f) {                                     // x is a float
    for (int x = 0; x < 1; ++x) {                           // x is an int
        [x = std::string{"Boo!"}](){                        // x is a std::string
            { auto [x,_] = std::make_pair(42ul, nullptr);}  // x is now unsigned long
        }();
    }
}
```  

        
</details>

<details>
<summary>
 Билет 14. Функции
</summary>

* ## Параметры
  * ### Синтаксис (пропущенное имя, значение по умолчанию в объявлении/определении)  
  У функции есть объявление и определение, хотя обычно они пишутся сразу вместе. У функции есть тип, название, в круглых скобках передаются параметры, в фигурных само тело функции.  
  ```C++
  void foo(int a, int b){}
  void foo(vector v = {1, 2, 3}){} // параметр по умолчанию
  ```
  Вот так будет выглядеть, если хотим разделить объявление и определение.  
  ```C++
  void foo(int a, int b);
  void foo(int a, int b){
     return a + b;
  }
  ```
  Это может быть полезно, например когда мы хотим использовать две функции друг в друге. При этом одна из них будет определена всегда равньше другой, поэтому приходится придегать к `Forward decloration`. То есть мы говорим, что такая функция есть, и мы можем её вызывать, но вот её определение мы попозже напишем.
  ```C++
  int bar(int x);
  int foo(int y){
      return bar(y - 1) + 1; // OK
  }
  int bar(int x){
      if(x <= 0) return 1;
      return foo(x - 1);
  }
  ```
  Ещё один случай, когда у нас есть несколько единиц трансяции. В этом случае там так же иногда приходится использовать функцию в единице трансляции отличной от той, где мы собственно эту функцию определяем. Поэтому приходится в каждой отдельной единице трасляции писать объявление, если мы хотим использовать функию.  
  Можно в качестве параметра использовать агрумент без имени, указав только его тип. Это, например, используется, чтобы различять префиксный и постфиксный декриметны и инкременты. Обратиться к переданному таким образом аргументу внутри функции не получится. При этом распалагать их можно в перемешку с обычными аргументами, но до агрументов со значениями по умолчанию.  
  ```C++
  void foo1(int a, int, int b, int, int, int c = 100){} // OK
  void foo2(int a, int, int b, int, int, int c = 100, int){} // Compilation error
  void foo3(int a, int, int b, int, int, int c = 100, int = 1){} // OK
  ```
  Аргументы со значениями по умолчанию всегда идут после всех остальных. Можно передавать им новые значения при вызове функции. Задать значение по умолчанию можно как в объявлении, так и в определении функции, но только либо там, либо там.
  ```C++
  void foo1(int c = 100);
  void foo1(int c){
    std::cout << c; // Выводит 100
  }
  ```  
    
  * ### Передача параметров по: значению, `&`, `const&`. Что выбрать и почему.  
  Аргументы в функцию можно передавать по значению, по ссылке, по константной ссылке. Если передавать по значению, то в функцию копируется переданный аргумент. Если по ссылке, то берётся ссылка на переданный агрумент (то есть если теперь его поменять внутри функции, то он поменяется и в том месте, где была вызвана функция). Передача аргумента по константной ссылке не даёт нам изменять его внутри функции.  
  Передача по ссылке нужна, если мы хотим как-то модифицировать переданный аргумент в функцию.  
  Передача по константной ссылке нужна, если мы не хотим менять наш объект внутри функции. При этом, копировать его лишний раз слишком дорого (например копировать матрицу 1000 на 1000 элементов, по которой мы хотим лишь разок пробежаться, не редактируя её, тупо, потратим на это кучу лишнего времени), поэтому лучше передать его по ссылке и запретить редактирование.  
  Отдельный разговор про верменные объекты. Если передать врементый объект в функцию как параметр, то либо по значению, либо по константной ссылке. По ссылке не получится (обычно не скомпилируется, но можно это как-то обойти и получить UB). При передаче временного объекта по константной ссылке, время его жизни продлевается.  
  ```C++
  size_t foo(const std::vector<int> &a){
      return a.size(); // 3
  }
  int main() {
      std::cout << foo({1, 2, 3});
  }
  ``` 
  Из-за этой фичи легальными являются и такие конструкции, где время жизни опять же продлевается.  
  ```C++
  int main() {
      const std::vector<int> &a = std::vector<int>{1, 2, 3};
      std::cout << a.size(); // 3
  }
  ``` 
  * ### Передача `{}` в параметры.  
  Компилятор умная штука. Можно передавать что-то в фигурных скобках, он по контексту догадается, чем это должно быть. Например тут он преобразует это в вектор интов. Это так называемое `List-initialization`. (см. соответствующий билет)
  ```C++
  void foo1(std::vector<int> arr){}
  int main() {
      foo1({1, 2, 3});
  }
  ```  
  * ### Неименованый параметр и `[[maybe_unused]]`  
  Неименованный параметр подробно описан выше. Вместо него можно использовать аргумент с каким-то фиктивным названием и пометить его `[[maybe_unused]]`  
  Приведу ещё один пример, где это используется: теги в аргументах функции. Мы заводим две фиктивные структуры с говорящими именами, делаем перегрузку функции. В одном месте передаём фиктивный параметр типа первой структуры, во второй функции фиктивный параметр второй структуры.  
  ```C++
  struct multi_five{};
  struct multi_ten{};
  int foo(int a, multi_five){
      return a * 5;
  }
  int foo(int a, multi_ten){
      return a * 10;
  }
  int main() {
      foo(1, multi_five{}); // 5
      foo(1, multi_ten{}); // 10
  }
  ```  
  
* ## Возвращаемое значение
  * ### Возврат по значению, ссылке, константной ссылке.  
  При возврате по значению, возвращаемый объект будет копироваться в переменную, куда вы его запишите.  
  При возврате по ссылке, функция возвращается ссылку на объект. Поэтому стоит быть аккуратным. В следующем примере пытаемся вернуть ссылку на локальную переменную, которая уберётся со стека после окончания выполнения функции, поэтому получаем UB.  
  ```C++
  int& foo1(int a){
      int b = a + 1;
      return b; // UB
  }
  int main() {
      int c = foo1(4);
      std:: cout << c;
  }
  ```  
  Применять возращение значения по ссылке можно например, если нам в параметрах передали какой-то аргумент по ссылке. То есть после окончания функции, он не будет уничтожен, поэтому позвращать на него ссылку совершенно легально.  
  ```C++
  int& foo1(int &a){
      a++;
      return a; // OK
  }
  int main() {
      int c = 5;
      int &b = foo1(c); // 6
      b++; // 7
      std::cout << c; // 7
  }
  ```
  Или например, можно возвращать ссылку на статический объект, объявленный внутри функции.
  ```C++
  int& foo1(){
      static int a = 100;
      a++;
      return a; // OK
  }
  int main() {
      int &c = foo1();
      std::cout << c << "\n"; // 101
      foo1();
      std::cout << c << "\n"; // 102
  }
  ```  
  Ну и можно возвращать константные ссылки. Всё работает интуитивно.  
  ```C++
  const int& foo1(int &a){
      a++;
      return a; // OK
  }
  int main() {
      int c = 5;
      const int &b = foo1(c); // 6
      b++; // Compilation error
  }
  ```
  * ### Возврат `{}`.  
  Возвращение из функции `{}` возможно только если возвращать что-то по значению (ну очевидно, не понятно что бы означало вернуть ссылку на пустые скобки. Это просто не скомпилится). В этом случае, вызововется Default initialization у элемента возвращаемого типа. То есть если функция от инта, то вернётся 0.  
   ```C++
  int foo1(){
      return {};
  }
  int main() {
      std::cout << foo1(); // 0
  }
  ```
  * ### `[[nodiscard]]`, возможные стратегии применения: когда не имеет смысла игнорировать возвращаемое значение, когда игнорировать опасно  
  Например, опасно игнорировать возвращаемый объект какой-то структуры. Если мы использовали внутри функции Dynamic storage duration, и возвращаем какой-то объект, в предположении что его после нужно пудет удалить. Если же мы его никуда не сохраним, произойдёт утечка памяти. Имеет смысл запрещать игнорировать возвращаемое значение, например если мы переопределяем какой-то арифметический оператор, как `+` в `bigint`. (Речь идёт о `C-style pointer`, с `unique_ptr` всё нормально будет, он почистится).  
  Так же если функция ничего не меняет вне себя, то ситуация, когда мы никуда не сохранили её значение означает, что мы попросту впустую потратили время на её выполнение, и это не дело.  
  Или если функция связана с обработкой ошибки, то идейно мы обязаны как-то исползользовать возвращаемое ей значение.  
* ## Перегрузка функций:
  * ### Что входит в сигнатуру, что не входит (например, значение по умолчанию).  
  Сигнатура функции включает имя функции, а также количество, порядок и тип ее формальных параметров.  
  Две перегруженные функции не должны иметь одинаковую сигнатуру.  
  Возвращаемое значение не является частью сигнатуры функции.  
  Две эти функции имеют одинаковую сигнатуру:  
  ```C++
  int Divide (int n, int m) ; 
  double Divide (int n, int m) ;
  ```
  * Типы-тэги для пояснений к перегрузкам (04-210923/01-functions/04-tags)
  Пояснил за тэги в пункте про безымянные и `[[maybe_unused]]`аргументы.  
  * ### Синтаксис `= delete` с C++11.  
  Если мы хотим запретить, например копирующий конструктор, можем воспользоваться конструкцией = delete: чтобы пометить их как удаленные функции.  
  ```C++
  unique_ptr(const unique_ptr&) = delete;
  unique_ptr& operator=(const unique_ptr&) = delete;
  ```
  Отличие удаления этих функций от их объявления как private.Удаленные функции не могут использоваться никоим образом, так что даже код функциичлена или функций, объявленных как friend, не будет компилироваться, если попытается.  
  Так же можно запрещать перегружать метод:  
  ```C++
  void foo(int x) {
      std::cout << "foo(" << x << ")\n";
  }

  void foo(double) = delete;  // Last step: if chosen by overload resolution, fail compilation.
  ```
  * ### Проблемы с разделением `nullptr`, `NULL`, `0`.  
  nullptr: это отдельный тип, а вот 0/NULL — это инты. Поэтому с перегрузками беда. Различие между NULL и 0 чаще всего практически никакого - (идеологически NULL показывает, что там пусто.  
  `#define NULL 0` //чаще все это именно так и есть  
  `nullptr` - значит что ни на что не указывает - необходимо использовать для указателей
  ```C++
  int *a=nullptr;
  *a; //UB!!!
  ```
  После 11 плюсов с взаимнозаменяемостью этих трёх штук полная лажа, так что `NULL` не стоит использовать вообще никогда.
  * ### Не было: `noexcept`.
  * ### Не было: правил выбора перегрузки точнее "выбирается перегрузка наиболее точная или ambiguous".
* ## Указатели на функции: синтаксис, использование.
Стыбжено у 2 курса  
[большая статья про указатели на функции](https://ravesli.com/urok-104-ukazateli-na-funktsii/#toc-0)  

```C++
// fcnPtr - это указатель на функцию, которая не принимает никаких аргументов и возвращает целочисленное значение
int (*fcnPtr)();
```
В примере, приведенном выше, fcnPtr — это указатель на функцию, которая не имеет параметров и возвращает целочисленное значение. fcnPtr может указывать на любую другую функцию, соответствующую этому типу.

Скобки вокруг *fcnPtr необходимы для соблюдения приоритета операций, в противном случае int *fcnPtr() будет интерпретироваться как предварительное объявление функции fcnPtr, которая не имеет параметров и возвращает указатель на целочисленное значение. Собственно синтаксис `*` интуитивно понятен, хотим получить `указатель` на функцию.  

Указатель на функцию может быть инициализирован функцией (и неконстантному указателю на функцию тоже можно присвоить функцию):  

```C++
int boo()
{
    return 7;
}
 
int doo()
{
    return 8;
}
 
int main()
{
    int (*fcnPtr)() = boo; // fcnPtr указывает на функцию boo()
    fcnPtr = doo; // fcnPtr теперь указывает на функцию doo()
 
    return 0
```

Можно передавать свой компаратор в сортировочку. Или в тестирующей системе tic-tac-toe извращаться(прикольно). Или в другую функцию передавать, чтобы в каком-то конкретном случае она делала именно то, что вы хотите(некоторое обобщение передачи в сортировочку).  
Далее примерчики  
```C++
#include <iostream>

void apply(void (*operation)(int)) { // cdecl.org
    std::cout << "calling with 10\n";
    operation(10);
}

using ApplyArgument = void(*)(int);
void apply2(ApplyArgument operation) { // cdecl.org
    std::cout << "calling with 10 twice\n";
    operation(10);
}
void print(int x) {
    std::cout << x << "\n";
}

void print_twice(int x) {
    std::cout << x << ", " << x << "\n";
}

int main() {
    apply(print);
    apply(print_twice);
    apply2(print);
    apply2(print_twice);
}
```

```C++
#include "iostream"
void lol(int a) {
    std::cout << "функция вызвана с параметром " << a << '\n';
}
void kek(void(*lol)(int), int a, int b) {
    for (int i = 0; i < a; i++) lol(b);
}

int main() {
    kek(lol, 2, 4);
    void(*pek)(int) = lol; //создали указатель pek на функцию lol
//(просто показываю, что так можно)
    return 0;
}
```

В функцию kek передали указатель на функцию возвращающую void и принимающую один параметр int. Так же можно создать константный указатель на функцию void(* const lol)(int).  
Так же уместен такой синтаксис:  
```C++
#include "iostream"
void lol(int a) {
    std::cout << "функция вызвана с параметром " << a << '\n';
}
using func = void(*)(int);
void kek(func lol, int a, int b) {
    for (int i = 0; i < a; i++) lol(b);
}

int main() {
    kek(lol, 2, 4);
    func pek = lol; //создали указатель pek на функцию lol
//(просто показываю, что так можно)
    pek(1);
    return 0;
}
```  

  * ### Не было: конверсии между указателями, что происходит с перегрузками.

Тесно связано с: методы.

</details>

<details>
<summary>
 Билет 15. Жизнь объектов
</summary>


### Семантика копирования

В C++ по умолчанию при присваивании объекта / 
передаче объекта в функцию или возврате из функции ожидается, что объект будет скопирован и 
изменения, произошедшие с копией не мутируют сам объект.

При этом существует способ создать ссылку на объект, то есть добавить новое имя для ровно того же объекта в памяти.
Для этого импользуется синтаксис `Type &refer = ....;`, функции также могут принимать аргументы по ссылке. 
При возвращении ссылки из функции нужно быть очень осторожным - локальные переменные умирают при завершении функции, 
возникает dangling reference - ссылка на умерший объект. Обращение по ней - UB. [stackowerflow](https://stackoverflow.com/questions/46011510/what-is-a-dangling-reference)


```c++
void foo(std::vector<int> a) {
    a.push_back(1);
    std::cout << a.size(); 
} 

void bar(std::vector<int>& a) {
    a.push_back(1);
    std::cout << a.size();                                  
} 


int main() {
    std::vector<int> a{0};
    foo(a); // 2
    std::cout << a.size(); // 1 
    bar(a); // 2
    std::cout << a.size(); // 2  
    return 0;
}
```

Пример с dangling reference

```c++
#include <iostream>
#include <vector>

std::vector<int>& foo() {
    std::vector<int> vec{1, 2, 3};
    return vec;
}

int main() {
    std::vector<int> vec = foo();
    std::cout << vec.size() << "\n"; // UB
}
```

### Storage duration

Storage duration - характеристика объектов, опиисание их времени жизни - момента, когда они создаются и умирают.
[cppreference](https://en.cppreference.com/w/cpp/language/storage_duration) - полное описание.
Мы рассматриваем automatic, static и dynamic.

#### Automatic storage duration

Наиболее распространённая storage duration - мы создаём объект при проходе через объявление переменной - её значение 
(обычно оно кладётся на стэк, но стандарт это никак не оговаривает). Объект умирает, когда эта переменная 
становится невидимой навсегда (shadowing не считается, т.к. в какой-то момент переменные снова становятся видимыми).
У полей структуры с automatic storage duration - такой же storage duration. 

```c++
int main() {
    std::vector<int> v;                    // (1) - created

    for (int i = 0; i < 10; i++) {
        std::vector<int> v;                // (2) - created (10 times)
        if (i % 2 == 0) {
             break;                        // (2) - deleted
        }
    }                                      // (2) - deleted
    v.push_back(1);                      
    return 0;                              // (1) deleted
}


```

#### Static storage duration

Переменные инициализируются в какой-то момент и живут до окончания всей программы. Основной пример -
глобальные переменные. Можно создать и локальные объекты с таким же storage duration - для этого
их нужно пометить `static Type var;`. Они инциализируются только при первом прохождении через строчку с их
объявленем, а затем существуют до конца выполнения программы. При их инициализации доступны вске видимые объекты, 
существующие в этот момент (в частности - аргументы функции, в которой они созданы).

```c++
std::vector foo(1000, 0);                 // (1) - created before main

int count(int start) {
    static int current = start;           // (2) - Created on first call; 
    return current++;
}

int bad_counter(int b){
    static int a{};                       // (3) Value-initialzation on first call
    a = b;                                // assigment on every call
    return a++;                                
}

int main() {
    foo.push_back(0);
    std::cout << count(5) << std::endl;           // 5
    std::cout << count(5) << std::endl;           // 6
    std::cout << count(0) << std::endl;           // 7
    std::cout << count(101) << std::endl;         // 8
    std::cout << bad_counter(5) << std::endl;     // 5
    std::cout << bad_counter(5) << std::endl;     // 5
    std::cout << bad_counter(0) << std::endl;     // 0
    std::cout << bad_counter(101) << std::endl;   // 101
}

```

Обычно такие переменные помещаются в область глобальных переменных, поэтому на практике имеет смысл создавать
большие объекты именно таким способом, чтобы не тратить память на стэке.

Здесь можно встретить все проблемы, связанные с SIOF [билет 33](https://github.com/khbminus/CppTickets/blob/master/tickets/ticket33.md).
Про порядокс (или его отсутсвие инициализации таких переменных можно почитать [тут](https://en.cppreference.com/w/cpp/language/initialization#Non-local_variables))
и в билете про инициализацию


#### Dynamic storage duration

Программа сама полностью управляет временем жизни. При вызове оператора `new Type;` - создаётся
объект, значение этого выражения - указатель на него. Для того, чтобыы уничтожить объект используется
`delete ptr;`.

При попытке удалить объект 2 раза или удалить объект, созданый не при помощи опретаора `new` - 
возникает UB.
              
```c++

#include <vector>
#include "iostream"
struct Foo {
    std::vector<int> vec{0, 0, 0};
};

int main() {
    Foo *ptr = new Foo;
    int bar;
    std::cout << ptr->vec.size() << std::endl; // 3
    delete ptr; // To avoid memory leak
    //delete ptr; // Double free - UB;
    //delete &bar; // UB;
}
```

Неосвобождённая память живёт до окончания программы - дальше современные ОС её освобождают. Такая ситуация называется утечкой памяти, 
она может вызвать отложенные проблемы.

Есть целый зоопарк new/delete; 

Можно выделять целые массивы при помощи `new Type[n]` - в таком случае освобождать память следует при помощи `delete[] ptr` - 
иначе UB (В том числе при попытке сделать `delete ptr;`). 

Для new работает много инициализаций:

* default - `new Type`
* default - `new Type()`
* default - `new Type{}`
* direct - `new Type(10)`
* direct list - `new Type{10}`

* Инициализация массивов - `new Foo[n]{val1, val2, val3}` - неинициализированные инициализируются по умолчанию.




### Время жизни временных объектов

Временные объекты умирают по завершении вычмсления выражения где они возникли, но при этом если создать
константную ссылку на временный объект, его время жизни продлится, чтобы соответсвовать времени жизни этой ссылки.

Важно, что эффект теряется, если мы инициализируем новую ссылку на временный объект старой.


```c++

const std::vector<int> &first = std::vectorP{0, 0, 0};
std::cout << first.size() << std::endl; // NO UB
 ....
// maybe another scope
const std::vector<int> &second = first; // would have been dangling if lifetime of second had been wider than lifetime of first;     
}
```

Это может иметь значение, если 


```c++
int const& func(int const& x) {
    return x;
} 


int main() {
    const int &first = func(1);
    std::cout << first; // UB
}
```
т.к. время жизни объекта продлевается только до времени жизни x. x - исчезает после завершения вычисления функции.

Подобное можно встретить и в STL - функция std::min - принимает и возвращает ссылки

```c++
int main() {
    const auto &val = std::min(0, 1); // Dangling reference
}
```
[ну или проблемы range-based for связанная с тем, что его рассахаривание - несколько выражений](https://github.com/Nekrolm/ubbook/blob/master/lifetime/for_loop.md) 

</details>

<details>
<summary>
 Билет 16. Стандартная библиотека
</summary>


<!-- 1 -->
### Что такое `namespace std`
`namespace std` - это пространство имен стандартной библиотеки. Когды мы пишем `std::something`, это означает "взять что-то из стандартной библиотеки". Namespaces используются во избежания конфликтов имен, когда в больших проектах может использоваться много разных библиотек (более подробно - в билете про `namespaces`, уверен, что такой есть. Где-то....).  


<!-- 2 -->
### Контейнеры

#### `std::vector`, `std::string`, `std::list`, `std::map`: когда что использовать 

- `std::vector` - динамически расширяемый массив. Хранение вектора происходит автоматически: дополнительная память под элементы выделяется/освобождается, когда нужно. Память выделяется с запасом на будущие элементы, таким образом вектору не нужно перевыделять память каждый раз при добавлении нового элемента.

- `std::string` - контейнер для работы со строками. В `std::string` можно присвоить сишную строчку, для нее определены многие методы, например, `size()`, также можно обратиться к конкретному символу в строке с помощью оператора `operator[]`.

- `std::list` - обычно реализован как двусвязный список, поддерживающий удаление и встаку элементов за O(1). При этом не поддерживает быстрый доступ к произвольному элементу.

- `std::map` - контейнер, хранящий пары (уникальный ключ, значение) в отсортированном порядке. Наиболее похож на `set<pair<const T1, T2>>`. При этом ключ константный (это важно помнить)!



#### Основные операции и время работы: `push_back`/`emplace_back`, `front()`/`back()`, `operator[]`, `size()`, `capacity()`, `resize()`, `reserve()`

| `vector`, `string`, `list` | push_back | emplace_back | front | back | operator[] | size | capacity | resize | reserve |
|---|---|---|---|---|---|---|---|---|---|
| Время работы | O*(1) | O*(1) | O(1) | O(1) | O(1) | O(1) | O(1) | O(n) | O(n) |
| Возвращаемое значение | - | Начиная с C++17 - ссылка на добавленный элемент | Ссылка на первый элемент | Ссылка на последний элемент | Ссылка на i-ый элемент  | Кол-во элементов в контейнере   | Кол-во элементов, под которое выделена память | - | - |
| Описание | Вставляет элемент в конец копированием или перемещением | Конструирует элемент на месте (в конце контейнера). Не определен для `string` |  |  | Не определен для `list` |  | Не определен для `list` (есть аналог `max_size`) | Изменяет размер контейнера (обрезает с конца или увеличивает, заполняя дефолтными значениями) | Выделяет доп. память (влияет на capacity). Не определен для `list` |


| `map` | insert  | emplace | operator[] | size | max_size |
|---|---|---|---|---|---|
| Время работы | O(logn) | O(logn) | O(logn) | O(1) | O(1) |
| Возвращаемое значение | Итератор на вставленный элемент (или на то, что уже был в контейнере), либо пару (итератор, `bool`), второй параметр показывает произошла ли настоящая вставка элемента   | Пару (итератор, `bool`) | Ссылка на элемент по ключу  | Кол-во элементов в контейнере   | Кол-во элементов, под которое выделена память |
| Описание | Вставляет элемент копированием или перемещением | Конструирует элемент на месте |  |  |  |



#### Особенность `operator[]` у `std::map`: элемент всегда создаётся, даже если его не было, почему
Несмотря на то, что `std::map` похож на сет пар, у него есть свои отличия. Оператор `operator[]` у `std::map` принимает значение ключа, создают элемент с таким ключом (инициализирует его дефолтным значением), если такого ключа раньше не было, и возвращает ссылку на значение.

Этот оператор работает именно таким образом, поскольку возвращает **ссылку** на значение (значение должно быть проинициалиированно, чтобы вернуть его по ссылке).


#### Инвалидация итераторов и ссылок на элементы: когда, какие последствия
Для стандарта `C++17` (для других стандартов правила могут отличаться! Подробнее [тут](https://stackoverflow.com/questions/6438086/iterator-invalidation-rules-for-c-containers)):
- `std::vector`: итераторы (ссылки на элементы тоже!) инвалидируются при удалении и при добавлении в любое место, если произошла реаллокация памяти (вектор расширился). Также инвалидируются указатели (и ссылки) на удаленные элементы (в случае `push_back`).
- `std::string`: также как у `std::vector`.
- `std::list`: при добавлении итераторы (и ссылки) не инвалидируются, при удалении инвалидируются только итератор (и ссылка) на удаленный элемент.
- `std::map`: при добавлении итераторы (и ссылки) не инвалидируются, при удалении (это про `std::map::erase()`, у `std::map::extract()` поведение схоже, но ссылки остаются валидными) инвалидируются итераторы (и ссылки) только на удаленный элемент.

Обращение к невалидному итератору - UB!

<!-- 3 -->
### Итераторы
#### Конвенции с `begin()`/`end()`
Эти два итератора представляют собой полуинтервал, включающий левую, но не правую границу. Иными словами: `[begin; end)`

<!-- 4 -->
### Алгоритмы
#### `sort`, передача своего компаратора
`std::sort` - сортирует элементы контейнера на заданом полуинтервале в соответсвии в предоставленным компаратором (или компаратором по умолчанию).

```cpp
std::vector <int> arr = {2, 4, 3, 1, 6, 5};
std::sort(arr.begin() + 2, arr.begin() + 4); // 2 4 1 3 6 5
std::sort(arr.begin(), arr.end()); // 1 2 3 4 5 6 
```

Способы передать компаратор (TODO: ссфлка на билет про **функторы**):
- Классом компаратором с определенным оператором `operator()`:
```cpp
struct comp {
	bool operator() (const T& a, const T& b) {
		return (a > b);
	}
};
...
std::sort(arr.begin(), arr.end(), comp());
```
- Функцией, возвращающей `bool`:
```cpp
bool comp(const int& a, const int& b) {
	return (a > b);
}
...
std::sort(arr.begin(), arr.end(), comp);
```
- Лямбда функцию:
```cpp
std::sort(arr.begin(), arr.end(), [](const int& a, const int& b) {
	return a > b;
});
``` 

#### `lower_bound`, `upper_bound`, точные инварианты
`lower_bound`, `upper_bound` - принимают полуинтервал (границы поиска) отсортированного контейнера, значение для сравнения, опциональный компаратор.

`lower_bound` - вернет итератор на первый элемент **не меньший**, чем переданный, если такого нет, то на end.

`upper_bound` - вернет итератор на первый элемент **больший**, чем переданный, если такого нет, то на end.

<!-- 5 -->
### Ввод-вывод
#### `cin`/`cout`/`ifstream`/`ofstream`/`istream`/`ostream`/`sstream`
- `cin`/`cout` - глобальные объекты ввода/вывода в стандартные Сишные потоки ввода/вывода. 
```cpp
#include <iostream>
...
int a;
std::cin >> a;
std::cout << a; 
```

- `ifstream`/`ofstream` - типы для файлового ввода/вывода.
```cpp
#include <fstream>
...
std::ifstream input("input.txt");
std::ofstream output("output.txt");
int num; std::string str;

input >> num >> str; // 123 Anime
output << str << ' ' << num; // Anime 123
```

- `istream`/`ostream` - типы для стандартного ввода/вывода (объекты `cin`/`cout` - преставители этих типов). 

- `sstream` - поток для чтения/записи строчек.
```cpp
#include <sstream>
...
std::stringstream ss;
ss << "Hello" << ", World!"; // Hello, World!
std::string s1, s2;
ss >> s1 >> s2;
std::cout << s1 << '\n' << s2 << std::endl;
// Hello,
// World!
```

#### Какие `#include` бывают (2 шт)
`#include` - указывает препроцессору включить содержимое указанного файла в точку, где отображается директива. Типы скобок принципиально отличаются тем, что указывают порядок поиска файлов при указании не полного пути. 

- `#include "..."`: сперва искать этот заголовочный файл следует в текущей директории нашего проекта, затем в системный директориях. 
- `#include <...>`: сперва искать этот заголовочный файл следует в системных директориях.
#### Синтаксис ввода и вывода
Примеры синтаксиса два пункта выше.

#### Перегрузка операторов ввода-вывода для своих классов: конвенции, почему так работает, когда нужны `friend`-операторы и зачем
Когда мы перегружаем операторы ввода/вывода, мы обязаны возвращать ссылки на объекты ввода/вывода, которыми пользуемся. Это позволит нам применять много операторов последовательно в одной строчке. Примеры перегрузок операторов ввода/вывода:
```cpp
std::istream& operator>>(std::istream &is, Type &obj) {
	...
	return is;
}
...
in >> obj1 >> obj2 >> obj3; // равносильно тому, что ниже
// ((in >> obj1) >> obj2) >> obj3; - так как в перегрузке возвращается ссылка на объект типа std::istream
...
std::ostream& operator<<(std::ostream &os, const Type &obj) {
	...
	return os;
}
...
out << obj1 << obj2 << obj3; // по аналогии с вводом
```
- Ввод: Принимаем вторым параметром ссылку на объект, который хотим ввести, так как мы собираемся положить введенное значение по этому адресу. Первым параметром принимаем `std::istream&` (почему именно ссылку - в комментариях в коде расписано почему), почему именно ссылку на этот тип - чтобы, мы могли перегрузить оператор ввода единожды, и он работал для всех типов потоков ввода (так как `std::istream` - базовый класс для всех остальных типов ввода). 
- Вывод: Принимаем вторым параметром константную ссылку на объект, который хотим вывети, либо же копируем по значению, но так скорее делать не стоит (особого смысла нет). Остальное по аналогии с вводом.

Если у нас есть класс, у которого имеется приватное поле, которое нам уметь выводить, можно воспользоваться `friend`:
```cpp
class T {
  public:
    friend std::ostream& operator<<(std::ostream&, const T&);
  private:
    int data;
};
...
std::ostream& operator<<(std::ostream& os, const T& obj) {
	os << obj.data;
	return os;
}
``` 

<!-- remark -->
**Замечание**: тесно связано с: функторы, лямбда-функции, базовый синтаксис (порядок вычислений).




</details>

<details>
<summary>
 Билет 17. Указатели
</summary>


## Содержание

Каждый указатель относится к одному из 4 видов:
1. Указатель на объект или функцию.
2. Указатель на память следующую за последним элементом объекта.
3. Нулевой указатель - `nullptr`.
4. Invalid указатель - указывает куда угодно (мы не знаем, что в той памяти лежит).

* ## Базовый синтаксис
  * ### Объявление
    В общем случае выгладит так: `T *P`, где `T` - 
    это тип того, на что указатель указывает, `P` - это имя указателя.
    
    Примеры объявления (и инициализации в одном месте, а на самом месте в двух):
    ```c++
    const int ci = 10;       // просто cosnt int (не указатель)
    const int *pc = &ci;     // pс - указатель на переменную ci
    int i;                   // i - просто int (не указатель)
    int *p;                  // p - указатель (не инициализировали)
    
    struct node {
        int value;
        node *next, *prev;   // со структурками/классами синтаксис ровно такой же синтаксис
    };
    
    int main() {
    }
    ```
    
    >_Замечание:_ звездочка пишется именно перед указателем 
    (то есть для каждого указателя нужна отдельная звездочка)
    `node *next, *prev;`
    
    Приколы ([zero initialization](https://en.cppreference.com/w/cpp/language/zero_initialization)):
    ```c++
    int *ptr; // по-умолчанию ставится в nullptr (zero initialization)
              // кратко: nullptr ставится всем неинициализированным указателям со static storage duration
    
    int main() {
        int *another_ptr; // указывает на рандомное место в памяти (Invalid указатель)
    }
    ```

  * ### Разыменование
    
    Чтобы получить объект, на который ссылается указатель `ptr`, надо написать `*ptr`.

    >При разыменовании указателей вида 2,3,4 получаем UB.      

    Собственно, пример:
    ```c++
    #include <iostream>
      
    int *p;        			// просто указатель (nullptr по умолчанию)
    int x = 10;      		// просто int
    int *xp = &x; 			// xp с этого момента - указатель на x
      
    int main() {
      int y = *xp;          // в y копируем значение x
      int *nxp = xp;    	// nxp теперь тоже указатель на x
      
      std::cout << (*nxp) << " " << x << "\n";  // 10 10
      if (*nxp == x) {
          std::cout << "true\n";                // prints true
      }
    
      // int z = *p;      	// UB при разыминовании nullptr
      // int *p;         	// указатель p (invalid указатель)
      // *p;             	// тоже UB, потому что указатель - invalid
    }    
    ```
    >_Замечание:_ При выводе скобочки потерять нельзя из-за [приоритетов операторов](https://en.cppreference.com/w/cpp/language/operator_precedence).
  * ### Взятие адреса
        
    Собственно, чтобы получить адрес, на который указывает указатель `ptr`, 
    нужно написать `ptr` (то есть адрес, куда указывает указатель - это просто его значение).
  
    Пример:
    ```c++
    #include <iostream>
    
    int x = 10;        // просто int 
    int *px1 = &x;     // указатель на x
    int *px2 = &x;     // еще указатель на x
   
    int main() {
      std::cout << px1 << " " << px2 << "\n";    // выводим адреса переменной,
                                                 // на которую указывают px1 и px2
                                                 // (они совпадут)
      
      std::cout << &px1 << " " << &px2 << "\n";   // выводим адреса самих указателей
                                                  // (они разные) 
    }
    ```
    >_Замечание 1:_ `&ptr` - память, где лежит указатель. 
    `ptr` - память, где лежит переменная, на которую указывает указатель.   

  * ### Стрелочка `->`
    
    `->` - это просто синтаксический сахар для того, чтобы работать со структурками/классами
    было удобней.
  
    Написать стрелочку - то же самое, что и разыменовать указатель и применить к результату `operator.`.
    
    Пример:
    ```c++
    #include<iostream>
    
    struct node {            // структурка для двусвязного списка
      int data;              // значение node  
      node *next, *prev;     // указатели на предыдущий и следующий элементы списка
    }
    
    int main() {
      node a{10}, b{20}, c{30};  // создаем три элемента (пока что раздельных)
      a.prev = nullptr;          // говорим, что a - это начало списка, проинициализировав 
                                 // его предыдущий элемент nullptr (такой у нас инвариант)
      
      a.next = &b;               // связали элементы в список
      b.next = &c;               
      
      // теперь хотим вывести значение следующего элемента после a
      // давайте сделаем, как умеем
    
      std::cout << (*a.next).data << "\n";        // фуу
      
      // чтобы писать было на два символа короче, директор c++ придумал стрелочку:
    
      std::cout << a->data << "\n";               // теперь красиво 
    }              
    ```
  
* ## Реализация двусвязного списка
  Ну вот она:
  ```c++
  #include <iostream>
  
  struct node {
      int data;
      node *prev = nullptr, *next = nullptr;
  };
  
  void add_after(node& a, node&  b) {          // добавление элемента между a и a->next
      b.next = a.next;                         // говорим, что следующий за b элемент - это следующий за a в прошлом элемент
      if (b.next != nullptr) {                 // разыменование nullptr - UB
          b.next->prev = &b;                   // обновляем указатель на элемент идущий перед следующим за b
      }                                                                               
      a.next = &b;                             // все понятно: следующий за a теперь b
      b.prev = &a;                             // тоже понятно: предыдущий от b - это a
  }
  
  void add_before(node& a, node& b) {          // добавление элемента b между a->prev и a
      b.prev = a.prev;                         // элемент перед b теперь - это элемент перед a в прошлом
      if (b.prev != nullptr) {                 // разыменование nullptr - UB
          b.prev->next = &b;                   // обновляем указатель на идущий после элемента перед b
      }
      b.next = &a;                             // все понятно: следующий за b - теперь a
      a.prev = &b;                             // тоже понятно: следующий за a - теперь b
  }
  
  void remove(node& a) {                       // удаление элемента a 
      if (a.prev != nullptr) {                 // если есть элемент перед a, то обновим его
          a.prev->next = a.next;               // обновляем указатель на следующего за предыдущим элементом
      }
      if (a.next != nullptr) {                 // если есть элемент после a, то обновим его
          a.next->prev = a.prev;               // обновляем указатель на идущего пред слудющим за a
      }		
  }
  
  void print_list(node& head) {                // печть списка: не интеллектуально
      node *cur = &head;
      while (cur != nullptr) {                 // собственно, пока текущий выводмимый - не конец списка
          std::cout << cur->data << " ";       // выводим значение предыдущего head
          cur = cur->next;                     // теперь head - это следующий за head элемент
      }
      std::cout << "\n";                       // вывод пустой строчки, потому что почему бы и нет
  }
  
  int main() {
      node a{10}, b{20}, c{30}, d{40}, e{15};  // создание элементов и их связывание спомощью add-функций
      add_after(a, b);
      add_after(b, c);
      add_before(b, e);
      add_after(c, d);      
  
      print_list(a);  // 10 15 20 30 40
      print_list(b);  // 20 30 40
      print_list(c);  // 30 40
  
      remove(e);
  
      print_list(a);  // 10 20 30 40
  }
  ```
  >_Замечание:_ в конструкции типа `a.next->prev` мы сначала пишем точку, потому что `a` 
    был у нас не указателем, но, `a.next` - это указатель, поэтому, чтобы обратится к 
    его полям надо использовать стрелочку.
* ## Нулевой указатель
  Иногда хочется пометить, что указатель никуда не указывает. Это можно сделать с 
  помощью присвоения `nullptr` указателю. Такой указатель называется нулевым.
  > Разыменование нулевого указателя - это UB.
  
  Пример: 
  ```c++
  int main() {
    int *ptr = nullptr;
    if (ptr) {             // если ptr - это nullptr, то при конвертации к bool
                           // получим false. Иначе - true.
      // do something                  
    }
    if (ptr != nullptr) {  // так тоже делать никто не запрещает
      // do something
    }
    *ptr;                  // разыменование nullptr - UB
  }
  ```
  >_Замечание:_ Единственный случай, когда указатель при конвертации к `bool`
    вернет `false` - это случай, когда указатель нулевой.  
  
  До `C++11` стандартным нулевым указателем был макросовая константа `NULL`, которая определен нулем. 
  Ее лучше не использовать из-за вот таких приколов:
  ```c++
  #include <cstddef>
  #include <iostream>
   
  void foo(int*) {
    std::cout << "foo(int*);\n";
  }
   
  void foo(long) {
    std::cout << "foo(long);\n";
  }
   
  int main() {
    foo(nullptr);        // calls foo(int*)
    foo(NULL);           // compilation error (call is ambigous)
    foo(0);              // compilation error (call is ambigous)  
  }
  ```
  >_Замечание1:_ `NULL` и `0` могут быть сконвертированы и в `int`, и в указатель,
    а `nullptr` - это чисто про указатели.
  
  >_Замечание2:_ На cppreference [написано](https://en.cppreference.com/book/pointers#:~:text=Special%20null%20pointer),
    что `foo(NULL)` будет вызывать `foo(long)`, но у меня под всеми компиляторами и всеми разумными стандартами была ошибка компиляции.
  
  > _Замечаание3 (от ХБ):_ лично у меня при компиляции руками `g++ -std=c++17/03/11` g++ выкидывал предупреждение, что `NULL` кастуется к лонгу, при этом `clang++` вообще ничего не выкидывал. 
  
  Тем не менее, когда вы пишете `foo(NULL)`, вы ожидаете, что вызовется перегрузка `foo(int*)`, чего не происходит.
* ## Отличие ссылок от указателей
  * ### Изменяемость
    
    >Ссылка после создания всегда указывает на один элемент, в то время как указатель 
    можно перепривязывать.
    
    Пример:
    ```c++
    #include <iostream>
    
    int main() {
      int x = 10;
      int y = 20;
      int *ptr = &x;                             // указатель на x
      int &x_ref = x;                            // ссылка на x 
      std::cout << ptr << " " << &x_ref << "\n"; // указывают на одну и ту же память
      ptr = &y;                                  // перепривязали указатель к y
      x_ref = y;                                 // это уже присвоение y в x_ref, т.е. в x
      std::cout << ptr << " " << &x_ref << "\n"; // у ptr адрес поменялся на адрес y, а у x_ref остался тем же
    }
    ```
  * ### Обнуляемость
    
    >Указатели имеют нулевое состояние `nullptr`, в то время как ссылки таким не обладают. 
    Т.е. ссылка всегда должна указывать на объект, а указатель - нет.
    
    Пример:
    ```c++
    #include <iostream>
    
    int *g_ptr;                 // просто указатель (по умолчанию nullptr)
    
    int main() {
      int *ptr = nullptr;       // просто нулевой указатель
      int &ref;                 // compilation error: ref объявлена, как ссылка, но не инициализирована  
    }
    ```
  * ### Хранение в контейнерах
    Указатели спокойно кладутся в контейнеры, а вот ссылки туда класть нельзя. 
    (можно, если использовать `std::reference_wrapper`, который превращает ссылку в 
     копируемый и присваиваемый объект, но это не просто ссылки)
    
    >Ссылки нельзя копировать и присваивать. (Вообще ссылка - это не объект, 
     а в контейнерах должны объекты лежать)
  
    Пример:
    ```c++
    #include <vector>
    
    int main() {
      std::vector<int*> v_ptr(10);       // создается вектор из 10 нулевых указателей
      std::vector<int&> v_ref(10);       // compilation error: с длинной ошибкой
    }
    ```
    
    Пример с `std::reference_wrapper`:
    
* ## Арифметика указателей
  * ### `array-to-pointer decay`
    Ссылка на массив - это ссылка на его первый элемент. Значит можно сделать вот так:
    
    Пример:
    ```c++
    #include <cassert>
    #include <cstddef>
  
    int main() {
      int data[]{10, 20, 30, 40};
      
      int *p1 = &data[0];        // берем адрес первого элемента
      assert(*p1 == 10);
  
      int *p2 = data;            // array-to-pointer decay. Только массивы, не вектора.
      assert(p2 == p1);
      assert(*p2 == 10);
      *p2 = 12;                  // можно менять
      assert(*p2 == 12);
      assert(data[0] == 12);
      *p2 = 10;
    }
    ```
    >_Замечание:_ Только для C-шных массивов (не для векторов).
    
  * ### Операции `+`, `++`, `-`, `--` указателей с `int`
    Указатели в массиве можно смещать (главное, надо остаться либо в массиве,
    в котором мы находились, либо в следующей ячейке после конца массива). Отдельные объекты
    трактуются, как массивы из одного элемента, то есть можно получать указатель следующий за последним.
    
    `+`, `++` - смещение вперед.
    
    `-`, `--` - смещение назад.
  
    >Работает ровно как у итераторов.
    
    > Происходит UB при выходе за границы массива (кроме элемента следующего за последним, но про это следующий пункт).
      Причем UB даже без разыменования указателя, то есть UB - сам факт его существования.

    Пример:
    ```c++
    #include <cassert>
    #include <cstddef>
  
    int main() {
      int data[]{10, 20, 30, 40};
      
      int *p1 = &data[0];               // взяли указатель на первый элемент
      int *p2 = data;                   // array-to-pointer decay
  
      // Арифметика такая же, как и у итераторов.
    
      int *q = p1 + 2;                  // указатель на data[2]
      assert(q == &data[2]);
      assert(data + 2 == &data[2]);
      assert(*q == 30);
      
      int *ub1 = data - 1;              // UB: вышли за границу массива
      int *ub2 = data - 1 + 1;          // UB: в промежуточных вычислениях у нас произошло UB (посчитали data - 1)
      int *ub3 = data + 5;              // UB: вышли слишком далеко 
      int *not_ub = data + 4;           // НЕ UB: - one-past-the-last (про него в следующем пункте)
      
    
      int *r = q;                       // указатель на q, то есть на data[2]
      r--;                              // теперь это указатель на data[1]
      assert(r == &data[1]);
      assert(*r == 20);
  
      int x = *r--;                   
      
      // Эквивалентно вот этой штуке:
      // int *old_r = r;
      // r--;
      // int x = *old_r;
      
      assert(x == 20);
      assert(data[1] == 20);
      assert(data[0] == 10);
      assert(r == &data[0]);
      assert(*r == 10);
  
      // То же самое, только с префиксным оператором
    
      r = &data[1];
      int y = *--r;
      assert(y == data[0]);
      assert(y == 10);
      assert(r == &data[0]);
  
      std::ptrdiff_t diff = r - q;      // std::ptrdiff_t - тип, в который влазит вся память на компе
      assert(diff == -2);
      assert(&data[0] - &data[2] == -2);
  
      assert(data[1] == *(data + 1));  // По определению, синтаксический сахар для массивов (not vectors).
      assert(data[1] == *(1 + data));
      assert(1[data] == *(1 + data));
      int *data_ptr = data;
      assert(data_ptr[1] == *(data_ptr + 1));
      assert(data_ptr[1] == data[1]);
    }
    ```
    >_Замечание:_ `data[1]` - это на самом деле `*(data + 1)`.
  * ### `one-past-the-last`
    > Указатель на память, следующую за последним элементом массива - корректный, но его нельзя разыменовывать.
    
    Пример:
    ```c++
    #include <cassert>
    #include <cstddef>
    #include <iostream>
  
    struct Foo {
      int x = 0;
      int y = 1;
    };
    
    int main() {
      int data[]{40, 20, 10, 30};
  
      int *one_past_end = data + 4;
      assert(one_past_end - data == 4);
      // int var = *one_past_end;                     // разыменование - UB.
        
      Foo a;
      int *val = &a.x;
      val++;                                          // корректно (ope-past-the-last)
      // *val;                                        // разыменование - UB
    }
    ```
  * ### Сравнение указателей
    >`=`,`!=` - можно сравнивать любый указатели. Возвращает, равен ли один другому.
    
    > `>`,`>=`,`<`,`<=` - можно сравнивать указатели из одного массива или из одной структурки. 
      В случае сравнения разных объектов - `unspecified behaviour`.
    
    > `-`: Вычитать два указателя можно только из одного массива
  
    >В контейнерах используется `std::less`, который на всех указателях строит _какой-то_ полный порядок,
      поэтому можно пихать указатели, например, в `std::set`.
    
    Пример:
    ```c++
    #include <cassert>
    #include <functional>
    #include <iostream>
    #include <set>
  
    struct Foo {
      int a = 10;
      int b = 20;
      int c = 30;
    };
  
    int main() {
      {
          int data[4];
          int end;
          std::cout << (&end - data) << "\n";  // UB
          std::cout << (data < &end) << "\n";  // unspecified, может быть неконсистентным!
          std::cout << (data > &end) << "\n";  // unspecified, может быть неконсистентным!
          assert(data != &end);  // ok
      }
      {
        Foo f;
        std::cout << &f.b - &f.a << "\n";  // UB: не массив
        assert(&f.a < &f.b);  // ok: члены с одним уровнем доступа (private/protected/public) упорядочены
        assert(&f.a != &f.b);  // ok: разные int
      }
      {
        std::set<int*> s;
        int a = 10, b = 20;
        s.insert(&a);  // ok
        s.insert(&b);  // ok
  
        std::less<int*> comparator;
        std::cout << comparator(&a, &b) << "\n";  // implementation-defined
      }
    }
    ```

* ## C-style-strings/ASCIIZ-строки/строки в стиле Си
  * ### Определение
    `C-style-strings` - это не тип, а конвенция. 
     > "Если у нас есть массив, где сначала идут символы, символы, символы, а потом символ `\0`,
        то это сишная строка", — Егор Суворов.
  * ### Сохранение строкового литерала в `char *`
    С помощью `array-to-pointer decay` можно сконвертировать массив (сишную строку) в указатель.
    
    Пример:
    ```c++
    int main() {
      char str[] = "hello";                              // сишная строка
      // char str[] = {'h', 'e', 'l', 'l', 'o', 0};      // то же самое
      
      char *str_ptr = str;                               // array-to-pointer decay
    }
    ```
  * ### Сравнение и получение длины
      
    >_Опасно:_ если есть две си-шные строки `s` и `t`, то если написать `s < t`, то будут сравниваться указатели, 
      что приведет к `unspecified behaviour`. 
      
    >_Опасно:_ казалось бы на равенство указатели сравниваются без `unspecified behaviour`,
      почему бы тогда не сравнить `s == t`. Нельзя так как не гарантируется, что у 
      одинаковых строковых литералов один и тот же адрес. Ну и вообще разные строковые
      литералы могут обозначать одну и ту же сишную строку (например `"hello"` и `"hello\0"`). 
      То есть придется тоже цикликом.
      
    Но если написать `*s < *t`, то сравнятся лишь первые символы, а значит придется писать цикл `:(`.
      
    Сравнение на меньше (остальные аналогично):
    ```c++
    bool is_less(char* a, char* b) {
      for (int i = 0; a[i] || b[i]; i++) {           // (a[i] || b[i]) - нулевой символ кастуется к false, остальные - к true
        if (a[i] != b[i]) {
          return a[i] < b[i];
        }
      }
      return false;
    }
    ```
      
    Получить длину сишной строки можно так:
    ```c++
    int get_length(char* s) {
      int res = 0;
      while (s[res] != '\0') {    // идем до последнего символа, ответ - сколько элементов прошли
        res++;
      }
      return res;
    }
    ```
      
    >_Опасно:_ длина сишной строки считается за линию. Даже `std::strlen()`.
      
  * ### Выделение памяти, аллокация, конкатенация
      
    Мы хотим сконкатенировать две сишные строки. Беда в том, что сишные строки - 
    это не отдельные объекты, это указатели.
      
    То есть если мы хотим сконкатенировать две строки и получить новую, то нам надо 
    где-то выделить под нее память.
      
    Функция для конкатенации: 
    ```c++
    char* strcat(cosnt char* a, const char* b) {
      char* res = new char[std::strlen(a) + std::strlen(b) + 1]; // +1 для '\0'.
      int res_len = 0;
      for (int i = 0; a[i]; i++) {
        res[res_len++] = a[i];
      }
      for (int i = 0; b[i]; i++) {
        res[res_len++] = b[i];
      }
      res[res_len] = '\0';
      return res;
    }
    ```
      
    >_Опасно:_ теперь про каждую сишную строчку мы обязаны помнить, как мы ее получили.
      В зависимости от способа получения вызывать или не вызывать нужный `delete`.
      
    Пример (реализацию `strcat` возьмем из прошлого примера):
    ```c++
    #include <cstring>
    #include <iostream>
    #include "прошлый_пример.h"
      
    int main() {
      char* x = "xyz";
      char* y = strcat("xy", "z") + 1;
      
      // миллион строк кода
      
      delete[] (y - 1); // тут надо не забыть, что мы выделили именно массив и y взят со съездом на 1
      
      // еще надо не забыть, что вызывать delete от x не надо, потому что
      // у x automatic storage duration
    }
    ```
    
  * ### Небезопасность функции чтения

    Рассмотрим реализацию `readWord` из известного среди всей прогрессивной общественности 
    файлика `optimization.h`.
  
    Напоминание реализации readWord:
    ```c++
    void readWord(char *s) {
      int c = readChar();         // readChar просто смотрит на текущий символ из буфера
      while (c > 32)
        *s++ = c, c = getChar();  // c++ выпендреж от Cерёжи. Просто считали очередной символ.
      return с != -1;             // видимо, возвращает, считалось ли что-то?
    }
    ```
    
    >_Опасно:_ что произойдет, если мы считаем больше символов, чем выделено в `s`? 
      UB конечно же.
  
  * ### Кто владеет результатом `c_str`
    
    Что вообще такое `c_str`? Это метод у `std::string`, который возвращает сишную строчки.
    
    >_Собственно ответ:_ результатом `c_str` владеет `std::string`, который его вызвал.
    
    Пример:
    ```c++
    #include <iostream>
    #include <string>
    
    int main() {
      const char *s_ptr;
      {
        std::string s = "hello";
        s_ptr = s.c_str();
        std::cout << s_ptr << " (1)\n";    // корректно вывели сишную строчку
      }                                    // конец зоны видимости s (тут она умирает)
      std::cout << s_ptr << " (2)\n";      // UB: строчка, владеющая той памятью уже не существует
    }
    ```
 

</details>

<details>
<summary>
 Билет 18. `unique_ptr`, управление памятью, move
</summary>

* ## Ручное управление памятью: `new`, `delete`, `new[]`, `delete[]`, когда что использовать.
Это `Dinamic storage duration`, `new` выделяет память, обычно на куче, и возвращает указатель на свежесозданный объект, который мы обязуемся удалить с помощью оператора `delete`. (иначе произойдёт утечка памяти). Квадратные скобки выделяют массив элементов, которые будут лежать подряд в памяти. В скобках нужно указать количество объектов в массиве. При этом при удалении этого делать не нужно.  
```C++
struct Foo{

};
int main() {
    Foo *f = new Foo;
    Foo *arr = new Foo[1000];
    delete f;
    delete[] arr; // no memory leak
}
```
  * ### Не было: разница между `new int;` и `new int();`
  * ### Утечка памяти: UB ли, какие последствия, как ловить, как читать вывод sanitizer и Valgrind с примерами.  
  Утечка памяти это не уб, программа спокойна работает, просто появляется всё новая и новая выделенная память, что может вызвать проблемы. Например, если мы сервер вк, то утечки памяти лучше не допускать, иначи со временем памят на сервере кончится. Ловить с помощью `valgrind` или санитайзеров.  
  ```C++
    struct Foo{
        int a;
    };
    int main() {
        Foo *f = new Foo; // Memory leak
        return 0;
    }
  ```
  Запускаем валгринд командой `valgrind ./a`. Он напишет сколько памяти утекло.  
  ```
    ==135348== Memcheck, a memory error detector
    ==135348== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
    ==135348== Using Valgrind-3.15.0 and LibVEX; rerun with -h for copyright info
    ==135348== Command: ./a
    ==135348== 
    ==135348== 
    ==135348== HEAP SUMMARY:
    ==135348==     in use at exit: 4 bytes in 1 blocks
    ==135348==   total heap usage: 2 allocs, 1 frees, 72,708 bytes allocated
    ==135348== 
    ==135348== LEAK SUMMARY:
    ==135348==    definitely lost: 4 bytes in 1 blocks
    ==135348==    indirectly lost: 0 bytes in 0 blocks
    ==135348==      possibly lost: 0 bytes in 0 blocks
    ==135348==    still reachable: 0 bytes in 0 blocks
    ==135348==         suppressed: 0 bytes in 0 blocks
    ==135348== Rerun with --leak-check=full to see details of leaked memory
    ==135348== 
    ==135348== For lists of detected and suppressed errors, rerun with: -s
    ==135348== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)

  ```  
  Скомпилировать с санитайзером можно вот так `g++-10 main.cpp -o a -fsanitize=address`. Вот что он выдаст  
  ```
    =================================================================
    ==136349==ERROR: LeakSanitizer: detected memory leaks

    Direct leak of 4 byte(s) in 1 object(s) allocated from:
        #0 0x7fce088235a7 in operator new(unsigned long) ../../../../src/libsanitizer/asan/asan_new_delete.cpp:99
        #1 0x5633a583225e in main (/home/mirong/CLionProjects/hse/plusi/ut/untitled/a+0x125e)
        #2 0x7fce0821e0b2 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)

    SUMMARY: AddressSanitizer: 4 byte(s) leaked in 1 allocation(s).
  ```
  
* ## Отличия `unique_ptr` от обычного указателя, когда что использовать  
`unique_ptr` это `smart_pointer`. Это некая обёртка над обычным указателем, добовляющая какую-то семантику, кто указателем владеет, кто удаляет, какие-то операции запрещает делать, каие-то делает автоматически. `unique_ptr` сам чистит за собой память, его не нужно удалять руками. При этом его нельзя копировать, только мувать. Получать значение можно так же, как и у обычного указателя.  
Если вы не хотите возиться с удалением памяти, и вам не нужно копирование указателей, то используйте `unique_ptr`.  Только если вам нужна конкретно семантика владения, иногда нужно `shared_ptr`, `weak_ptr` и т.д.  
* ## Создание `unique_ptr`: какие есть конструкторы, что делает `make_unique`  
Можно просто объявить, тогда это `nullptr`  
```C++
std::unique_ptr<Foo> f;
assert(f == nullptr);
```
Можно собственно записать указатель, с помощью `make_unique`. Под капотом это обычный `new`, только возвращающий сразу `unique_ptr`. `make_unique` передаёт аргументы в конструктор.
```C++
std::unique_ptr<Foo> f = std::make_unique<Foo>();
std::unique_ptr<Foo> f = std::unique_ptr<Foo>(new Foo); // так то же норм, завернули указатель в unique_ptr
```
  * ### Проблема с `make_unique` и приватными конструкторами
  Во первых, факт. Можно френдить функции из других неймспейсов. Хотим создовать через объект класса только через `make_unique`, и имеем только приватный конструктор. Тогда потупому звывать `make_unique<Foo>()` не получится, так как не имеем доступ к конструктору.  
  * ### Решения: неработающее с друзьями, работающее с фабричной статической функцией
Поэтому может возникнуть идея сделать `make_unique<Foo>()` френдом класса. Но она плохая, так как сработает только в том случае, если именно `make_unique` вызовет в себе контруктор. Если же он под копотом делигирует эту операцию в какую-то другую функцию, то ничего не сработает, так как у неё не будет доступа к приватному конструктору. Решение такое - сделать отдельную функцию `make`, в которой мы вызовем `new Foo`, и завернём полученный указатель в `unique_ptr`. (вызвать здесь `make_unique` всё так же не получится).  
```C++
#include <memory>

// https://abseil.io/tips/134

struct Foo {
    static std::unique_ptr<Foo> make() {
        // return std::make_unique<Foo>();  // bad
        return std::unique_ptr<Foo>(new Foo());  // good
    }

private:
    Foo() {}

    // Technically possible, but won't help becase std::make_unique may construct indirectly
    // friend std::unique_ptr<Foo> std::make_unique<Foo>();
};

int main() {
    // auto p1 = std::make_unique<Foo>();  // hence, this is bad
    auto p2 = Foo::make();  // this is good
}  
  
```
* ## Невозможность копирования
`unique_ptr` нельзя копировать, только мувать.  
* ## Синтаксис перемещения: в параметры функции, из функции, в/из других переменных (включая поля: `13-211208/02-move-objects/03-move-to-field`), в/из контейнеров  
Если мы возвращаем локальную переменную из функции, компилятор видит это и мувает автоматически, т.к. локальная переменная в любом случае умрёт после return.  
  
  Принимаем в конструкторе аргумент по значению, а затем муваем его в поле. Таким образом мы разделяем процесс: аргумент разрешаем инициализировать как угодно (самым быстрым образом), а потом бесплатно муваем его в поле и удаляем пустой объект. Итого получили одну потенциально долгую инициализацию и две бесплатных штуки (если, конечно, мув и удаление для такого объекта работают быстро)
  Дальше вставлен код с лекции. Нужно сравнить передачу по константной ссылке и по значению. init, copy, destruct- дорогие операции. move, copy, destruct of empty- дешёвые операции. Единственный сценарий, когда мы не хотим передавать по значению, если объект очень большой, и мувать + удялять его очень дорого. Но такого лучше не допускать.  
  В итоге получается, что передавать переменную выгоднее по констентной ссылке. Временный объект по значению. В третьем случае (где у нас функция возвращает строчку по значениб) так же выгоднее передавать по значению.  
  
```C++
  #include <string>
  #include <utility>

  struct PersonCpp03 {
      std::string name;
      PersonCpp03(const std::string &name_) : name(name_) {}  // 1 copy
  };

  struct PersonCpp11 {
      std::string name;
      PersonCpp11(std::string name_) : name(std::move(name_)) {}  // 1 initialization name_ + 1 move + 1 destruct of empty
  };

  std::string create_name() {
      std::string s = "hello world";
      return s;  // no std::move needed
  }

  int main() {
      {
          std::string x = "Egor";
          [[maybe_unused]] PersonCpp03 p1(x);  // x is copied into p1.name: 1 copy
          [[maybe_unused]] PersonCpp03 p2("Egor");  // temporary is copied: 1 init, 1 copy, 1 destruct
          [[maybe_unused]] PersonCpp03 p3(create_name());  // temporary is copied: 1 init inside create_name(), 1 copy, 1 destruct
      }
      {
          std::string x = "Egor";
          [[maybe_unused]] PersonCpp11 p1(x);  // 1 copy + 1 move + 1 destruct of empty
          [[maybe_unused]] PersonCpp11 p2("Egor");  // 1 init, 1-2 move, 1-2 destruct of empty
          [[maybe_unused]] PersonCpp11 p3(create_name());  // 1 init inside create_name(), 1-3 move, 1-3 destruct of empty
      }
  }
  ```
  * ### Когда (не) надо писать `std::move`
    Не хочется мувать большие объекты лишний раз, если их достаточно просто скопировать (смотри предылущий пример с лекции). Или наоборот, когда проще скопировать объект, чем переставлять указатели (например короткие строки).
* ## `move` как оптимизация для копируемых объектов, автоматическая поддержка `move` у пользовательских структур
  После третьих плюсов, любые пользовательские структуры можно мувать. До этого их приходилось только копировать, при `swap` например. Если копируемый объект нам больше не нужен, то компилятор сам поменяет копирование на `move`.
  * ### moved-from состояние у объектов
  Если мувать из `unique_prt`, то останется гарантированно `nullptr`. Для других оъектов это не гарантируется, например для строк или векторов. Строчка остаётся корректной после мува, то есть можно её вывести, узнать размер. Но о её содержимом у нас никакхи гарантий нет. Это сделано из-за того, что коротки строчки проще скопировать, чем переставлять указатели.  
```C++
#include <cassert>
#include <memory>
#include <string>
#include <vector>
#include <iostream>

int main() {
    {
        std::unique_ptr<int> ptr(new int(200));
        std::cout << ptr.get() << "\n";
        std::move(ptr);  // Does nothing.
        std::cout << ptr.get() << "\n";
        auto ptr2 = std::move(ptr);
        // Guaranteed: ptr.get() == nullptr
        std::cout << ptr2.get() << " " << ptr.get() << "\n";
    }
    {
        std::string s1 = "hello";
        std::string s2 = std::move(s1);
        // s1 is 'moved-from': valid, but unspecified.
        // May be empty, may be "hello", may be in a random state.
        std::cout << "|" << s1 << "| |" << s2 << "|\n";
        assert(s1.empty());  // FIXME: may fail
        s1 = "ok";

        /*
        struct string {
            char buf_small[10];
            char *buf_big = nullptr;
            void move_from(string &other) {
                if (other.buf_big) {
                    buf_big = other.buf_big;
                    other.buf_big = nullptr;
                } else {
                    buf_small[0] = other.buf_small[0];
                    buf_small[1] = other.buf_small[1];
                    // ...
                }
            }
        };
        */
    }
}  
```

Тесно связано с: функции (как передавать параметры), жизнь объектов.

</details>

<details>
<summary>
 Билет 20. Классы
</summary>

* **Cинтаксис**

```c++
struct Example{
    int x;
    
    Example(){}; // конструктор
    ~Example(){}; // деструктор
    void do_something(){
        std::cout << "hello";
    }
}; // не забываем ставить всегда точку с запятой в конце
```

* **Поля: обычные, константные, ссылки, порядок создание и уничтожения и когда он важен.**
    * **Поле класса/атрибут** - переменная, описание которой создает программист
при создании класса. Все данные объекта хранятся в его полях. Доступ к полям
осуществляется по их имени.
    * **Константные поля** 
Поля, инициализируемые при помощи синтаксиса списка инициализации получают свое значение еще до входа в тело конструктора. Присваивание константе значения в теле конструктора уже является именно присваиванием, что по определению невозможно для константы.

    ```c++
        struct Foo {
            const int x = 10;
            Foo(int x_) : x(x_) { }
        };
    ```
    * **Ссылки** обязательно надо проинициализировать, чтобы они к чему-то были при-
        вязаны. Если же объект, чья ссылка была передана для инициализации переменной-ссылки внутри структуры, умер, то ссылка невалидна и обращение по ней будет вызывать UB.
    ```c++
        class DateClass{
            int a = 1;
            int &c = a;
        };
    ```
    * Разработчики классов могут гарантировать инициализацию каждого объекта пу-
тем определения особой функции, которая называется конструктор. Если в классе определен конструктор, компилятор автоматически вызывает его в момент создания объекта, до того как отдать его в руки программисту. Программисты не праве даже решать, вызывать конструктор или нет, конструктор вызывается всегда компилятором в момент создания объекта.
    ```c++
        class Example {
            int i;
        public:
            Example(){} // конструктор дефолтный
            Example(int a){} // тоже конструктор, но от int
        };
        
        int main(){
            Example cur;  // создание объекта
        }
    ```
    Как и у любого метода, у конструктора могут быть аргументы, чтобы можно было иметь возможность указать как создавать объект, передать какие-то значения и т.д. В C++, очистка поставлена на одну планку по важности с инициализацией и гарантируется, что она будет осуществлена путем вызова деструктора. Синтаксис деструктора и конструктора схожи. И там, и там, в качестве имени метода используется имя класса. Однако, чтобы отличить деструктор от конструктора, перед именем деструктора добавляется символ тильда ( ). Кроме того, деструктор не может иметь какие-либо аргументы, так как для процесса уничтожения не требуется дополнительных параметров. Вот пример объявления деструктора:
    ```c++
    struct Example{
      ~Example(){
        std::cout << "DELETE object\n";
     }
    };
    ```
    Деструктор вызывается автоматически компилятором, когда объект выходит из своей области существования.
* **Семантика копирования, особенности полей-констант/ссылок при копировании и инициализации.**
Если у нас есть объект и мы его передаем по значению (в функции например) или делаем **=**, то копируются все поля. Существует еще copy-constructor и copy assignment operator, которые и управляют копированием. Про них и их реализацию подробнее и красочнее в [примере с лекции](https://github.com/hse-spb-2021-cpp/lectures/blob/master/09-211110/00b-special-operators.cpp). Но стоит сказать, что в примере ниже copy-constructor и copy assignment operator по умолчанию дефолтные.
    ```c++
    struct Foo{
        int x;
        int y;
    };
    void do_smth(Foo temp){} // копирование 

    int main(){
        Foo a{1,2};
        Foo b = a; // Копирование
    

    ```

* **Конструктор: синтаксис, параметры, когда вызывается, делегирующие конструкторы.** 
Конструкторы - специальные методы, которые вызываются при создании объекта. Всегда вызываются и нет способа их пропустить. Время жизни объекта начинается с того, как закончился конструктор. Конструктор по умолчанию - конструктор без аргументов. Может быть сгенерирован компилятором неявно (например, когда вообще нет конструкторов). Когда присутствует какой либо конструктор (не дефолтный), то не генерируется. [Пример с лекции](https://github.com/hse-spb-2021-cpp/lectures/blob/master/04-210923/02-ctors/04-no-default.cpp), где видно, что дефолтный конструктор не создается при наличии другого конструктора. [Примеры вызова конструктора](https://github.com/hse-spb-2021-cpp/lectures/blob/master/04-210923/02-ctors/02-args.cpp).
    ```c++
    #include <iostream>
    
    struct ratio {
        int num;
        int denom;
        ratio() {
            num = 0;
            denom = 1;
            std::cout << "Constructing!\n";
        }
    };
    
    int main() {
        ratio r;
        std::cout << r.num << "\n";
        std::cout << r.denom << "\n";
        std::cout << ratio{}.num << "\n";  // Not UB, ok even in C++03.
    }
    ```
    **Делегирующий конструктор** - конструктор, который вызывается в данном конструкторе для инициализации полей. Тонкость: после вызова делегирующего конструктора не можем изменять поля в member initialization list. Вторая тонкость: внутри конструктора нельзя вызвать делегирующий конструктор, так как это не является вызовом конструктора, это является созданием временного объекта, который быстро умирает. 
    
```c++
    #include <vector>
    #include <iostream>
    
    struct bigint {
        std::vector<int> digits;
        int var;
    
        bigint(int x) : digits{x % 10, x / 10} {
        }
    
        bigint() : bigint(0)/*, var(10)*/ {  // since C++11
            var = 10;                       // тут bigint(0) - делегирующий конструктор
            // если хотим поменять переменную, то лучше сделать переприсвоение, так как в initilization list изменять не имеем права.
        }
    };
    
    int main() {
        [[maybe_unused]] bigint b1; 
    }
```

* **Инициализация полей: когда что можно и нужно использовать, как они взаимодействуют между собой и с делегирующим конструктором:**
    * **По умолчанию (тривиальных и с конструктором по умолчанию). В конструкторе по умолчанию**
    * **Default member initializer (C++11).** Простыми словами мы можем задавать начальные значения в структуре и если мы хотим посмотреть от них значение, то не получим UB, как в случае, если они непроинициализированы (int num; int denom;)
    ```c++
    #include <iostream>
    
    struct ratio {
        int num = 0;  // C++11: member default initialization
        int denom = 1;
    };
    
    int main() {
        ratio r;
        std::cout << r.num << "\n";
        std::cout << r.denom << "\n";
        std::cout << ratio{}.num << "\n";
    }
    ```
    * Member Initilization list. У каждого поля в  {} мы говорим какой конструктор вызвать с круглыми или фигурными скобочками. Тогда у нас поле сразу инициализируется правильно и мы его не инициализируем, а потом перезаписываем, а мы сразу делаем правильно. Это точнее выражает намерения программиста.
    ```c++
    #include <cassert>
    #include <iostream>
    #include <vector>

    struct bigint {
        std::vector<int> digits;
        int sign = 1;
    
        bigint() /*: digits{}*/ {
        }
        bigint(int value) : digits{value % 10, value / 10} {
            assert(value >= 0);
            assert(value < 100);
        }
    };
    
    int main() {
        bigint value(23);
        std::cout << value.digits[0] << "\n";
        std::cout << value.digits[1] << "\n";
    }
    ```
* **Приватные/публичные поля и методы**
[Плохой пример](https://github.com/hse-spb-2021-cpp/lectures/blob/master/04-210923/04-api/01a-public.cpp), когда все в public не бывает полезно. Например пользователь может что-то случайно изменить или сломать инвариант. Для этого существует private секция. К полям и методам из private секции имеют доступ только методы структуры, через них мы можем даже изменять приватные поля. 
Вредные советы: всегда создавать getters и setters. Пример: setters в случае дроби не нужны, и getters тоже сомнительно (?), но их можно оставить. Например надо ставить assert(x != 0), когда меняется знаменатель через  setter. Да и вообще неразумно менять дробь. 
    **геттеры** — это функции, которые возвращают значения закрытых переменных-членов класса;
    **сеттеры** — это функции, которые позволяют присваивать значения закрытым переменным-членам класса.
Запомним: 
Класс должно быть нельзя использовать некорректно! Даже если очень захотеть.
Пример: нельзя просто так взять и поменять числитель/знаменатель у дроби.
    [Оригинальный пример с лекции](https://github.com/hse-spb-2021-cpp/lectures/blob/master/04-210923/04-api/01b-private.cpp)

```c++
    struct ratio {
    private:
        // denom != 0
        int num;
        int denom;
    
    public:
        
        //  куча конструкторов
    
        // getter
        int numerator() const {
            return num;
        }
        int denominator() const {
            return denom;
        }
    /*    // setter
        void numerator(int new_value) {
            num = new_value;
        }
        void denominator(int new_value) {
            assert(new_value != 0);
            denom = new_value;
        }*/
    };
    
    int main() {
        ratio r;
        // r.denominator(0); 
        r = {r.numerator(), 5}; // безумная операция, которая отрывает числитель у дроби и меняет знаменатель.
        // пример плохого применения setter
        std::cout << r.numerator() << "\n";
    }
```

Чтобы иметь доступ к приватным полям структуры вне структуры свободная функция должна быть либо friend-функцией структуры (синтаксис в примере), либо static функция - все так же является другом, все так же НЕ является методом, но она лежит внутри класса с точки зрения ее имени и имеет доступ к private полям. Friend-функция должна быть обязательно объявлена в структуре, а определена либо в структуре, либо вне ее.

```c++
    // friend: defined inside or outside; hidden friends
    // static: defined inside or outside
    struct Foo {
    private:
        int x;
    
    public:
        friend void foo(Foo &f) {
            f.x = 10;
        }
    
        static void bar(Foo &f) {  // Also a friend.
            f.x = 10;
        }
    };
    
    // Can also define outside:
    // void foo(Foo &)
    // void Foo::bar(Foo &)
    
    int main() {
        Foo f;
        foo(f);
    
        Foo::bar(f); // вызов статической функции
    }
```
* **Отличия struct/class.**

    В struct по дефолту все методы публичны, если явно не указана private секция. Наследование тоже публично, если явно не указано private. У class все ровно наоборот: наследование приватное, методы и поля приватны, если явно не указана публичная секция.

* **Вложенные классы**
```c++
    #include <iostream>
    
    struct Foo {
        void foo() {
            bar();
        }
        void bar() { // заметим, что внутри класса можно вызывать методы без 
            foo();   // предварительного declaration, чего нельзя делать вне структуры
        }
    
        struct Bar {
        };
    };
    
    int main() {
        Foo::Bar b; // вызов вложенной структуры Bar
    }
```

**Агрегатная инициализация простых классов через {}**
    Мы можем инициализировать поля простого класса таким способом с C++11. Если не все поля структуры переданы в {} будет warning, но поле просто примет дефолтное значение.
```c++
    #include <iostream>
    
    struct ratio {
        int num;
        int denom;
    };
    
    int main() {
        // aggregate initialization. Looks like an automatically generated constructor
        [[maybe_unused]] ratio r1{};
        [[maybe_unused]] ratio r2{3};  // num = 3, warning about missing 'denom' initializer
        [[maybe_unused]] ratio r3{3, 4};  // num = 3, denom = 4
    }
```



</details>

<details>
<summary>
 Билет 21. Функции-члены (методы)
</summary>


* ## Синтаксис объявления и вызова через `.` или `->`.

[Данный момент в лекции](https://youtu.be/Ff1pBiDkPOA?t=2021)
[Соответствующий файл](https://github.com/hse-spb-2021-cpp/lectures/blob/master/03-210916/02-struct/01-struct.cpp)

**Функция-член** (англ. _member function_, жарг. _метод_) - функция, которая позволяет работать с объектом и всеми его полями класса, в котором объявлена (но при этом `friend` и `static` методами не являются, смотри ниже)

Синтаксис объявления - написали обычную функцию, но внутри структуры

```c++
struct Point {
    // members
    int x, y;

    // member function
    int dist2() {
        return x * x + y * y;
    }
}
```

(А ещё можно объявить в структуре, а определить потом вообще в другом месте, смотри последний пункт билета)

К функции добавляется аргумент, который не видно (_неявный аргумент_) `this`, смотри ниже. 

Синтаксис вызова через `.`:

```c++
...
Point p;
p.x = 10;
p.y = 20;
std::cout << p.dist2() << "\n";
...
```

По сути это просто вызов метода от объекта.

Синтаксис вызова через `->`, как и при работе с обычными указателями:

```c++
...
Point *p2 = &p;
std::cout << p2->dist2() << "\n";
```

По сути `p2->dist2()` это просто обёртка над `(*p2).dist2()`

* ## Ключевое слово `this`

[Данный момент в лекции](https://youtu.be/Ff1pBiDkPOA?t=2054)

К функции добавляется аргумент, который не видно (_неявный аргумент_) `this` - объект (==указатель на объект!==), на которой этот метод был вызван.

В отличие от питона (в котором аргумент `self` явный), к полям можно обращаться просто по именам (вместо `self.x` в том же питоне)

[Более подробно про `this`](https://youtu.be/ZStm-I4K0so?t=4529)

`this` - в любом методе (именно методе, `friend` и `static` не методы) объект, на котором мы вызываем метод, **указатель** на структуру, в которой работаем.

  * ### Где его можно не писать, зачем писать хоть где-то.
  
  Можно не писать при обращении к полям объекта, в методе от которого мы работаем. 
  
  ==ИСТОЧНИК ОТСУТСТВУЕТ==
  Писать нужно, когда мы в методе хотим, например, закинуть куда-нибудь ссылку на себя, например при реализации двусвязного списка:
  
```c++
struct node {
	int value;
	node *prev; 
    node *next;
    
    void append_right(node *child) {
        next = child;
        child->prev = this;
    }

    void append_left(node *child) {
        prev = child;
        child->next = this;
    }
};
```
  
  * ### Чем метод отличается от свободной функции.
  
  [Данный момент в лекции](https://youtu.be/ZStm-I4K0so?t=4395)
  
  Методы объявляются в структуре, могут рекурсивно вызываться друг из друга без необходимости предварительного объявления (т.к. внутри структур совместимости с `C` уже нет, можно жить в два прохода):
  
```c++
struct Foo{
  void foo() {
    bar();
  }
    
  void bar() {
    foo();
  }
};
```
  
  Метод - функция-член, находится в структуре, ей же и принадлежит. Сразу же имеет доступ к приватным полям (да и вообще к `this`)
  
  Свободная функция - функция, не находящаяся в какой-либо структуре, не имеет доступа к приватным полям
  
  А ещё есть `friend` функции, которые могут быть определены снаружи, но при этом иметь доступ к приватным полям. Методами не являются, по сути -- свободные функции
  
  А ещё есть `static` функции, которые всё ещё `friend`, которые всё ещё не методы, но она лежит внутри класса (с точки зрения имени)
  
  * ### Захват `this` в лямбды: `[]`, `[=]`, `[&]`, `[this]`, `[*this]`
  
[Соответствующий момент в лекции](https://youtu.be/XdrSzs04HKU?t=3195)
[Соответствующий файл](https://github.com/hse-spb-2021-cpp/lectures/blob/master/13b-211215/02-lambdas/01-lambda-captures.cpp)

С данной темой связан билет: Функторы и лямбды
  
  Будем рассматривать следующую ситуацию:
  
```c++
struct Foo {
    int member_var = 10;
    static inline int static_member_var = 20;
    int arr[10'000];

    void method() {
        int local_var = 30;
        static int static_local_var = 40;
        [[maybe_unused]] long long local_big[100]{};
        ...
    }
};
```

Если мы далее в `method` объявим лямбду через `[]`, то у неё будет доступ к объектам со `static`-storage duration, к `this` (и, как следствие, к `member_var`, `arr`) доступа нет

Если же мы объявим через `[=]`, т.е. всё по значению, то указатель `this` захватится по значению! И у лябмды будет прямой доступ к `member_var` и `arr`, без копирований. (А остальные локальные захватятся по значению, если будут использоваться)
Подводя итог по `[=]` - имеем прямой доступ к полям структуры, из которой вызвались, можем их редактировать и радоваться жизни (т.к. указатель не константный)

При лямбде через `[&]` захват идёт не по значениям, а по ссылкам, в том числе у нас будет ссылка на `this`, а не копия указателя.
Всё ещё легально редактировать поля, т.к. прямой доступ есть, хоть и по ссылке на указатель.

Можно захватить `[this]` - просто захват указателя на себя по ссылке

А можно явно захватить прям объет `this` - `[*this]`, теперь будет целиком скопирован весь объект, всё будет скопировано внутрь, в лямбду.


  
* ## Const correctness: ограничение доступа к полям (в том числе ссылочным и указателям) при константном `this`.

  * ### Когда возникает константный `this`.
  
  [Данный момент в лекции](https://youtu.be/Ff1pBiDkPOA?t=2372)
  [Соответствующий файл](https://github.com/hse-spb-2021-cpp/lectures/blob/master/03-210916/02-struct/02-const.cpp)
  
  Пусть у нас есть функция, которая принимает объект по константной ссылке (чтобы не менять и не копировать объект):
  
```c++
  void print(const Point &p) {
      std::cout << p.x << " " << p.y << "\n";
      std::cout << p.dist2() << "\n";
  }
```
  
  Если `dist2` реализован так, как мы его описывали ранее:
  
```c++
  struct Point {
      ... 
      int dist2() {
          return x * x + y * y;
      }
  }
```
  
  То данный код не скомпилируется с ошибкой вида `error: passing 'const Point' as 'this' argument discards qualifiers`
  
  `p` - `const Point`, `this` - объект, на котором работаем. Компилятор по умолчанию считает, что любой метод меняет объект.
  Как итог: компилятор видит, что метод `dist2` меняет объект, значит его нельзя вызывать на константном `this`.

  
  * ### Const qualifier и ограничения внутри такого метода.
  
  Сам компилятор посмотреть на тело метода и понять, что ничего не меняется, не может (реализация может быть вообще в другом месте, например).
  
  В таком случае мы сами должны указать компилятору, что метод не меняет объект - добавить `const` qualifier:
  
```c++
int dist2() const {
    return x * x + y * y;
}
```

   Теперь компилятор разрешает вызывать этот метод на константных объектах, и при компиляции данного метода компилятор проверит, что метод не изменяет ни одно из полей.
   
   Общее правило: если вы можете сделать какой-то метод константным - сделайте. 
  
  * ### Когда будет UB при отбрасывании const qualifier внутри метода.
  
  Пусть у меня `dist2` не константный, но я очень хочу вызвать его на константном объекте. Можно попробовать взять неконстантную ссылку на объект и вызвать метод от неё.
  
  Если брать ссылку тупым образом `Point &p2 = p`, то произойдёт падение на этапе компиляции: `error: binding reference of type 'Point&' to 'const Point' discards qualifiers`
  
  Но мы знаем про приведение типов и C-style cast.
  
```c++
void print(const Point &p) {
    std::cout << p.x << " " << p.y << "\n";

    Point &p2 = (Point&)p;
    std::cout << p2.dist2() << "\n";
}
```

  Вообще C-style cast-ом пользоваться не нужно, он творит хрень. Он и сейчас сотворит хрень, но прямо сейчас это **не UB**, потому что наш метод **действительно ничего не меняет** и исходная точка `p`, которую мы передали в функцию, была не константной.
  
  А вот если, например, сделать так (объявить точку `p` константной):
  
```c++
int main() {
...
    const Point const_p{30, 40};
    print(const_p);
}
```

  И вот теперь начинается **UB**
  
  Запрещается вызывать неконстантные методы на исходно константных объектах.
  
  Объяснение: константные объекты могут храниться в памяти, в которую ничего нельзя записывать, это может быть другое адресное пространство и неконстантному методу будет плохо.
  
  А `static_cast` просто не скомпилируется, используйте `static_cast`. А ещё существует `const_cast`, который позволяет отбрасывать константность. Но он заметный и почти не возникает в реальности.
  
  Итог: при отбрасывании `const`-квалификатора произойдёт **UB** если

  1) Исходный объект был сам по себе константным (тут точно произойдёт)
  2) Метод как-то изменяет поля объекта (а вот тут уже не факт, Егор сам не уверен)
  
* ## Ref qualifier `&`

[Данный момент в лекции](https://youtu.be/DXABuiEBx-8?t=1100)
[Соответствующий файл](https://github.com/hse-spb-2021-cpp/lectures/blob/master/07-211013/02-classes/02-ref-qualifier.cpp)

Пусть есть что-то такое:

```c++
class stack {
    std::vector<int> data;

public:
    void push(int x) {
        data.push_back(x);
    }

    ...
};

stack foo() {
    stack s;
    s.push(1);
    s.push(2);
    return s;
}

int main() {
    foo().push(10);
}
```

Что произойдёт в `main`? `foo()` вернёт временный объект, у которого мы ещё вызвали `push`. Всё легально, но звучит как чушь, без особого смысла поменяли временный объект.

Как запретить? Добавить _ref qualifier_ (один амперсанд в то же место, где был `const` квалификатор):

```c++
...
void push(int x) & { // ref qualifier
    data.push_back(x);
}
```

Теперь этот метод нельзя вызывать на временных объектах, при попытке компиляции нам сообщат, что мы пытаемся отбросить квалификатор, вызывая этот метод от временного объекта.

Кстати, если совместить `const` и `ref` квалификаторы, то получим константную ссылку, но всё и так передаётся по константной ссылке, так что `const&` окажет 0 эффекта.

_ref qualifier_ - 

* ## Определение методов внутри и снаружи класса, неявный `inline` и зачем.

[Немного про определения методов внутри и снаружи класса](https://youtu.be/ZStm-I4K0so?t=4604)

Мы можем объявить метод внутри структуры:

```c++
struct Foo {
    void foo(int n);    // Declaration
};
```

А определить уже снаружи, но тогда нам потребуется "полное имя" функции:

```c++
void Foo::foo(int n) {
    std::cout << "called foo(" << n << ")\n";
}
```

Бывает полезно, поскольку иногда у нас функции объявляются в одном файле, а определяться могут в другом, и вообще в другой единице трансляции

[Файл про `inline`](https://github.com/hse-spb-2021-cpp/lectures/tree/master/08-211020/03-linkage/01-inline)
[Про `inline` на лекции](https://youtu.be/XdrSzs04HKU?t=4074)

`inline` по сути относится к `linkage` сообщает о том, что можно забить на ODR и выбирать любое определение функции, т.к. они одинаковые. Исторически - функцию нужно скопировать вместо вызова, но сейчас это уже не всегда выполняется компилятором.
Проблема - везде нужно видеть её тело. И так далее, смотри `inline` в другом билете.
 
 Но нас сейчас интересует неявный `inline`.
 
 `inline` необходим для методов класса, если вы их реализуете снаружи (в header-е, но вне тела структуры), но при реализации метода внутри структуры `inline` добавляется автоматически. Логика: если вы пишете структуру, то пишете её в хэдере, если реализовали метод в структуре, то это тоже в хэдере, значит метод реализуют в нескольких единицах трансляции, значит нужен `inline`.
 
</details>

<details>
<summary>
 Билет 22. Статические члены класса
</summary>

Обычные члены класса относятся к конкретному объекту. Статические члены же относятся ко всему классу. 
```c++
struct Foo {
    Foo() {
        Foo::objectCount++;
    }
    static int objectCount;
};

int Foo::objectCount = 0; // exactly one definition in exactly one TU!

int main() {
    std::cout << Foo::objectCount << '\n';  // 0
    Foo a1;
    Foo a2;
    std::cout << Foo::objectCount << '\n';  // 2
}
```
### Статические поля
Обратите внимание, что в примеры выше поле `objectCount` **объявлено и определено раздельно**.

Почему так? Потому что непонятно, где нужно выделить память на это поле. Где мы определили, там и выделится.

Кроме того определение статического поля должно быть **одно и только в одной единице трансляции**. ODR.

#### Слово `inline`
Если хочется всё-таки сразу объявить поле внутри класса, то можно добавить ключевое слово `inline`. Тогда объявление вне класса не нужно. 

С классическим смыслом `inline` ODR-выключателя запутанно. Экспериментально выявил, что нельзя несколько раз объявлять, даже в разных единицах трансляции, т.е. ODR не выключился... Хотя вроде по cppreference должно быть можно, ибо external linkage... Почитайте [cppreference](https://en.cppreference.com/w/cpp/language/inline#:~:text=An%20inline%20function%20or%20variable%20(since%20C%2B%2B17)%20with,It%20has%20the%20same%20address%20in%20every%20translation%20unit).
<!-- FIXME: --->

```c++
struct S {
    int n;                    // defines S::n
    static int i;             // declares, but doesn't define S::i
    inline static int x;      // defines S::x
    inline static int y = 1;  // defines S::y
};

int S::i = 3;                 // defines S::i
```

### Обращение к статическим членам
Предполагаемое обращение к статическим члена это `Foo::member`, но для удобства можно и по-другому:
```c++
struct Foo {
    static inline int x = 1;
    static void bar() {}
    void baz() {
        Foo::x;
        Foo::bar();

        x;
        bar();

        this->x;
        this->bar();
    }
};

int main() {
    Foo::x;
    Foo::bar();
    
    Foo obj;
    obj.x;
    obj.bar();
}
```
На статические члены также ожидаемым образом влияют `public/protected/private`. Но объявить статическое поле снаружи тоже можно и доступ к внутренним .
```c++
struct Foo {
private:
    static inline int x = 2;
    static int y;
};

int Foo::y = x + 2;  // ok!

// int a = Foo::y  // can't access private!
``` 

### Порядок инициализации и удаления статических полей
Статические поля имеют static storage duration (см. [билет 15](https://github.com/khbminus/CppTickets/blob/master/tickets/ticket15.md)), поэтому внутри единицы трансляции гарантируется, что инициализация в том порядке, как она записана в файле (кроме некоторых `const`! так как они инициализируются через *const initialization* обычно сразу на этапе компиляции).

Порядок удаления неочевиден (под разными компиляторами даже по-разному).

Больше про это можно прочитать в [билете 33](https://github.com/khbminus/CppTickets/blob/master/tickets/ticket33.md) про static initialization fiasco.

### Статические константы
Если поле сделать `integral` (типа, которое ~почти int: `int`, `char`, `long`, etc.) поле константным, то его можно сразу инициализировать через initializer:

```c++
struct Foo
{
    const static int n = 1;
    const static int m{2};  // Since C++11
    const static int k;
};
const int Foo::k = 3;
```

#### Беды с константами
Кроме этого могут происходить беды с указателями на константы, например:

```c++
// foo.h
struct Foo {
    static const int N = 60; // объявление
}
// fst.cpp
... Foo::N ... // ОК
... &Foo::N ... // может быть undefined reference на этапе линковки
// snd.cpp
... Foo::N ... // ОК
... &Foo::N ... // может быть undefined reference на этапе линковки
```

В чем проблема? У константы должно быть и объявление, и должно быть определение ровно в одной единицы трансляции. Для решения проблемы добавляем определение констант.

```c++
// foo.h
struct Foo {
    static const int N = 60; // объявление
}
// fst.cpp
const int Foo::N; // инициализация и слово `static` не нужны
... Foo::N ... // ОК
... &Foo::N ... // ОК
// snd.cpp
... Foo::N ... // ОК
... &Foo::N ... // ОК
```
Если не писать inline, то необходимо эту константу определить ровно в одном cpp файле, иначе ошибка компиляции (пример выше). Если в двух и более файлах написали определение, то ошибка компиляции.

Если пишем inline, то больше ничего определять не нужно.

```c++
// foo.h
struct Foo {
static inline const int N = 60;
}
// fst.cpp
... Foo::N ... // ОК
... &Foo::N ... // ОК
// snd.cpp
... Foo::N ... // ОК
... &Foo::N ... // ОК
```

Ровно так следует писать константы по мнению Егора.
### Статические методы, отличия от свободных функций и друзей
В статических методах, как можно догадаться, не видно `this`. Обращаться можно только к статическим членам.

Все статические методы сразу `inline`.

* От свободных функций отличаются уровнем доступа: у `static` полный доступ.
* От друзей отличаются синтаксисом. Теоретически можно написать то же самое, но обычно хочется вложить другой смысл.

### Паттерн: статический метод как конструктор с именем
Допустим, хочется класс прямоугольник. Хочется уметь создавать его по координатам левого-нижнего и правого-верхнего концов: `x1`, `y1`, `x2`, `y2`, а также по координате левого-нижнего конца, ширине и высоте: `x1`, `y1`, `width`, `height`.

И то, и то - четыре int, значит signature одинаковый, поэтому компилятор не поймёт, какой вы хотите конструктор.

Вместо этого можно сделать два статических метода вместо конструктора:
```c++
struct Rectangle {
    Rectangle(...) {...}

    static Rectangle makeFromPoints(int x1, int y1, int x2, int y2) {
        return Rectangle(...);
    }

    static Rectangle makeFromWidthAndHeight(int x1, int y1, int width, int height) {
        return Rectangle(...);
    }
};
```

### Полезное
* https://en.cppreference.com/w/cpp/language/inline
* https://en.cppreference.com/w/cpp/language/definition

### Неочевидные источники:
* https://github.com/vladnosiv/hse-spb-conspects-2020/blob/master/C%2B%2B/all-tickets.md#%D0%B1%D0%B8%D0%BB%D0%B5%D1%82-01-%D0%B4%D0%B5%D1%82%D0%B0%D0%BB%D0%B8-%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%BE%D0%B2
* https://olympiads.ru/zaoch/2018-19/lang_docs/cppreference.com/reference/en/cpp/language/static.html
</details>

<details>
<summary>
 Билет 23. Друзья и перегрузка операторов
</summary>

Друзья - это те, кто имеют доступ к приватным полям, не являясь членами класса.
**ВАЖНО**: дружба не наследуется(если базовый класс друг, то дочерний не является по умолчанию другом); дружба не транзитивна(друг моего друга не является моим другом)
- ### Друзья-классы
Внутри нашей структуры говорим, что у нас есть структура-друг(друг получает доступ ко всем приватным полям).
```c++
struct Foo {
private:
	int x = 0;
	friend struct Bar; // Подразумевает, что Bar лежит в этом же namespace
};
struct Bar {
	void foo(Foo &f) {
		f.x++;
	}
	static void sfoo(Foo &f) {
		f.x++;
	}
};
int main() {
Foo f;
// f.x++; //Обращение к приватному полю, выдаст ошибку
Bar b;
b.foo(f); //Изменяет приватное поле Foo, ошибки нет
b.sfoo(f); //Изменяет приватное поле Foo, ошибки нет
Bar::sfoo(f); //Изменяет приватное поле Foo, ошибки нет
}
```
Отмечу, что если реализовать Bar сразу в Foo тогда не нудно слово friend, так как тогда Bar станет так называемым вложенным классом(nested class), а они автоматически считаются друзьями. Пример использования в реальной жизни вложенных классов: итераторы(хеш-таблица, вектор, map и т.д.).  Пример кода:
```c++
struct Foo {
private:
	int field = 10;
	struct NestedClass { // E.g.: hash_table::iterator
		void foo(Foo *b) {
			b->field++;
		}
// Если мы хотим запретить создавать такие объекты вне Foo, говорим, что
// конструктор по умолчанию приватный, а чтобы метод get_nc работал, 
// говорим, что Foo друг(чтобы можно было вызвать конструктор по умолчанию)

/*  private: 
 		NestedClass() {}
 		friend struct Foo;
*/
};
public:
	using get_result = NestedClass; //Публичный псевдоним, чтобы можно было не использовать auto для определения типа
	NestedClass get_nc() {
		NestedClass obj;
		return obj;
	}
};
int main() {
Foo f;
// Foo::NestedClass nc1 = f.get_nc(); // Нельзя, так как NestedClass - приватное имя
auto nc2 = f.get_nc(); // с C++11 можно так
nc2.foo(&f);
Foo::get_result nc3 = f.get_nc();
nc3.foo(&f);
[[maybe_unused]] Foo::get_result nc4;
[[maybe_unused]] decltype(f.get_nc()) nc5; // C++11 (аналог auto, разница будет изучаться в 4 модуле, однако из базового: decltype сохраняет ссылку, если объект ей является, а auto отбрасывает)
}
```
- ### Друзья-функции
Друзья, как уже было отмечено, не являются членами класса. Если у некоторого класса есть функция-друг, то внутри класса нужно обязательно указать, что она друг:
```c++
struct Foo {
	...
	friend void friend_func();
}
```
Определение этой функции может быть как внутри класса:
```c++
struct Foo {
	...
	friend void friend_func() {
		return;
	}
}
```
Так и вне класса:
```c++
struct Foo {
	...
	friend void friend_func();
}
void friend_func() {
	return;
}
```
Ключевая разница заключается в видимости этих друзей. Пример:
```c++
#include <memory>  
// https://www.justsoftwaresolutions.co.uk/cplusplus/hidden-friends.html  
namespace ns {  
struct Foo {  
private:  
    int field = 10;  

	// private/protected/public никак не влияют на друзей, так как они не члены класса
	friend void doit1(Foo *f); // объявили, что функция - наш друг  
	friend void doit2a(Foo *f) { // объявили и определили друга(это скрытый друг)  
		f->field++;  
	}  

    friend void doit2b(Foo *f) { // объявили и определили друга(это НЕ скрытый друг)  
		f->field++;  
	}  

    friend void doit3() { // Объявили и определили друга(его вообще нельзя вызвать ни изнутри класса, ни из вне)  
	// doit3();  
	}  
};  

void doit([[maybe_unused]] Foo *f) {  
    // f->field++;  
}  

void doit1(Foo *f) {  
    f->field++;  
}  

void doit2b(Foo *f);  
} // namespace ns  
int main() {  
    ns::Foo f;  
    //ADL(argument dependent lookup) - если не указан namespace в котором лежит функция, смотрим на аргументы, на их namespace и в нем ищем нужную функцию
    doit(&f); // ADL, сработает
    doit1(&f); // ADL, сработает  
    doit2a(&f); // ADL, сработает
    doit2b(&f); // ADL, сработает  
    ns::doit(&f); // полный вызов, так как указали конкретный namespace, где должжна лежать функция, сработает, так как определение void doit есть внутри namespace ns  
    ns::doit1(&f); // абсолютно аналогично  
    // ns::doit2a(&f); // полный вызов, но внтури namespace ns, нет функции 'ns::doit2a', значит такой вызов не сработает(отсюда и название, друг является скрытым, так как его нельзя вызвать через полный вызов, только через ADL)    
    ns::doit2b(&f); // сработает, так как в namespace ns есть объфвление: "void doit2b(Foo *f);"

	// Что касается doit3: это скрытый друг, так как объявление и определение только внутри структуры, а не namespace, значит его можно вызвать только через ADL, но у него нет аргументов, а значит ни на что ADL посмотреть не может, значит вызвать нельзя.
}
```
Объявление друга до класса, внутри класса - нет разницы.
- ### Друг из другого namespace
  Вернемся к friend struct. Если же мы хотим, чтобы у нас был друг не из нашего namespace, а из другого, то:
```c++
namespace ns2 {
	struct Bar;
}
namespace ns1{
struct Foo {
private:
	friend /*struct*/ ns2::Bar; // слово struct необязательно, потому что компилятор и так зенает, что это структура
};
}
namespace ns2 {
struct Bar {
	...
};
}
```
Функции из других namespace тоже могут быть друзьями(в частности из std):
```c++
struct Foo {
private:
    Foo() {}

    friend std::unique_ptr<Foo> std::make_unique<Foo>(); // Без этой строчки нельзя сделать unique_ptr<Foo>, так как конструктор по умолчанию приватен
};
```
Теперь `Foo` можно сделать только при помощи `unique_ptr`.  Однако, проблема в том, что мы сделали только make_unique другом. Если он не сам вызывает конструктор, а кому-то делегирует это, то все сломается, так как этот кто-то другом не является.  Поэтому лучше так не делать. Лучше делать публичную функцию вместо дружбы с make_unique:
```c++
struct Foo {
	static std::unique_ptr<Foo> make() {
	    // return std::make_unique<Foo>();  // не сработает, так как мы больше не друзья, а конструктор все еще приватный
	    return std::unique_ptr<Foo>(new Foo());  // сработает
	}
private:
    Foo() {}
};
```
- ### Перегрузка операторов
#### Унарные операторы
Операторы, которые работают с одним операндом(оператор унарного минуса или плюса(к примеру, знак у числа), ++, --), бинарные - с двумя(операторы сравнения, арифметические действия, логические операторы).
#### Постфиксные и префиксные операторы(a++ и ++a)
Казалось бы, один и тот же оператор, как тогда перегружать? Решение: постфиксный оператор принимает один параметр типа int(по стандарту гарантируется, что это 0, однако, никто не мешает сделать a.operator++(1234)). Код:
```c++
struct X
{
    // prefix increment
    X& operator++()
    {
        // сделали то, что хотели с this
        return *this; // возвращаем значение по ссылке
    }
 
    // postfix increment
    X operator++(int)
    {
	    X old = *this;
	    this++;
        // сделали то, что хотели с this
        return old; // возвращаем по значению, так как this изменился, а поскольку оператор постфиксный, нам не нужно учитывать это изменение
    }
}
```
#### operator()
Позволяет вызывать объекты нашего класса как функции. Пример:
```c++
#include <algorithm>
#include <cassert>
#include <functional>
#include <iostream>
#include <vector>
struct Greater { // Функтор
	bool operator()(int a, int b) const {
		return a > b;
	}
	int operator()(int a, int b, int c) const { // overloads are possible
		return a + b + c;
	}
};
int main() {
	std::vector<int> v{1, 2, 3, 4, 5, 6, 7, 8};
	const Grater g; // 'const' is optional, just to demonstrate const-qualifier
	assert(g.operator()(5, 4));
	assert(!g.operator()(4, 5));
	assert(g(5, 4));
	assert(!g(4, 5));
	assert(Greater().operator()(4, 5));
	assert(Greater()(4, 5));
	sort(v.begin(), v.end(), g /* Greater() */);
	for (int x : v) {
	std::cout << x << "\n";
	}
}
```
Для функторов еще есть следующее:
```c++
Greater c;
std::reference_wrapper<Greater> cwrap = c; // копируемая ссылка на с
```
Эта штука позволяет вызывать только оператор круглые скобки, удобно тем, что это ссылка, а не большой объект. Второе назначение: если мы передаем функтор, который меняется при вызове операторы круглые скобки в функцию, которая вызывает наш функтор(например, sort или for_each), тогда нам может быть интересно финальное состояние функтора. Для этого передаем ссылку, а не просто по значению.
#### operator&&, operator|| и operator,
Если эти операторы не перегружены, то гарантируется, что выражения будут выполняться по порядку(порядок - тот, в котором выражения написаны). Если же их перегрузить, то автоматически отключаются все гарантии на порядок выполнения, за этим нужно отдельно внимательно следить.
#### Минимизация лишних копирований и кода
Принято реализовывать операторы +, -, *, / через +=, -=, *=, /=, так как  в этом случае мы минимизируем количество копирований(рассмотрим на примере + и +=): += принимает две ссылки и меняет первую(0 копирований), а + принимает первый параметр по значению, второй по ссылке, к первому добавляет(через += ) второй и возвращает первый(1 копирование). Если же делать наоборот, то придется при вызове += сделать копирование, так как оператор + вернет значение. А могло быть 0 сравнений.
Для операторов сравнения принято реализовывать оператор меньше, так как через него можно выразить все остальное и при этом обычно в stl принимают оператор меньше(в sort, set) :
```c++
bool operator< (const X& lhs, const X& rhs){ /* do actual comparison */ }
bool operator> (const X& lhs, const X& rhs){ return rhs < lhs; }
bool operator<=(const X& lhs, const X& rhs){ return !(lhs > rhs); }
bool operator>=(const X& lhs, const X& rhs){ return !(lhs < rhs); }
bool operator==(const X& lhs, const X& rhs){ return (lhs <= rhs) && (lhs >= rhs); }
bool operator!=(const X& lhs, const X& rhs){ return !(lhs == rhs); }
```
#### Конвенция для типов параметров, типа возвращаемого значения
Операторы составного присваивания принимает константную ссылку(потому что меняем this, а значение того, что мы добавляем обычно не меняется, а копировать бессмысленно), а возвращает ссылку, так как мы хотим поддерживать конструкции вида a += b += c. Для арифметических действий наоборот принимать один аргумент по значению, а второй по константной ссылке(так как он не меняется, а первый элемент должен быть по значению, так как его менять не надо), а возвращают такие операторы по значению, чтобы работали конструкции вида a + b + c. Операторы сравнения возвращают bool(результат сравнения), а принимают две константные ссылки, так как при сравнении значения обычно не меняются, лишний раз копировать нет смысла.
#### Делать оператор свободной функцией или членом, последствия для преобразований (conversions)
Обычно операторы сравнения делают свободными, чтобы могли работать неявные преобразования. Если сделать его членом класса, тогда неявное преобразование будет выполняться только для правого аргумента, а если свободной функцией - то сразу для двух аргументов. Из этой же логики обычно +, -, *, / обычно делаются свободными, а составные присваивания наоборот. Является ли оператор другом - определять надо из логики, что мы хотим минимизировать количество функций имеющих доступ к приватным полям.
-   ### Отличия  a + b,  a.operator+(b),  a.operator+()
    a.operator+(b) - вызов оператора +, реализованного для объектов того же типа, что и a, то есть если неявное преобразование и произойдет, то только у b.
    a + b - вызов оператора +, который может быть реализован через свободную функцию, то есть неявное приведение можнт сработать как для a, так и для b.
    Пример, когда это существенно:
```c++
#include <iostream>

struct bigint {
    bigint(int) {}
    friend bigint operator+(const bigint&, const bigint&) {return 1;}
};

int main() {
    int lhs = 3;
    bigint a = lhs + bigint(3);  // ok, так как есть функция, которая может преобразовать int в bigint, и тогда вызовется наша перегрузка оператора
    bigint b = lhs.operator+(bigint(3));  // CE, так как у int нет оператора сложения с bigint
}
```
    a.operator+() - вызов унарного плюса(это другой оператор). Пример его использования:
```c++
char c = '0';
+c // имеет тип int(оператор унарного плюса для целочисленных типов преобразует к типу большего размера)
```
- ### Проблемы с самоприсваиванием и самомодификацией
  Пусть у нас есть класс Ratio - рациональная сокращенная дробь. Предположим, что мы хотим выполнить следующее:
```c++
#include <iostream>

struct Ratio {
	int num, denom;
	Ratio &operator/=(const Ratio &other) {
		num *= other.denom;
		denom *= other.num;
		return *this;
	}
};

int main() {
	Ratio r{2, 3};
	r /= r;
	std::cout << r.num << " " << r.denom << std::endl;
}
```
Логично предположить, что ответ должен быть "6 6", однако ответ получается "6 18".  Дело в том, что мы принимаем ссылку. Она константная, это значит, что через нее значение не поменять, однако значение, на которое она указывает может меняться. И поскольку эта ссылка указывает на this, мы получаем, что к моменту выполнения строчки `denom *= other.num;` числитель успевает поменяться на 6 и из-за этого denom считается некорректно. Как исправить: принимать по значению либо заифать случай, когда other и this одно и то же(в данном случае возвращать дробь 1/1).
</details>

<details>
<summary>
 Билет 24. Преобразования
</summary>


Преобразование одного типа в другой.  
Бывают явные(explicit) и неявные(implicit).  
Явные — программист чётко прописывает, что хочет преобразовать тип:

```C++
double a = 123.4;
int b = static_cast<int>(a); // кастуем a к int
```

```C++
struct foo{ foo(int){} }
void bar(foo){}
int main{
    int k = 2;
    bar(foo(k)); // создаём объект foo от k и передаём в функцию
}
```

Неявные — умняш компилятор сам догадывается, что во что нужно преобразовать.

```C++
double a = 123.4;
int b = a; // компилятор сам понял, что хотим привести double к int
```

```C++
struct foo{ foo(int){} };
void bar(foo){}
int main(){
    int k = 2;
    bar(k); // компилятор догадался создать foo от int k и передать его в функцию bar
}
```

### Implicit

```C++
#include <iostream>

struct ratio {
    int num;
    int denom;
    
    // конструктор без параметров
    ratio() {
        num = 0;
        denom = 1;
        std::cout << "Default constructor\n";
    }
    
    // конструктор с параметром типа int
    ratio(int value) {
        num = value;
        denom = 1;
        std::cout << "ratio(int)\n";
    }
};

// функция ожидает на вход константную ссылку на объект типа ratio
void println(const ratio &r) {
    std::cout << r.num << " " << r.denom << "\n";
}

ratio generate_ratio() {
    return 123; // превращается в return ratio(123);
}

int main() {
    ratio r = 10; // вызывается конструктор ratio(int)
    println(r); 
    println(10); // println(ratio(10));
    println(generate_ratio());
}
```

В коде выше 3 раза происходит неявное преобразование.  
Для `ratio r = 10;` компилятор выполнил то же самое, что выполнил бы для `ratio r = ratio(10);`, то есть произошло
неявное преобразование int — 10 к ratio.  
`println(10)` здесь — это `println(ratio(10))`.  
Наконец

```C++
ratio generate_ratio() {
    return 123;
}
```

есть на самом деле

```C++
ratio generate_ratio() {
    return ratio(123);
}
```

Во всех трёх случаях компилятор пытается найти конструктор, в который может передать int и неявно его использовать.

#### Пытливые умы спросят

Что если сделать `ratio r = 1.4;`?  
В этом случае компилятор запустит цепочку преобразований double->int->ratio. Подробнее об этом в последнем параграфе.

### Почему неявные преобразования — не всегда хорошо?

```C++
void print_vector([[maybe_unused]] const std::vector<int> &vec) {
}

int main() {
    [[maybe_unused]] std::vector<int> v1(10); // Норм
    [[maybe_unused]] std::vector<int> v2 = 10; // Не норм
    print_vector(10); // Почему, а главное зачем?
}
```

Существует конструктор vector(int n), который создаёт вектор из n дефолтных значений.  
Но тогда почему бы не вызвать неявно `[[maybe_unused]] std::vector<int> v2 = 10;`?  
Потому что выглядит ~~всрато~~ не интуитивно. Вполне разумно было бы ожидать от такой конструкции получить вектор {10,
}.  
Совсем странно выглядит `print_vector(10);`
Вроде хотим вывести вектор, а аргумент — число. Непорядок.  
Благо в stl умные дяди позаботились и _предусмотрели_, поэтому эта штука не скомпилируется, но если бы вместо
стандартного vector мы бы использовали самописную структуру

```C++
struct my_vector {
    my_vector() {}
    my_vector(int) {}
};
```

всё скомпилировалось бы.

### Чтобы не напороться на такую проблему существует Explicit.

Помечаем конструктор словом explicit и запрещаем неявные преобразования.

```C++
struct my_vector {
    my_vector() {}
    explicit my_vector(int) {}
};
```

Теперь можем только явно вызвать конструктор от int.

```C++
    [[maybe_unused]] my_vector v1(10); // Компилится
    [[maybe_unused]] my_vector v2 = static_cast<my_vector>(10); // Компилится
    // [[maybe_unused]] my_vector v2 = 10; // Не компилится
    // print_vector(10); // Не компилится
```

`static_cast<T>` — явное преобразование к типу T.

#### Explicit можно использовать для конструкторов с несколькими параметрами или без параметров

Например, хотим запретить неявно создавать объект при помощи `{}`.  
Это полезно, потому что зачастую `Object{a, b, c}` интуитивно понятнее и логичнее, чем `{a, b, c}` 

```C++
struct Foo {
    explicit Foo() {}

    explicit Foo(int, std::string) {}
};

void call(const Foo &) {
}

Foo ret() {
    return Foo{}; // OK
    // return {}; // BAD

    return Foo{10, "hello"}; // OK
    // return {10, "hello"}; // BAD
}

int main() {
    [[maybe_unused]] Foo f1{10, "hello"}; // OK
    // [[maybe_unused]] Foo f2 = {10, "hello"}; // BAD

    [[maybe_unused]] Foo f3{}; // OK

    [[maybe_unused]] Foo f4 = Foo{}; // OK
//    [[maybe_unused]] Foo f4 = {}; // BAD

    call(Foo{10, "hello"}); // OK
    // call({10, "hello"}); // BAD

    call(Foo{}); // OK
    // call({}); // BAD
    ret();
}
```

#### Можно ли запретить только некоторые неявные преобразования?

> По умолчанию нельзя, но в конце 4 модуля можно будет разрешить преобразование в произвольный тип, а потом вызывать ошибку компиляции, если он не совпал с желаемым. Но там больно.
> —Егор

### Операторы преобразования

#### Проблема

```C++
struct ratio {
    int num;
    int denom;
};

int main() {
    ratio r{3, 4};
    double x = r; // Нельзя
}
```

Не можем преобразовать объект нашего класса в double, потому что в double нет конструктора от ratio. Можно было бы
дописать, будь он нашим классом, но double, во-первых, не наш, во-вторых, не класс.

#### Решение

```C++
struct ratio {
    int num;
    int denom;

    operator double() const {
        std::cout << "operator double()\n";
        return num * 1.0 / denom;
    }
};
```

Дописали `operator double() const{}` теперь наш ratio умеет конвертироваться в double.

#### Приятный побочный эффект

Начинает работать

```C++
ratio r{3, 4};
std::cout << r << "\n";
```

Потому что `std::cout` умеет работать от double, а ratio теперь умеет неявно преобразовываться в double.  
То есть на самом деле код выше отработает, как
```C++
ratio r{3, 4};
std::cout << r.operator double() << "\n"; // явное преобразование к double
std::cout << static_cast<double>(r) << "\n"; // то же самое
```

### Можно пометить оператор explicit

```C++
struct ratio {
    int num;
    int denom;

    epxlicit operator double() const {
        std::cout << "operator double()\n";
        return num * 1.0 / denom;
    }
};
```

Например, решили, что не хотим неявно преобразовывать в double, чтобы не потерять точность.

```C++
ratio r{3, 4};
double x = r; // не скомпилируется, потому что запретили неявное преобразование
double x = static_cast<double>(r); // явное преобразование к double — работает
std::cout << x << "\n";
std::cout << static_cast<double>(r) << "\n"; // тоже явное, тоже работает
```

### Ошибки из-за неоднозначности

```C++
struct Foo {
    // оператор преобразования Foo к Bar
    operator Bar() {
        return Bar{};
    }
};

struct Bar {
    Bar() {}
    // конструктор Bar от Foo
    Bar(Foo /*arg*/) {}
};

int main() {
    Foo f;
    Bar b = f;  // ambiguous
}
```

Foo умеет преобразовываться в Bar, но и Bar умеет создаваться от Foo.  
То есть имеем два способа преобразовать Foo к Bar, между которыми компилятор не может выбрать, поэтому не компилирует
вовсе.
#### Можно починить
Для этого пометим один из методов explicit
```C++
struct Bar;

struct Foo {
    operator Bar();
};

struct Bar {
    Bar() {}

    explicit Bar(Foo /*arg*/) {
        std::cout << "Bar(Foo)";
    }
};

Foo::operator Bar() {
    std::cout << "Foo::operator Bar()";
    return Bar{};
}

int main() {
    Foo f;
    Bar b = f;
}
```
Теперь неявно может вызваться только `Foo::operator Bar()`, это и произойдёт.

### Возвращаясь к неявным преобразованиям

#### Порядок преобразований

Последовательность преобразований состоит из:
<ol>
  <li>0 или 1 стандартная последовательность преобразований.</li>
  <li>0 или 1 пользовательское преобразование.</li>
  <li>0 или 1(только если было выполнено пользовательское преобразование) стандартная последовательность преобразований.</li>
</ol>

Стандартная последовательность преобразований — например, преобразование между численными типами. Подробнее про это
можно почитать [здесь](https://en.cppreference.com/w/cpp/language/implicit_conversion)

##### Пример

```C++
struct Foo {
    Foo(int) {}
};

struct Bar {
    Bar(const Foo&) {}
};

void call_with_bar(const Bar&) {
}

int main() {
    // На стандартные преобразования тип 'Bar -> const Bar' забиваем, но вообще они есть.
    call_with_bar(Bar(Foo(10)));  // все преобразования явные
    call_with_bar(Bar(Foo(10LL)));  // стандартное неявное преобразование long long -> int
    call_with_bar(Foo(10));  // пользовательское неявное преобразование Foo -> Bar
    call_with_bar(Bar(10));  // пользовательское неявное преобразование int -> Foo
    call_with_bar(Bar(10LL));  // стандартное неявное преобразование long long -> int + пользовательское неявное преобразование int -> Bar
    // call_with_bar(10);  // два неявных пользовательское преобразование: int -> Foo -> Bar
}
```

Строчка `call_with_bar(10);` не скомпилируется, потому что ей требуется два пользовательских преобразования, а
допускается только 0 или 1.

##### Зачем такие ограничения?

Потому что в момент вызова `call_with_bar(10)` совершенно неясно почему и откуда должна взяться промежуточная структура
Foo, а ведь она может быть и не одна.

```C++
struct Foo {
    Foo(int) {}
};

struct Baz {
    Baz(int) {}
};

struct Bar {
    Bar(const Foo&) {}
    Bar(const Baz&) {}
};

void call_with_bar(const Bar&) {
}
int main() {
    call_with_bar(10);
}
```

Чтобы это заработало, пришлось бы перебирать все промежуточные вершины преобразований(int -> Foo -> Bar или int -> Baz
-> Bar), а это долго, сложно, и стреляло бы по ногам, поэтому запретили.

### std::string — обычный пользовательский тип

Он определен в стандартной библиотеке, но с точки зрения языка ничем не примечателен. Отсюда следующее:

```C++
#include <string>

struct Foo {
    Foo(const std::string&) {}
};

void call_with_foo(const Foo&) {
}

int main() {
    call_with_foo(Foo(std::string("hello"))); // все преобразования явные
    call_with_foo(Foo("hello"));  // неявное пользовательское преобразование const char[6] -> std::string
    call_with_foo(std::string("hello")); // неявное пользовательское преобразование std::string -> Foo
    // call_with_foo("hello");  // требуется 2 неявных преобразования

    {
        using namespace std::literals; // используем стандартные литералы
        call_with_foo("hello"s);  // "hello"s — это std::string, 
                                  // поэтому здесь 1 неявное преобразование string -> Foo
    }
}
```

### Оператор bool

Позволяет преобразовывать объект к bool, например

```C++
while(std::cin >> x){}
whlie((std::cin >> x).operator bool()){}
```

это две одинаковых строчки.

#### Проблема

С точки зрения языка bool — это число и его легко неявно преобразовать к int. Причём такое преобразование является
стандартным, а не пользовательским.  
Из-за этого можно сделать вот так:

```C++
#include <iostream>

struct Foo {
    operator int() {
        return 10;
    }
};

struct Bar {
    operator bool() {
        return true;
    }
};

int main() {
    [[maybe_unused]] Foo f;
    [[maybe_unused]] Bar b;
    [[maybe_unused]] bool x1 = f;  
    [[maybe_unused]] bool x2 = b;  

    if (f) {}
    if (b) {}

    for (; f;) {}
    for (; b;) {}

    while (f) {}
    while (b) {}

    [[maybe_unused]] int x3 = 10 + f;
    [[maybe_unused]] int x4 = 10 + b;
}
```

Foo и Bar могут быть какими-то сложными структурами, а мы используем их как bool или int.  
Использовать Bar как bool — нормально, потому что у него для этой цели определён operator, но очевидно не ожидалось, что
кто-то будет использовать этот класс для арифметики.  
Аналогично и Foo предполагалось преобразовывать только к int, но никак не к bool.  
В C++03 с этим боролись при помощи [safe bool idiom](https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Safe_bool).

#### Начиная с C++11 решение приятное и лаконичное.

Просто дописываем к операторам explicit, чтобы запретить неявные преобразования.

```C++
#include <iostream>

struct Foo {
    explicit operator int() {
        return 10;
    }
};

struct Bar {
    explicit operator bool() {
        return true;
    }
};

int main() {
    [[maybe_unused]] Foo f;
    [[maybe_unused]] Bar b;
    // [[maybe_unused]] bool x1 = f;
    // [[maybe_unused]] bool x2 = b;

    // if (f) {}  // неявное преобразование int -> bool запрещено
    if (b) {}  // преобразовали к bool

    // for (; f;) {}
    for (; b;) {}

    // while (f) {}
    while (b) {}
    
    [[maybe_unused]] int x3 = 10 + static_cast<int>(f); // явно преобразовали к int
    // [[maybe_unused]] int x3 = 10 + f; // не срабоатет, потому что неявное
    // [[maybe_unused]] int x4 = 10 + b; 
}
```

Теперь Bar можем использовать только как bool, а Foo только как int и только при явном преобразовании.  
Важно заметить, что по стандарту языка внутри конструкций `if, for, while` преобразование к bool является **явным**.

</details>

<details>
<summary>
 Билет 25. Функторы и лямбды  
</summary>


Функциональный объект, иногда называемый функтор - что угодно, к чему применима семантика вызова, как у функции.

Функторами могут быть:

* функции
* указатели на функции 
* объекты с перегруженным `operator()`

### `operator()`

```c++

struct Greater {
	bool operator()(int a, int b) const {
		return a > b;
	}
	bool operator()(int a) const {                    // overloads are possible
	    return a > 0;
	}
	bool operator()() const {
	    return true;
	}
};

int main() {
	const Greater comparator;

	std::cout << comparator.operator()();              // true
	std::cout << comparator.operator()(-8);            // false
	std::cout << comparator.operator()(100, 99);       // true

	std::cout << comparator();                         // true
	std::cout << comparator(-8);                       // false
	std::cout << comparator(100, 99);                  // true

	std::cout << Greater().operator()();               // true
	std::cout << Greater()(-8);                        // false
	
	std::vector<int> vec{1, 2, 3, 4, 5, 6, 7, 8}; 
	std::sort(vec.begin(), vec.end(), comparator);     // will reverse vector
}

```

`operator()` логично помечать `const`, т.к. обычно функторам не нужно мутировать состояние


### использование функторов

В примере выше функтор передаётся в `std::sort` в качестве компаратора. Так же его моджно передать в `std::set`. Т.к.
set хочет скопировать компаратор в себя (как и почти всё в STL) и считает, 
что компаратор не может менять состояние при вызове, так что`operator()` придётся пометить `const`. 

```c++
int levenshtein_distance(std::string const& a, std::string const& b);


struct Closer {
    std::string template;

    bool operator()(std::string const& a, std::string const& b) const {  // 'const' is important
        return levenshtein_ditance(a, template) < levenshtein_ditance(b, template);
    }
};

int main() {
    using namespace std::literals;
    std::set<std::string, Closer> v1({"meow"s, "woof"s, "oink"s, "quack"s}, Closer{"meow"s});
    std::set<std::string, Closer> v2({"meow"s, "woof"s, "oink"s, "quack"s}, Closer{"woof"s});
}

```

При присвоении `std::set` компараторы тоже поменются. 

Обычно аргументы в `operator()` передают по констанной ссылке - очень странно, если компаратор хочет изменить свои аргументы, 
а копирование занимает время.  

Заметим, что из-за того, что большинство алгоритмов STL принимает функторы с семантикой копирования, при передаче 
функтора, как аргумента в алгоритм `std::all_of`, `std::any_of`, `std::for_each` и т.д. состояние функтора никак не поменяется.
`std::for_each` возвращает функтор после применения его к аргументам, так что в его состоянии всё-таки можно что-то хранить.

```c++
struct Functor {
	int val = 0;
	void operator()(int) {
		val++;
	}
};

int main() {
	Functor c;
	std::vector<int> v(100, 0);
	auto used = std::for_each(v.begin(), v.end(), c); // Если operator() менял состояние c, то этот вызов отразится на c
	std::cout << c.val << std::endl;                  // 0
	std::cout << used.val << std::endl;               // 100
}

```

Функторы можно складывать в  `std::function`, при этом он копируется в объект с dynamic storage duration
(ну если там нет small object optimization)

Для хранения ссылок на функторы есть тип `std::reference_wrapper` из библиотеки `functional`, 
который позволяет сохранять ссылки на функторы в `std::vector` или
где-нибудь ещё и прокидывает наверх `operator()`, оставляя возможность вызывать функтор, лежащий по ссылке.
При этои если у хранимого объекта нет такого оператора с подходящей сигнатурой код не скомпилируется (см. perfect forwarding
и ленивое раскрытие шаблонов)

Канонический способ создания `std::reference_wrapper` -  `auto func = std::ref(functor);`

У этого типа есть метод `get`, возвращающий обычную ссылку на объект, на который ссылается `std::reference_wrapper`.

Теперь функторы можно передавать в алгоритмы stl


```c++
struct Functor {
	int val = 0;
	void operator()(int) {
		val++;
	}
};

int main() {
	Functor c;
	std::vector<int> v(100, 0);
	std::for_each(v.begin(), v.end(), std::ref(c)); // Если operator() менял состояние c, то этот вызов отразится на c
	std::cout << c.val << std::endl;                // 100
}
```
`std::reference_wrapper` не владеет, тем на что ссылается и может быть висячим.

### лямбды

Лямбда-выражения - синтаксический сахар для создания функторов. Тип созданного функтора невозможно описать,
поэтому сохранять объекты этого типа можно только через `auto` или, если
выражение такого типа уже можно написать, то при помощи `decltype`. Синтаксис лямбда-выражения `[<capture>](<arguments>){<body>}`.
Тип возвращаемого функтором значения выводится сам (на самом деле его можно задать используя синтаксис `-> Type`).


Поля получившегося объекта функтора описываются в замыкании:

* `[=]` - все используемые в теле выражения переменнные из текущего scope копируются внутрь функтора.
* `[&]` - все используемые в теле выражения переменнные хранятся в функторе по ссылке.
* `[this]` - текущий `this` захватывается по ссылке
* `[\*this]` - текущий `this` захватывается по значению
* `[name = expression]` - создаём у функтора новое поле name, присваиваем туда `expression` (тип поля выведется сам)
* `[&name = expression]` - создаём у функтора новое поле=ссылку name на `expression` (тип поля выведется сам)
* `[name]` - копируем в функтор переменную `name`
* `[&name]` - храним в функторе ссылку на переменную `name`

Эти замыкания можно комбинировать всеми способами, более конкретные перекрывают менее конкретные.

Про `[&name = expression]` нужно отметить, что никак пометить в замыкании, что ссылку нужно брать именно константную не выйдет,
поэтому нужно сделатьт так, стобы тип `expression` сожержал категорию константности. Стандартый способ сделать это
`[&name = std::as_const(expression)]` ну или `[&name = static_cast<Type const&>(expression)]`.

По умолчанию `operator()` у получившегося функтора помечен, как `const`. Избежать этого можно, добавив слово `mutable` перед телом лямбды.

Примеры

```C++
int main() {
    int a = 0, b = 1, c = 2;
    auto first = [=, &a]() mutable {
	     std::cout << a << " " << b++ << " " << c << std::endl;
	};
    decltype(first) second = first;
    first();                             // 0 1 2            
    first();                             // 0 2 2
    second();                            // 0 1 2
    a = b = c = 100;
    first();                             // 100 3 2
    second();                            // 100 2 2
}
```


```C++
int main() {
    auto lambda = [val = 0](int) mutable { std::cout << val++ << '\n'; };
    std::vector<int> v(100, 0);
    std::for_each(v.begin(), v.end(), lambda); // numbers from 0 to 99
}
```

[раскрывается так](https://cppinsights.io/lnk?code=I2luY2x1ZGUgPGlvc3RyZWFtPgojaW5jbHVkZSA8dmVjdG9yPgojaW5jbHVkZSA8ZnVuY3Rpb25hbD4KCmludCBtYWluKCkgewogICAgYXV0byBsYW1iZGEgPSBbdmFsID0gMF0oaW50KSBtdXRhYmxlIHsgc3RkOjpjb3V0IDw8IHZhbCsrIDw8ICdcbic7IH07CiAgICBzdGQ6OnZlY3RvcjxpbnQ+IHYoMTAwLCAwKTsKICAgIHN0ZDo6Zm9yX2VhY2godi5iZWdpbigpLCB2LmVuZCgpLCBsYW1iZGEpOyAvLyBudW1iZXJzIGZyb20gMCB0byA5OQp9Cg==&insightsOptions=cpp17&std=cpp17&rev=1.0)

Поля структуры нельзя захватить по отдельно от всего объекта - приходится захватывать `[this]` или `[*this]`.

```c++

struct Foo {
  int a;
  auto copy_capture() {
  	return [*this](){
      std::cout << a << std::endl;
    };
  }
};

int main()
{
  auto lambda1 = Foo{1}.copy_capture();
  lambda1(); // no dangling reference
}

```

[раскрывается так](https://cppinsights.io/lnk?code=I2luY2x1ZGUgPGlvc3RyZWFtPgoKc3RydWN0IEZvbyB7CiAgaW50IGE7CiAgYXV0byBjb3B5X2NhcHR1cmUoKSB7CiAgCXJldHVybiBbKnRoaXNdKCl7CiAgICAgIHN0ZDo6Y291dCA8PCBhIDw8IHN0ZDo6ZW5kbDsKICAgIH07CiAgfQp9OwoKaW50IG1haW4oKQp7CiAgYXV0byBsYW1iZGExID0gRm9vezF9LmNvcHlfY2FwdHVyZSgpOwogIGxhbWJkYTEoKTsgLy8gbm8gZGFuZ2xpbmcgcmVmZXJlbmNlCn0=&insightsOptions=cpp17&std=cpp17&rev=1.0)


Довольго популярна идиома передачи в лямбды `[field = std::move(value)]` - 	это, например, единственный способ передать
в лямбду `std::unique_ptr`. Растаманского `move` тут нет, поэтому каждое такое поле придётся перемещать руками.

</details>

<details>
<summary>
 Билет 30. Препроцессор
</summary>


**`Note`**:

У `g++` можно запустить только препроцессор, для этого используйте ключ `-E`: `g++ -E main.cpp >main`.

Здесь перечислены имена переменных, которые нельзя использовать: [StackOverFlow answer](https://stackoverflow.com/questions/228783/what-are-the-rules-about-using-an-underscore-in-a-c-identifier/228797#228797)



### 1. Как пользоваться `#ifdef DEBUG`, `#define` и ключом `-DDEBUG` (в случае `GCC/Clang`):

1. `#ifdef ANY_VAR` - здесь мы проверяем, если переменная препроцессора `ANY_VAR` объявлена, то сделать то, что идет за `#ifdef`:

	Здесь если `DEBUG` **объявлена**, то часть с `#else` будет вырезана из файла и компилятор ее даже не увидит (если `DEBUG` **не объявлена**, то наоборот - останется часть в `#else`):

	```cpp
	#ifdef DEBUG
		std::cout << "Debugging mode is on!";
	#else // optional else statement
		std::cout << "Debugginh mode is off!";
	#endif
	```

2. `#define SOME_VAR value` - здесь мы объявляем (объявляем именно для препроцессора, а не для языка `C++`) переменную `SOME_VAR` и говорим препроцессору заменить все вхождения слова `SOME_VAR` в коде на `value` - вырезать все `SOME_VAR` и вставить конкретно слово `value` (вместо `value` могло стоять все, что угодно).

3. `-DDEBUG` - данный ключ пишется в момент компиляции программы, с помощью него мы объявляем переменную `DEBUG` (то есть это эквивалентно тому, чтобы написать `#define DEBUG 1` в коде).




### 2. Базовый синтаксис для `#if` и `defined()`:

1. `#if` - используется для более сложных условий проверки.

2. `defined(ANY_PREPROCESSOR_VAR)` - проверяет, объявлена ли препроцессорная переменная с именем `ANY_PREPROCESSOR_VAR`.

3. Пример использования:

	```cpp
	#if defined(SOME_VAR) && 10 * 3 <= 50
		std::cout << "SOME_VAR defined and 30 is less than 50!";
	#endif	
	```

4. Есть еще `#elif` - нужен, чтобы писать много разных условий:

	```cpp
	#if defined(FIRST)
		std::cout << "first defined";
	#elif defined(SECOND)
		std::cout << "second defined";
	#else
		std::cout << "maybe third?..."
	```




### 3. Определение компилятора и компилятороспецифичные `#pragma` (например, игнорирование предупреждений в `GCC`):

1. Переменная `__cpluplus` - содержит в себе информацию о версии языка (возможные значения `201700L`, `201400L`), с которой скомпилирован файл.

2. Определяем версию компилятора:

```cpp
#include <iostream>

int main() {
	std::cout << "C++ " << __cplusplus << "\n";

	std::cout << "Detecting compiler...\n";
#if defined(__GNUC__) && !defined(__clang__)
	std::cout << "GNU C " << __GNUC__ << "." << __GNUC_MINOR__ << "." << __GNUC_PATCHLEVEL__ << "\n";
#endif
#ifdef __clang__
	std::cout << "LLVM clang " << __clang_version__ << "\n";
#endif
#ifdef _MSC_VER
	std::cout << "Microsoft Visual C++ " << _MSC_VER << "\n";
#endif

	std::cout << "Detecting standard library...\n";
#ifdef __GLIBCXX__
	std::cout << "GNU libstdc++: " << __GLIBCXX__ << "\n";
#endif
#ifdef _LIBCPP_VERSION
	std::cout << "LLVM libc++: " << _LIBCPP_VERSION << "\n";
#endif
#ifdef _MSVC_STL_VERSION
	std::cout << "Microsoft STL: " << _MSVC_STL_VERSION << " at " << _MSVC_STL_UPDATE << "\n";
#endif
}
```

3. `#pragma` - команда компилятору о том, что надо что-то сделать (не имеет отношения к препроцессору). Это все специфично для каждого компилятора, поэтому компиляторы не понимают `#pragma` друг друга.

Игнорирование предупреждений в `GCC`:
```cpp
#pragma GCC diagnostic ignored "-Wunused-variable" // команда для GCC о том, чтобы он игнорировал неиспользуемые переменные
```

```cpp
int main() {
	#ifdef __GNUC__  // Everything is compiler-specific
		#pragma GCC diagnostic push // кладем все предупреждения на специальный стек
		#pragma GCC diagnostic ignored "-Wunused-variable" // говорим игнорировать предупреждения 'unused-variable'
	#endif
		int x = 10;
	#ifdef __GNUC__
		#pragma GCC diagnostic pop // восстанавливаем старые предупреждения
	#endif
}
```




### 4. Проблемы с аргументами макросов: приоритет операторов, повторное вычисление.

1. **Приоритет операторов**: так как препроцессор **только заменяет** все вхождения объявленной переменной на указанное значение, то важно самому следить за приоритетом операций:

	```cpp
	#define A 2 + 2
	std::cout << A * 4; // equals to 2 + 2 * 4 = 10, not (2 + 2) * 4 = 16 
	```

	```cpp
	#define max(a, b) a < b ? a : b
	std::cout << max(1, 2); // compilation error, because treating like '(cout << 1) < (2 ? 1 : 2)' - comparing 'iostream' and 'int' 
	```

	```cpp
	#define mul(a, b) (a * b)
	std::cout << mul(2 + 1, 3); // prints 2 + 1 * 3 = 5, not (2 + 1) * 3 = 9
	```

2. **Повторное вычисление**:
	
	```cpp
	#define max(a, b) ((a) < (b) ? (a) : (b))
	
	int x = 10;
	
	max(x++, 10) // UB: incrementing x twice in one statement (because (a) -> (x++) and we do it twice)

	max(foo(), 10) // calling foo() twice: (a) -> (foo())
	```



### 5. Проблемы с макросами из нескольких `statement` и трюк с `do { } while(0)`

Примеры проблем:

```cpp
// #1
#define print_twice(x) cout << x; cout << x;

// problems with:
int x = 10;
if(x == 10)
	print_twice(x); // only one print
```

```cpp
// #2
#define print_twice(x) { cout << x; cout << x; }

// problems with:
int x = 10;
if(x == 10)
	print_twice(x); // only one print
else
	print_twice(0);

// compilation error, expands to:
/*
if(x == 10)
	{ cout << x; cout << x; }; <- this ';' causes error
else
	{ cout << 0; cout << 0; };
*/
```

Трюк с `do {} while(0)`: мы вынуждены писать так, чтоюбы примеры выше работали:

```cpp
#define print_twice(x) do { cout << x; cout << x; } while(0) // no ';' at the end!

// BUT! following code causes error, because 'do{} while()' is not expression, it is statement (no solution for the problem):

print_twice(10), print_twice(10); // ERROR: while is not expression
```





### 6. Проблемы с `operator`, и вызовом макросов: как добиться, чтобы `assert(true)`, `assert(false)` работало:

Проблема в том, что если сделать `assert` через `if` или любое другое выражение (`statement`), то мы не сможем писать код по типу:
```cpp
assert(12 == 6*2), assert(1 == 1); // ERROR! statements cannot be used with operator,()
```

Код выдает ошибку, так как `statements` нельзя использовать с операторами. Чтобы избавиться от ошибки, необходимо писать `assert` через какой-нибудь `expression`: **функция**, **тернарный оператор**:

```cpp
// #1 with function implementation
bool evaluate(bool expr) {
	return expr;
}
#define assert(expr) evaluate((expr))


// #2 with ternary operator
#define assert(expr) ((exprt) ? true : false)
```





### 7. Вариадический макрос: `__VA_ARGS__` и `...`, проблемы с последней запятой:

1. На примере:

```cpp
#define foo(a, b, ...) bar(b, a, __VA_ARGS__)

int main() {
	foo(1, 2, 3, 4); // expands to: bar(2, 1, 3, 4)
	foo(1, 2, 3); // expands to: bar(2, 1, 3)
}
```

2. Проблема с последней запятой:

```cpp
#define foo(a, b, ...) bar(b, a, __VA_ARGS__)

int main() {
	foo(1, 2); // expands to: bar(2, 1, ) -> ERROR
}
```

3. Решение проблемы с запятой появилось только в `C++20`:
```cpp
// solution appeared only in C++20: __VA_OPT__()
// rewrite foo:
#define foo(a, b, ...) bar(b, a __VA_OPT__(,) __VA_ARGS__)
```






### 8. Проблемы с `assert(v == std::vector{1, 2, 3})`, `foo({1, 2})`, `foo(map<int, int>{})` и как их решать:

**Как их решать**: решение у всех почти одно, сначала используем `__VA_OPT__(,)`, а далее при вызове `foo()` оборачиваем аргументы в круглы скобки вот так `foo( (map<int, int>) )`, тогда разрезаний по `,` в типе `map<int, int>` не будет.

1. `assert(v == std::vector{1, 2, 3})`:

	**Проблема:**

	```cpp
	vector<int> v = {1, 2, 3};
	assert(v == vector{1, 2, 3}); // compilation error, cannot parse vector correctly
	```

	**Решение:**

	```cpp
	vector<int> v = {1, 2, 3};
	assert(v == (vector{1, 2, 3}) ); // works fine, due to embracing vector in brackets
	```

2. `foo({1, 2})`:

	**Проблема:**
	```cpp
	#define foo(a, b, ...) bar(b, a, __VA_ARGS__)

	int main() {
		foo({1, 2}); // expands to: bar(2}, {1, )

		foo({1, 2, 3, 4}); // expands to: bar(2, ({1, 3, 4})) - treating '{' as part of parameter			
	}
	```

	**Решение:**
	```cpp
	// using __VA_OPT__()
	#define foo(a, b, ...) bar(b, a __VA_OPT__(,) __VA_ARGS__)

	int main() {
		foo( ({ 1, 2 }), 1 ); // expands to: bar(1, ({1, 2}) )
	}
	```

3. `foo(map<int, int>{})`:

	**Проблема:**
	```cpp
	#define foo(a, b, ...) bar(b, a, __VA_ARGS__)

	int main() {
		foo(map<int, int>{}); // expands to: bar(int>{}, map<int, )
	}
	```

	**Решение:**
	```cpp
	#define foo(a, b, ...) bar(b, a __VA__OPT__(,) __VA_ARGS__)		

	int main() {
		foo(1, (map<int, int>{}) ); // expands to: bar( (map<int, int>{}), 1 )
	}
	```






### 9. Как использовать `#macro_arg`, `__FILE__`, `__LINE__` для создания своего макроса `CHECK` в тестовом фреймворке:

1. `#macro_arg` - здесь `#` преобразует переданный параметр макроса `marco_arg` в строку, то есть сделает нам `"marco_arg"`:

```cpp
#define print(x) (cout << #x)

print(output some text); // expands to: (cout << "output some text"); 
``` 

2. `__FILE__` - название текущего файла.

3. `__LINE__` - текущая строка в файле.

4. Как использовать в своем фреймворке для `CHECK`:
```cpp
// printOnError function:

void printOnError(bool hasError, string expr, string filename, int line) {
	if(hasError) {
		cout << expr << "has failed in file: " << filename << ", on line: " << line << endl;
	}
}
```
```cpp
#define CHECK(expr) \
	printOnError((!(expr)), #expr, __FILE__, __LINE__)
```







### 10. Базовое использование `##` в макросах:

`##` - склеивает 2 переменные/параметра вместе, например:
```cpp
#define glue(a, b) a ## b // whitespaces between 'a' and 'b' omitted

int xy = 12;
cout << glue(x, y); // expands to: cout << xy; which prints '12' in console
```

1. Было: генерация случайных имён переменных/функций при помощи `__LINE__` (`exercises/05-211004/10-new-var`):

```cpp
#define CONCAT_IMPL(x, y) x##_##y
#define CONCAT(x, y) CONCAT_IMPL(x, y)

// suppose executing on 10th line:
void CONCAT(func, __LINE__)(); // expands to: 'void func_10();'
```







### 11. Возможность писать в макросах лишь куски корректного кода:

1. Если мы пишем `#if ... #elif ... #else`, то лишь 1 часть из этих `if`-ов выполнится, а остальные будут вырезаны из программы препроцессором до этапа компиляции, поэтому если в каком-нибудь из `if`-ов был написан некорректный код на языке `C++`, но данный `if` не выполнился, то ошибки при компиляции не будет, так как данной части кода просто не будет в файле после работы препроцессора.

2. В лабе `TEST_CASE` выводит нам примерно следующий код `void test()`, а далее ожидается, что вызвавший макрос `TEST_CASE` напишет фигурные скобки и определит в них тело функции-теста, то есть получается, что сам макрос выдает некорректный код: мы обязаны дописывать тело функции, чтобы все компилировалось.



#### Общая идея создания фреймворка для автотестов с авторегистрацией тестов: `TEST_CASE("hi") { CHECK(1 == 2); }`:

1. Мы создаем функцию со статической переменной-вектором, которая будет хранить в себе ссылки на функции (функции - это сами тесты). Эта функция будет по ссылке возвращать нам данный массив, чтобы мы могли класть в него ссылки на тесты (мы делаем это как функцию, так как порядок инициализации переменных между единицами трансляции не задан, поэтому просто статический массив мог не успеть определиться до создания первого теста).

2. `TEST_CASE` делается следующим образом:

```cpp
#define TEST_CASE(name) \
static void CONCAT(func, __LINE__)(); \
const FunctionSaver CONCAT(saver, __LINE__)(name, CONCAT(mytest_func, __LINE__)); \
void CONCAT(mytest_func, __LINE__)()

// suppose calling on line 10
// expands to: 

static void func_10();
const FunctionSaver saver_10(name, func_10);
void func_10()


// use of TEST_CASE
TEST_CASE("test") { // on line 10
	...
}

// expands to 
static void func_10();
const FunctionSaver saver_10(name, func_10);
void func_10() {
	...
}
```

3. Здесь `saver_10` получает в конструктор ссылку на функцию `func_10()`, далее сохраняет ее в глобальный статический массив тестов. Важно, чтобы `saver_10` и `func_10()` были видны только в текущей единице трансляции, это достигается за счет `const` для переменных (здесь это `saver_10`) и `static` для функций (здесь `func_10()`).

4. После того, как все тесты собраны в массив, мы в каком-нибудь `main()` проходимся по всем этим тестам и вызываем каждый из них.
</details>

<details>
<summary>
 Билет 31. Программы из нескольких файлов
</summary>


**Важно знать**: порядок инициализации переменных между единицами трансляции неопределен!

### Что делает #include, в том числе #include <iostream> и `#include <iosfwd>`:

1) `#include "header.h"/<lib>` - просто вставляет код из `header.h/lib` в текущую единицу трансляции
2) `#include <iostream>` - включает стандартную библиотеку ввода/вывода в текущую единицу трансляции (`<>` - используются для встроенных библиотек, `""` - для собственных header-файлов)
3) `#include <iosfwd>` - этот заголовок содержит forward declaration для стандартной библиотеки ввода/вывода.



### Мотивация:
1. Зачем линковка, когда есть `#include`, отличия:

	**При линковке** мы можем сначала скомпилировать все файлы отдельно друг от друга, получив объектные файлы, а затем слинковать их как захотим. Например, есть файл `main.cpp`, он вызывает `print()` функцию. Мы можем создать 2 файла `print1.cpp` и `print2.cpp`, сделать независимо компиляцию каждого (`g++ -c main.cpp print1.cpp print2.cpp`), а далее слинковать полученные `main.o` и `print1/2.o` попарно (`g++ main.o print1.o -o a.exe`, `g++ main.o print2.o -o b.exe`), так получаем 2 `exe`-файлика, которые используют разные функции.

	Также важно помнить, что функция может иметь ровно определение (по правилу `ODR - One Definition Rule`) в какой-либо единице трансляции (definition: тело функции `void foo() {...}`), но сколько угодно много объявлений (declaration: `void foo();`). Структуры могут иметь определения для своих методов в разных единицах трансляций, но эти определения должны полностью совпадать (в таких случаях делают header-файл c объявлением структуры и ее полей/методов, а в отдельной одной единице трансляции пишут определения для методов).

	`#include<something>` - просто скопирует содержимое файла `something` и вставит в файл с include'ом, при этом размер текущего файла увеличится.


### Единицы трансляции и файлы:
`.cpp`-файл - это `translation unit` (единица трансляции), код разбивается на несколько файлов, чтобы было удобнее его читать + компилировать каждый файл отдельно (`g++ -c main.cpp` - создаст объектный (бинарный) файл `main.o`).


**UB:** 
	
1. Разные параметры по умолчанию в объявлении и определении функций
	
2. Разные типы данных в объявлении и определении, возвращаемые функцией


### Как из одного файла заиспользовать глобальный класс/функцию из другого:

1. **Функции**: в 1 единице трансляции мы определяем функцию (function definition: `void foo(int x) {[body of the function foo]}`), во всех других только пишем объявление этой функции (function declaration: `void foo(int x);`)

2.1. **Классы/структуры**: если не использовать `header`-файлы, то это боль, нужно в каждой единице трансляции *заново прописывать **определения членов** структуры* и **объявления ИЛИ определения методов (при этом определения в разных единицах трансляции должны совпадать - copy-paste)**; тут легко напороться на `UB`, поменяв местами определения членов структуры (UB так как удаляет объект текущая единица трансляции, поэтому если поля имеют другое расположение, то порядок удаления полей не соответствует их расположению в памяти). Вот [пример кода с лекции](https://github.com/hse-spb-2021-cpp/lectures/tree/master/06-211006/08-struct-ub).

2.2. **Классы/структуры**: с использованием header-файлов все просто: мы 1 раз *объявляем* все поля/методы структуры в каком-нибудь `my_struct.h` файле, далее в 1 единице трансляции (`my_struct.cpp`) пишем определения для методов. Если в каком-либо файле нам понадобиться эта структура, то мы просто включаем ее в нужный файл `#include "my_struct.h"` (при этом не забываем про `guards` в header-файлах).
	


### External linkage/internal linkage:

`Internal linkage` - данный тип линковки обозначает, что сущность (переменная, функция, структура) будет видна только в данной единице трансляции (в текущем `.cpp`-файле).

`External linkage` - данный тип линковки обозначает, что сущность будет видна всем единицам трансляции, которые мы решили скомпилировать вместе. Другими словами, доступна через всю программу, которая представляет собой комбинацию всех единиц трансляции.


1. **Слово `static` и `unnamed namespace`, где применять:**

1) `static`: если мы хотим, чтобы *глобальная функция* была видна только в текущей единице трансляции, то мы может перед ее типом написать слово `static`, и данная функция не будет видна другим единицам трансляции (также `static` делаем сущность *статической*, то есть она инициализируется в программе 1 раз и не умирает до завершения самой программы). Примеры:

```cpp
// foo.cpp

static int foo() {
	return 100;
}

int bar() {
	return 100;
}
```

```cpp
// main.cpp

foo();
bar();

int main() {
	foo(); // ERROR: undefined reference
	bar(); // works fine
}
```

2) `unnamed namespace`: нужен, чтобы переменная/функция/сущность была долступна только текущей единице трансляции. Пример:

```cpp
// foo.cpp
namespace {
	int foo() {
		return 10;
	}
}

int calc() {
	int x = foo();
	return x * x;
}
```

```cpp
// main.cpp

int foo();
int calc();

int main() {
	foo(); // ERROR
	calc(); // works fine
}
```





### Формулировка `One Definition Rule`, формулировка `IFNDR` (**Ill-Formed, No Diagnostic Required**):
	
1. **Формулировка `One Definition Rule`:** у любой сущности (функции/глобальной переменной) должно быть ровно 1 определение на всю программу (программа - все translation units, что есть в проекте)

2. **Формулировка `IFNDR`:** есть сущность имеет не 1 определение, то возникнет UB сразу после запуска программы (даже до выполнения main()), компилятор не обязан сообщать о некорректности программы

	
1) Пример ошибок линковщика: `multiple definition`, `undefined reference`:
```cpp
// multiple definition example: - имеем несколько определений для сущности

// foo.cpp
void foo() {...}
```

```cpp

// main.cpp
void foo() {...}

int main() {
}

// compile both and you will get an error: 

// g++ main.cpp foo.cpp;
// ./a.exe -> ERROR: multiple definition of 'foo()'
```

```cpp
// undefined reference example: - не имеем ни одно определения для сущности, однако пользуемся ею

// foo.cpp - leave empty
```

```cpp
// main.cpp

void foo();

int main() {
	foo();
}
// complie both and error will occur: 

// g++ main.cpp foo.cpp;
// ./a.exe -> ERROR: undefined reference to 'foo()'
```

2) Что происходит с перегрузками функций: перегрузки разрешаются на уровне компилятора, а не линковщика, поэтому **иметь одну функцию с разными перегрузками нормально**:

```cpp

// foo.cpp
void foo(int x) {...}
```

```cpp
// main.cpp
void foo(int x);
void foo() {...}

int main() {
	foo(10);
	foo();
}
// works fine, no ODR violation
``` 



### Типичный заголовочный файл:

1. Конвенция именования заголовочных файлов: 

	Правильное название для `guard'a` в `header`-файле будет `[filename uppercased]_H_` (здесь `[filename uppercased]` - название текущего файла, в котором пишется `guard`, заглавными буквами).

2. `Include guards`: зачем, как правильно, осторожно с `_`:
		
	Если начать название `guard'а` с `_A`, `__A` (`A` - любая заглавная буква), то это `UB` (такие названия запрещены к использованию).


**`Note:`** 

Если не делать `include-guards`, то возможна ситуация: мы имеем структуру `Foo` в `"header1.h"` файле, далее мы написали `#include "header1.h"` в каком-нибудь `"header2.h"` файле, а затем в `main.cpp` сделали `#include "header1.h"` и `#include "header2.h"`, так мы получили ошибку `"multiple definition of struct Foo"`, чтобы такого не произошло делают следующее:

```cpp
#ifndef HEADER1_H_
#define HEADER1_H_

struct Foo {...};

#endif // HEADER1_H_

// Так при первом включении header1.h в main.cpp мы объявим HEADER1_H_ и при втором include в header2.h второго подключения не случится

```


3. Опасность неявного включения, концепция include what you use, примеры из стандартной библиотеки вашего компилятора (`exercises/01-210906/07-missing-include`):

	Опасность неявного включения: на различных компиляторах код может либо компилироваться, либо нет. (смотри [exercises/01-210906/07-missing-include](https://github.com/hse-spb-2021-cpp/exercises/blob/master/01-210906/07-missing-include.cpp)).

	Важно сделать так, чтобы порядок `#include`-ов в единице трансляции не имел значения и все .h-файлы были независмые, поэтому если в каком-то .h-файлы мы используем что-то из другого .h-файла, то мы обязаны в текущий заголовочный файл включить все header-файлы, что необходимы (принцип `include what you see`); [пример с лекции](https://github.com/hse-spb-2021-cpp/lectures/tree/master/06-211006/10-include).


4. Запрет на реализацию функций:

	Мы пишем только объявления функций в `header`-файлах (так принято делать, чтобы избежать `ODR`). Также можно использовать `inline`, но **не нужно**, так как считается **плохой практикой** 
		
	Смысл `inline`: функция может иметь несколько определений, но я, как программист, обещаю, что все эти определения равны, поэтому выбери любое.


5. Необходимость подключать заголовочный файл в файл с реализацией:

	В файл реализации мы должны подключить наш `.h`-файл, чтобы обезопасить себя от возможных `UB`, пример:

```cpp
// get.h

#ifndef GET_H_
#define GET_H_

float get(int x);

#endif
```

```cpp
// get.cpp

double get(int x) {
	...
}
```

```cpp
// main.cpp

#include "get.h"

int main() {
	get(10.0);
}

// g++ main.cpp get.cpp -o a.exe
// ./a.exe - UB!
```

Если в пример выше включить `get.h` файл в `get.cpp`, то компилятор выдаст ошибку компиляции, т.е. убережет от трудного `debugging'а`.





### Взаимная рекурсия между заголовками и `forward header`:
	
**Взаимная рекурсия:**

Проблема:

```cpp
// bar.h 

#ifndef BAR_H_
#define BAR_H_

#include "foo.h"

struct Bar {
    Foo *f;
};

void bar_do_something(Foo, Bar);

#endif  // BAR_H_

```

```cpp
// foo.h

#ifndef FOO_H_
#define FOO_H_

#include "bar.h"

struct Foo {
    Bar b{this};
};

#endif  // FOO_H_

// Здесь Bar не видит Foo, так как стоят guards, если убрать guards, то мы зациклим подключения
```

Решение:

```cpp
// Чтобы решить проблему, мы создаем foo_fwd.h файл, в котором не будет ничего кроме объявления структуры Foo: struct Foo;

// foo_fwd.h

#ifndef FOO_FWD_H_
#define FOO_FWD_H_

struct Foo;

#endif  // FOO_FWD_H_
```

#### Идея `forward header`:
Данные заголовочные файлы включают в себя только forward-declaration (то есть объявления) структур.

Если есть `foo_fwd.h` и `foo.h`, то в `foo.h` также нужно подключить `foo_fwd.h`, чтобы проверить, что у нас объявление и определения не отличаются типом данных, параметрами и тд.



1. Incomplete type: как объявить, что можно сделать с неполным типом: 

	1) Синтаксис: `struct Foo;`

	2) Неполного типа достаточно, что передавать указатели и ссылки на структуру, т.е. мы не выделяем память для новой структуры данного типа. Но ничего кроме как передать по ссылке/значению мы не умеем: не можем вызывать методы, обжащаться к полям, создавать instance данной структуры, так как мы не знаем сколько структура должна занимать памяти, а также не знаем какие поля и методы у нее определены, [код с лекции](https://github.com/hse-spb-2021-cpp/lectures/tree/master/06-211006/09-incomplete).

	3) Зачем надо: это укоряет компиляцию, так как нам не нужно парсить определение структуры.

	
2. Пример forward hearder из стандартной библиотеки (`<iosfwd>`):

	1. Если мы хотим для свой структуры реализовать оператор вывода, то нам необязательно в .h-файл подключать большую <iostream> библиотеку, мы можем просто объявить, что объект ios существует и все:

```cpp
// foo.h

#ifndef FOO_H_
#define FOO_H_

#include <iosfwd>

struct Foo {};

std::ostream& operator<<(std::ostream&, const Foo&);

#endif  // FOO_H_
```

```cpp
// foo.cpp
#include "foo.h"
#include <iostream>

std::ostream& operator<<(std::ostream& os, const Foo&) {
	return os << "hello world";
}
```




### Что обычно (не) пишут в своих заголовочных файлах (в том числе forward), `using namespace std`:

1. В заголовках **не пишут** определения функций, их выносят в соответствующие .cpp-файлы.

2. В заголовках **пишут** объявления сущностей, guards

3. В forward-заголовках пишут forward-declaration для структур (`struct Foo;`)

4. `using namespace std` - так не пишем, так как в случае, если есть какая-либо функция c совпадающим названием как в `std` в другой библиотеке, мы не сможем ее вызвать. 







## Other notes from `06-211006(I) — программы из нескольких файлов, СПб ВШЭ ПМИ, C++`:

### `namespaces`: 

1. `::` - global namespace.

2. `ns1::ns2` - nested namespace.

3. Поиск среди namespace'ов вверх по вложенности.

4. `(Un)qualified name lookup`:

```cpp
namespace ns1 {
	void foo() {...}
}

namespace ns1::ns2 {
	void bar() {
		foo(); // Unqualified name lookup for 'foo' - пытаемся найти foo() в текущем namespace'e потом на 1 уровень выше, потом на 2 выше и тд
		
		ns1::foo(); // Qualified name lookup for 'foo', Unqualified name lookup for 'ns1'
	}
}
```

5. `Argument dependent lookup`:

```cpp
namespace ns {
	struct Foo;

	void foo(Foo) {...}

	void foo() {...}
}

// compiles fine
int main() {
	ns::Foo f;
	foo(f); // найдет нужный 'foo' в 'ns', так как компилятор пытается посмотреть во все namespace'ы и найти там функцию foo с такими аргументами
	
	// это нужно, чтобы уметь писать операторы: f == f, ns::operator==(f, f) 
}

// does not compile
int main() {
	foo();
}

```

</details>

<details>
<summary>
 Билет 32. One Definition Rule и нарушения IFNDR
</summary>


## ODR

ODR (One Definition Rule) - во всей программе (то есть включая все файлы) у любой сущности должно быть ровно одно определение. 
Определение с cppreference: Only one definition of any variable, function, class type, enumeration type, concept (since C++20) or template is allowed in any one translation unit (some of these may have multiple declarations, but only one definition is allowed).

### Что с перегрузкой функций
#### Напоминание про перегрузку функций: 
Есть несколько функций с одинаковым именем, но с разными типами аргументов. Тогда компилятор может выбрать наиболее подходящую перегрузку.
#### Что происходит внутри:
API (Application Programming Interface) - показывает, какой программный интерфейс у различных translation unit'ов. (Какие типы у аргументов функции, какие типы возвращаются, в каком namespace лежит и тд). Всё API запоминает компилятор и им можно пользоваться. (Подробнее - [лекция Егора](https://youtu.be/X-6unqJz_uY?list=PL8a-dtqmQc8obAqSKqGkau8qiafPRCxV7&t=1683))
```C++
void foo();
foo();
```
При компиляции все превращается в ABI (Application Binary Interface) - тоже самое, но более низкоуровневое. У компилятора есть регламенты, как и через что возвращается (через какие регистры процессора, через какие места памяти и тд). Например, поэтому нельзя компилировать разные части программы разными компиляторами, в итоге какие-то регламенты могут не совпасть.  
Затем происходит name mangling:
```C++
void foo(); -->  \_Z3foov // v - тип аргумента. 
```
Все это к тому, что перегруженные функции различаются компилятором и нарушения ODR не возникает. Пример:  
foo.cpp:
```C++
void foo(int) {
}
```
main.cpp:
```C++
void foo(int);
void foo() {
}

int main() {
    foo();
    foo(10);
}
```
### Пример ошибок линковщика
#### Multiple definition 
Функция имеет более одного определения.  
foo.cpp:
```C++
void foo() {
}
```
main.cpp:
```C++
void foo() {
}

int main() {
}
```
#### Undefined reference
Функция не имеет опрделения, но при этом где-то используется.
```C++
void foo();

int main() {
    foo();
}
```
### Примеры IFNDR
IFNDR (Ill-Formed, No Diagnostic Required) - "программа некорректна, сообщать не требуется" - УБ в момент запуска, при этом компилятор об этом не сообщает. Ниже несколько примеров таких УБ (при этом все компилируется).
#### Несовпадение объявлений функций
Везде будет УБ, при этом компилятор не будет предупреждать нас об этом.
С аргументами:

С аргументами по умолчанию:  
foo.cpp:
```C++
void foo(int x = 10) {
    std::cout << x << "\n";
}
```
main.cpp:
```C++
void foo(int = 1000);

int main() {
    foo();
}
```
Возвращаемое значение:  
foo.cpp:
```C++
float foo() {
    return 1000000;
}
```
main.cpp:
```C++
#include <iostream>

double foo();

int main() {
    std::cout << foo();
}
```
#### Несовподение определений классов
Если структура определена в одной трансляции и используется в другой, то там, где она используется, нужно еще раз написать структуру, а также перечислить все ее поля и объявить все методы, поля должны быть в том же порядке (иногда стреляет, когда обьект удаляется, и деструкторы вызываются не в том порядке).
Если метод определен вне структуры:  
foo.cpp:
```C++
#include <vector>
#include <iostream>

struct Foo {
    int a = 10;
    std::vector<int> v;

    void method();
};

Foo get_foo() {
    return Foo{};
}

void Foo::method() {
    std::cout << "method() called " << a << "\n";
}
```
main.cpp:
```C++
#include <vector>
#include <iostream>

struct Foo {
    int a = 10;  // Should be exactly 10, IFNDR otherwise.
    std::vector<int> v;

    void method();
};

Foo get_foo();

int main() {
    get_foo().method();

    Foo f = get_foo();
    f.method();

    Foo f2;
    f2.method();
}
```
Метод может быть определен и в структуре. В этом случае везде нужно написать одно и тоже определение этого метода. При этом это не будет нарушением ODR (смотри inline в методах классов).  
foo.cpp:
```C++
#include <vector>
#include <iostream>

struct Foo {
    int a = 10;
    std::vector<int> v;

    void method() {
        std::cout << "method() called " << a << "\n";
    }
};

Foo get_foo() {
    return Foo{};
}
```
main.cpp:
```C++
#include <vector>
#include <iostream>

struct Foo {
    int a = 10;  // Should be exactly 10, IFNDR otherwise.
    std::vector<int> v;

    void method() {
        std::cout << "method() called " << a << "\n";
    }
};

Foo get_foo();

int main() {
    get_foo().method();

    Foo f = get_foo();
    f.method();

    Foo f2;
    f2.method();
}
```
#### Потенциальные проблемы с любыми глобальными переменными
Ниже программа с глобальной переменной write. Если ее запустить как обычно, то она успешно скомпилируется и сработает, но при этом в некоторых ситуациях может стрельнуть УБ (смотри ниже).
```C++
#include <iostream>

int write;

int main() {
    std::ios_base::sync_with_stdio(false);
    std::cout << 10;
}
```
Но если скомпилировать эту программу с ключом `-static` ("что значит возьми стандартную библиотеку и встрой ее внутрь exeшника"), то будет стрельнет UB (во всяком случае у Егора выдало ошибку), так как в программе ODR-violation. В стандартной библиотеке есть глобальная функция с название write. Получилось, что в программе появилось два объекта с одинаковыми названиями. В данном случае процессор пытается вызвать переменную write как функцию. Мораль: используйте namespace!
### Использование inline-переменных/функций/методов для обхода ODR
Замечание: все методы, определенные внутри классов по умолчанию inline, но если метод определен вне класса, то inline не является (нужно указывать ручками). При этом это не распространяется на поля классов. Про переменные: раньше если глобальная переменная объявлялась внутри класса, то ее надо было определить ровно в одной единицы трансляции. Теперь можно прописать inline, работает на тех же условиях, что и inline функция (то есть везде должна быть определена одинаково).
```C++
struct Foo {
    static inline int x = 10;
    
    /* inline */ void doSmthWithFoo() { // - inline подставляется автоматически
    }
}
```
Теперь как работает inline: раньше работало по типу макроса, возьми определение и вставь его вместо вызова. Сейчас компиляторы умнее, выбирают что сделать лучше, но точный смысл остался: функция может быть реализована в нескольких единицах трансляции, но одинаково. Вот пример кода с [лекции](https://github.com/hse-spb-2021-cpp/lectures/tree/master/08-211020/03-linkage/01-inline).
### Отличия inline от static/unnamed namespace
Static, примененный к сущностям работает как unnamed namespace. Таким образом данная сущность будет видна в данной единицы трансляции и не видна в других. Как пример: собственная библиотека с автотестами. Там могут найтись несколько функций с одинаковым названием в разных единицах трансляции. Используем static/unnamed namespace -- все хорошо.  
Ключевое отличие: если использовать static/unnamed namespace, то у сущности будет internal linkage (то есть сущность видна только в текущей единице трансляции). inline разрешает создавать определение в нескольких единицах трансляции, но при этом определения должны быть одинаковыми и все помечены inline.



















</details>

<details>
<summary>
 Билет 33. Static initialization order fiasco
</summary>

### О чём это
Рассмотрим программу, состоящую из нескольких единиц трансляции: `a.cpp` и `b.cpp`. Пусть в `a.cpp` и `b.cpp` создаются объекты с статическим временем жизни (см. [билет 15](https://github.com/khbminus/CppTickets/blob/master/tickets/ticket15.md#static-storage-duration)), например глобальные переменные. В таком случае порядок инициализации этих переменных зависит от порядка линковки этих единиц трансляции. Это может привести к проблемам.
<!-- TODO: make references to other tickets uniform --->
### Создание и уничтожение объектов со статическим временем жизни
В целом, объекты с static storage duration инициализируются при запуске программы (в каком-то порядке) и удаляются по завершению программы (в неочевидном порядке<sup>[1](https://www.youtube.com/watch?v=XdrSzs04HKU&list=PL8a-dtqmQc8obAqSKqGkau8qiafPRCxV7&t=4806s)</sup> <sup>[2](https://stackoverflow.com/questions/31443437/why-is-the-order-of-destruction-of-these-function-local-static-objects-not-the-i)</sup>, под разными компиляторами по-разному). Также стандарт C++ гарантирует, что все static storage duration объекты внутри одной единицы трансляции будут проинициализированы по порядку<sup>[3](https://en.cppreference.com/w/cpp/language/initialization#:~:text=initialization%20of%20these%20variables%20is%20always%20sequenced%20in%20exact%20order%20their%20definitions%20appear%20in%20the%20source%20code.)</sup>, но нет никаких гарантий про порядок между ними! 
#### У кого static storage duration
Есть деление на два типа<sup>[4](https://en.cppreference.com/w/cpp/language/storage_duration#:~:text=static%20or%20extern.-,See%20Non%2Dlocal%20variables%20and%20Static%20local%20variables%20for%20details%20on%20initialization%20of%20objects%20with%20this%20storage%20duration.,-thread%20storage%20duration)</sup>: *non-local* переменные (в сущности, глобальные или статические поля класса) и *static local* переменные (статические локальные).
##### Non-local
К примеру, обычные глобальные переменные.
```c++
int x = 1;

void foo() {
    x++;
}

int main() {
    std::cout << x << '\n';  // 1
    foo();
    std::cout << x << '\n';  // 2
    x += 2;
    std::cout << x << '\n';  // 4
}
```
Как правило, они инициализируются во время запуска программы. Однако в случае non-local переменных, если применимо *constant initialization*<sup>[5](https://en.cppreference.com/w/cpp/language/constant_initialization)</sup>, то компилятор может (но не обязан, хотя обычно так и есть) создать объект сразу на этапе компиляции! Таким образом, объект будет встроен в .exe файл, из-за чего он может раздуться.

Если же constant initialization не применимо, то сначала используется *Zero initialization*<sup>[6](https://en.cppreference.com/w/cpp/language/zero_initialization)</sup>:
```c++
struct A {
    int a,b,c;
};
 
double f[3]; // zero-initialized to three 0.0's
int* p; // zero-initialized to null pointer value (even if the value is not integral 0)
std::string s; // zero-initialized to indeterminate value
               // then default-initialized to "" by the std::string default constructor
int main(int argc, char*[])
{
    delete p; // safe to delete a null pointer
    static int n = argc; // zero-initialized to 0 then copy-initialized to argc
    std::cout << "n = " << n << '\n';
    A a = A(); // the effect is same as: A a{}; or A a = {};
    std::cout << "a = {" << a.a << ' ' << a.b << ' ' << a.c << "}\n";
}
```

После *Zero initialization* идёт *Dynamic initialization*<sup>[7](https://en.cppreference.com/w/cpp/language/initialization#Dynamic_initialization)</sup>, собственно присвоение значений.

Компилятор имеет право сделать *Early Dynamic initialization*<sup>[8](https://en.cppreference.com/w/cpp/language/initialization#Early_dynamic_initialization)</sup>, обычно на этапе компиляции, если он видит, что объект не меняет другие объекты и не зависит от других не *early dynamic initialized*.
```c++
inline double fd() { return 1.0; }
extern double d1;
double d2 = d1;   // unspecified:
                  // dynamically initialized to 0.0 if d1 is dynamically initialized, or
                  // dynamically initialized to 1.0 if d1 is statically initialized, or
                  // statically initialized to 0.0 (because that would be its value
                  // if both variables were dynamically initialized)
double d1 = fd(); // may be initialized statically or dynamically to 1.0
```
Тут вообще много всего интересного и запутанного. Если есть время, посмотрите [cppreference](https://en.cppreference.com/w/cpp/language/initialization).
##### Static local
Статические локальные переменные можно создавать внутри функций, тогда они будут доступны каждый раз, когда вызывается эта функция.
```c++
int foo(int addition) {
    static int x = 1;
    x += addition;
    return x;
}

int main() {
    std::cout << x << '\n';  // 1
    foo(1);
    std::cout << x << '\n';  // 2
    foo(2);
    std::cout << x << '\n';  // 4
}
```
Инициализируется такой объект единожды первый раз, когда он используется в функции.
### Пример static initialization order fiasco
Из-за того, что порядок инициализации зависит от порядка линковки, можно наткнуться на проблемы, если один объект при своей инициализации (обычно в конструкторе) использует другой объект, который сам ещё не создался.

Это и называется static initialization order fiasco (SIOF).
#### Пример с некорректным порядком
`a.h`
```c++
#ifndef HSE_CPP_EXAM_A_H
#define HSE_CPP_EXAM_A_H

#include <vector>

struct Counter {
    explicit Counter (int init_count) : count(init_count) {}

    int getID() {
        return count++;
    }
    int count;
};

extern Counter globalCounter;

#endif //HSE_CPP_EXAM_A_H 
```

`a.cpp`
```c++
#include <vector>
#include "a.h"

Counter globalCounter(100);
```
`main.cpp`
```c++
#include <iostream>
#include "a.h"

int someId = globalCounter.getID();

int main() {
    std::cout << someId << '\n';  // either 100 or uninitialized
}
```
Если скомпилировать файлы в порядке `g++ a.cpp main.cpp -o siof`, то всё будет хорошо. Если же `g++ main.cpp a.cpp -o siof`, то `someId` не сможет воспользоваться `globalCounter`.
#### Пример, где не существует корректного порядка
`a.h`
```c++
#ifndef HSE_CPP_EXAM_A_H
#define HSE_CPP_EXAM_A_H

#include <utility>
#include <vector>
#include <iostream>

struct Counter {
    explicit Counter (int init_count, std::string name) : count(init_count), name(std::move(name)) {}

    int getID() {
        return count++;
    }

    int count;
    std::string name;
};

extern Counter globalCounter;

#endif //HSE_CPP_EXAM_A_H
```
`a.cpp`
```c++
#include "a.h"
#include "b.h"

Counter globalCounter(100, globalNameGiver.getName());
```
`b.h`
```c++
#ifndef HSE_CPP_EXAM_B_H
#define HSE_CPP_EXAM_B_H

struct NameGiver {
    explicit NameGiver(int id) : id(id) {}

    std::string getName() {
        return "obj" + std::to_string(id);
    }

    int id;
};

extern NameGiver globalNameGiver;

#endif //HSE_CPP_EXAM_B_H
```
`b.cpp`
```c++
#include "a.h"
#include "b.h"

NameGiver globalNameGiver(globalCounter.getID());
```
`main.cpp`
```c++
#include <iostream>
#include "a.h"
#include "b.h"

static int someId = globalNameGiver.id;
static std::string someName = globalCounter.name;

int main() {
    std::cout << someId << '\n';  // ???
    std::cout << someName << '\n';  // ???
}
```
`globalCounter` нужен для создания `globalNameGiver`, а `globalNameGiver` нужен для создания `globalCounter`... Вопрос о курице и яйце без решения.
#### Пример, где возникает UB только через std::vector
Давайте в модуль положим вектор, значение которого инициализируем только в `a.cpp`.

`a.h`
```c++
#ifndef HSE_CPP_EXAM_A_H
#define HSE_CPP_EXAM_A_H

#include <vector>

struct Foo {
    static std::vector<int> a;
};
// or use extern instead of Foo

#endif //HSE_CPP_EXAM_A_H
```
`a.cpp`
```c++
#include <vector>
#include "a.h"

std::vector<int> Foo::a{1, 2, 3};
```
`main.cpp`
```c++
#include <iostream>
#include "a.h"

int first_of_a = Foo::a[0];

int main() {
    std::cout << first_of_a << '\n';  // either 1, or UB, as it's out-of-bounds
}
```
Если сначала инициализируются объекты из `main.cpp`, то `first_of_a` должно взять значение неинициализированного вектора, получая UB.
### Решение проблемы
Чтобы избежать этой проблемы, можно воспользоваться идиомой 'construct on first use': вместо `non-local` переменных, будем использовать `static local`, чтобы они гарантированно создались, когда мы ими воспользовались.

Например, для прошлого примера:

`a.h`
```c++
#ifndef HSE_CPP_EXAM_A_H
#define HSE_CPP_EXAM_A_H

#include <vector>

struct Foo {
    static std::vector<int>& getVector();
};

#endif //HSE_CPP_EXAM_A_H
```
`a.cpp`
```c++
#include <vector>
#include "a.h"

std::vector<int>& Foo::getVector() {
    static std::vector<int> a{1, 2, 3};
    return a;
}
```
`main.cpp`
```c++
#include <iostream>
#include "a.h"

int first_of_a = Foo::getVector()[0];

int main() {
    std::cout << first_of_a << '\n';  // now OK!
}
```
#### Сравнение с автоматическим временем жизни и динамическим
* В отличие от автоматического времени жизни, один и тот же объект может использоваться в разных единицах трансляции.
* В отличие от динамического времени жизни, такой способ безопаснее, потому что гарантируется, что объект живой.

### Замечания
* Циклическое SIOF починить не получится никак, так как оно циклическое...
* Такие же приколы могут быть с уничтожением объектов: может удалится объект, нужный другому в деструкторе. Такое можно решать, например, вообще никогда не удаляя объект:
```c++
Foo& getFoo() {
    static auto* ptr = new Foo();  // never destructs!
    return *ptr;
}
```
* `cin`, `cout` тоже глобальные переменные, поэтому если вы используете их в конструкторе, то теоретически могут быть такие же проблемы. Однако, начиная с C++11, гарантируется, что `cout`, `cin` и прочие создадутся раньше остальных объектов с статическим временем жизни. **Только в случае если `#include <iostream>` идёт до `#include` файла с объявлением**. Об этом можно поподробнее прочитать в [ubbook](https://github.com/Nekrolm/ubbook/blob/master/runtime/static_initialization_order_fiasco.md#initialization-order-fiasco-%D0%B8-%D0%BD%D0%B5%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D1%83%D0%B5%D0%BC%D1%8B%D0%B5-%D0%B7%D0%B0%D0%B3%D0%BE%D0%BB%D0%BE%D0%B2%D0%BA%D0%B8).

### Полезные ссылки
* https://isocpp.org/wiki/faq/ctors#static-init-order
* https://github.com/Nekrolm/ubbook/blob/master/runtime/static_initialization_order_fiasco.md
* https://en.cppreference.com/w/cpp/language/initialization
</details>

<details>
<summary>
 Билет 40. Базовое наследование.
</summary>


### Совместимость по ссылкам и указателям

#### Устройство

В C++ совершенно бесплатно можно получить делать `basecast` (`upcast`): кастовать объект типа `Derived` (здесь и далее
считаем, что `Derived` наследуется от `Base`) к типу `Base&`, то есть получать ссылку на базу от Derived.

Причем делать это можно неявно, потому что мы считаем, что внутри памяти базовый класс лежит суперхорошо и приятно.

Заметим, что так делать можно и с указателями, все правила те же, преобразование такое неявное.

```c++
struct Base {
    int x = 10;
    void foo() const {
        std::cout << "x = " << x << std::endl;
    }
};

struct Derived : Base {
    int y = 20;
    void bar() const {
        std::cout << "x = " << x << " y = " << y << std::endl;
    }
};

int main() {
    Derived d;
    Base& b = d; // произошел basecast
    b.x++; // так можно
    b.y++; // так нельзя
    Derived* d_ptr = d;
    Base* b_ptr = d_ptr; 
    b_ptr->foo(); // OK
    b_ptr->bar(); // CE
```

#### Мотивация

Если у нас есть функция, которая должна работать на всех методах, отнаследованных от `Base`, то в целом upcast --
единственный способ сделать такое:

```c++
void foo(Base& b) {
    std:cout << "foo(" << b.x << ")" << std::endl;
}
```

Например, в STL такое используется при создании `operator>>` или `operator<<` для вывода. Подробнее: есть два как бы
базовых класса `istream` и `ostream`, от которых мы как раз делаем операторы, а потом `cin/cout` делают `upcast` к ним.

#### Усиляем! (derived-cast)

Если в `foo` мы точно знаем, что переданная нам ссылка на `Base` пришла от `Derived`, то можно вернуться к `Derived`:

```c++
void foo(Base& b) {
    std:cout << "foo(" << b.x << ")" << std::endl;
    const Derived& d = static_cast<const Derived&>(b); // you need to use static_cast
}
```

Данный прием называется derivedcast или downcast. Прием очень опасный: его можно применять только в том случае, если мы
точно на 100% безошибочно знаем, что `b` -- на самом деле `Derived`. А иначе у нас будет UB, причем UB случится сразу в
момент каста, то есть даже если дальше мы не используем поля `Derived`.

Важный момент, что мы здесь используем `static_cast`. Вот, если хоть на секунду предположить, что мы его не используем,
то могут происходить различные страшные вещи. Например:

```c++
int main() {
    string s = "LOL!";
    int &x = (int&)(s); // UB
    cout << x << '\n'; // на моем компиляторе каждый запуск генерируется случайное число
}
```

Компилятор и слова не скажет о том, что вы не правы и так делать нельзя. А вот `static_cast` запретит вам компиляцию и
скажет, что вы не правы.

### Расположение подобъектов в памяти и padding (пустое место для выравнивания).

Сейчас рассматриваем базовое наследование, если будет множественное, то там может быть несовпадение адресов, конечно же.

Заметим, что если вывести `b_ptr` и `d_ptr`, то они неожиданным образом совпадут. Это ни разу не совпадение, стандарт
гарантирует, что базовый класс всегда лежит в начале производного класса.

Следующий момент: выравнивание. Каждый тип имеет свое выравнивание --- его адрес должен делиться на какое-то хорошее
число (например, адрес `int` должен делиться на 4, а адрес `char` на 1). Это пошло из некоторых особенностей архитектуры
процессоров, так как они не могут работать с плохими адресами.

Поэтому иногда получается так, что структура имеет размер больший, чем суммарный размер всех её полей. Например:

```c++
struct Bar{ // address = x
    char c; // alignof(char) == 1, address = x
    int i; // alignof(int) == 4, address = x + 1 is bad -> address = x + 4
}; // sizeof(Bar) == 8
```

Другой интересный пример:

```c++
struct Buzz{
    char c; // address = x
    int i; // address = x + 4
    char c2; // address = x + 8
}; // sizeof(Buzz) == 12, WTF?!

struct Foo{
    int i; // address = x
    char c; // address = x + 4
    char c2; // address = x + 5
}; // sizeof(Buzz) == 8, WTF?!
```

А ответ в данном случае такой: размер структуры должен делить на её `padding` = `max align` её полей. Это важно,
например, в тот момент, когда мы кладем структуры в массив. Выравниванием, как видно, можно легко управлять при помощи
порядка полей. Компилятор не сделает это за вас, потому что что-нибудь может быть на этом завязано (например, порядок
аргументов в конструкторе). При этом все переменные одного уровня доступа лежат подряд.

### Права доступа

В этот момент надо тупо открыть и показывать `12-211201/03-access-specifiers` тут по-другому никак.

#### 10-public.cpp

Публичные имена можно вызывать и получать где угодно и когда угодно. Все просто.

Друзья (как функции, так и классы) здесь не имеют значения, так как все публичное.

#### 11-private.cpp

Усложняем! Теперь можно вызывать методы только у себя. У друзей доступ только к другу, но не к отцу/сыну друга. Но при
этом у отца/сына друга никакого доступа к нам.

При этом важный момент, что дружба не наследуется ни каким образом: сын друга не является другом.

#### 12-protected.cpp

Методы получают доступ к методам отцов (дедов, ...)/своим. Но Base&.base_method (**basecast**) нельзя вызывать, ибо по
ссылке лежит что-угодно.

Строгое правило: мы имеем доступ к методам родителей, если мы уверены, что вызываем от родителя. Поэтому ссылочные типы
или указатели отправляются домой.

```c++
void Derived::derived_method(SubDerived &sd) {
    sd.base_method(sd);
    sd.derived_method(sd);
    // sd.subderived_method(sd);

    Base::base_static(sd);
    Derived::base_static(sd);
    SubDerived::base_static(sd);
    Derived::derived_static(sd);
    SubDerived::derived_static(sd);
    // SubDerived::subderived_static(sd);

    // WARNING: can only see protected through 'Derived' or 'SubDerived', not 'Base'.
    [[maybe_unused]] Base &b = sd;
    // b.base_method(sd);

    // Reason:
    [[maybe_unused]] OtherDerived od;
    // od.base_method(sd);
    // static_cast<Base&>(od).base_method(sd);

    [[maybe_unused]] Derived &d = sd;
    d.base_method(sd);
    d.derived_method(sd);
}
```

А что друзья? Друг Derived имеет доступ к методам Derived, но не к SubDerived. А что с методами Base? А кто его знает)
Там открытый issue на гитхабе: зависит от стандарта, компилятора, фазы луны, номера лабы, ...

### Hiding

Пусть у нас есть такой набор структур:

```c++
struct Base {
    void foo() {
        std::cout << "no args\n";
    }
    void foo(int) {
        std::cout << "int\n";
    }
};
struct Derived : Base {};

struct SubDerived : Derived {
    void foo(double) {
        std::cout << "double\n";
    }
    
    // void foo(int x) { std::cout << "SubDerived int\n"; Derived::foo(x); }
    // void foo() { std::cout << "SubDerived no args\n"; Derived::foo(); }
};
```

Разберемся с `Base`: у него можно вызывать `foo()`, `foo(int)`, `foo(double)` (преобразование `double` -> `int`). Все просто, простые перегрузки.

С `Derived` все то же самое. Ничего не поменялось.

А теперь начинаются мемы. Вот мы в `SubDerived` решили добавить новую перегрузку от `double`. Но теперь нельзя
вызывать `foo()`. Произошол _Hiding_.

Теперь более формально, что произошло. Рассмотрим механизм вызова невиртуальных функций:

1. Name resolution (разрешение имени) Output: "overload set".
2. Overload resolution. Output: a single overload. Определяем перегрузку, результат: какая-то одна функция.
3. Access check. Определяем можно ли трогать.
4. Call, can be virtual or non-virtual. Вызываемся, смотря на виртуальность.

То есть в `SubDerived` перегрузка ломается на первом шаге: она видит только `foo(double)`, а в родительских классах
перестает искать. Для того чтобы вернуть перегрузки есть два способа:

1. Вернуть все руками,
2. Воспользоваться `using <BaseClass>::<functionName>`. Это сделать unhiding функции, причем ровно до следующего
   hiding'а.

А теперь разберемся что еще умеет `using`. Во-первых, он умеет изменять права доступа:

```c++
struct Base {
protected:
    void magic() {
    }  // Similarly for fields.
};

struct Derived : Base {
    using Base::magic; // теперь метод magic публичный
};

struct SubDerived : Derived {
    void magic2() {
        magic();
        Base::magic();
        Derived::magic();
    }

private:
    using Derived::magic; // а теперь снова приватный
};

 [[maybe_unused]] Base b;
// b.magic(); <- protected

 Derived d; 
 d.magic(); // <- public
 // d.Base::magic(); <- protected

 SubDerived sd;
 // sd.magic(); <- private
 // sd.Base::magic(); <- protected
 sd.Derived::magic(); // <- public
 sd.magic2();
```

Во-вторых, он умеет перегружать ВСЕ конструкторы базового класса при помощи синтаксиса `using <BaseName>::<BaseName>;`.
После этого у нас все в `Derived` будут все конструкторы из `Base` (но создавать они будут уже `Derived`), причем если
мы создать новый конструктор с совпадающей сигнатурой, то он скроет базовый конструктор.


</details>

<details>
<summary>
 Билет 41. Использование наследования для неполиморфных классов
</summary>


### Совместимость по ссылкам и указателям

#### Устройство

В C++ совершенно бесплатно можно получить делать `basecast` (`upcast`): кастовать объект типа `Derived&` (здесь и далее
считаем, что `Derived` наследуется от `Base`) к типу `Base&`, то есть получать ссылку на базу от Derived.

Причем делать это можно неявно, потому что мы считаем, что внутри памяти базовый класс лежит суперхорошо и приятно.

Заметим, что так делать можно и с указателями, все правила те же, преобразование такое неявное.

```c++
struct Base {
    int x = 10;
    void foo() const {
        std::cout << "x = " << x << std::endl;
    }
};

struct Derived : Base {
    int y = 20;
    void bar() const {
        std::cout << "x = " << x << " y = " << y << std::endl;
    }
};

int main() {
    Derived d;
    Base& b = d; // произошел basecast
    b.x++; // так можно
    b.y++; // так нельзя
    Derived* d_ptr = d;
    Base* b_ptr = d_ptr; 
    b_ptr->foo(); // OK
    b_ptr->bar(); // CE
```

#### Усиляем x2 (slicing)

Пусть теперь у нас `foo` принимает не ссылку, а значение, то есть просто `Base`. После этого мы никогда не сможем делать
derivedcast, это всегда UB, UB ровно такое же, что и выше. Но! `foo` от `Derived` все еще можно вызвать. Это как раз и
называется `Slicing`, то есть "урезание".

Как это работает: когда мы делаем вызов `foo(d)`, то мы вызываем копирующий конструктор `Base(const Base &other)`, где
происходит basecast. После этого мы больше никак не можем вернуть тип `Derived`, поэтому и обратиться к полям `Derived`
больше нельзя. Соответственно, если попытаться сделать `derivedcast`, то можно получить ~~по лицу~~ UB.

Методика избежания слайсинга похожа на знаменитый метод "Насильник, не насилуй". То есть, просто будьте аккуратнее,
следите за типами, передавайте по ссылке и не пишите плохой код.

### Конструкторы и наследование: отличие от наследования обычных методов

Конструкторы не наследуется по умолчанию (специальные
методы ([смотри подробней](https://github.com/hse-spb-2021-cpp/lectures/blob/master/09-211110/00b-special-operators.cpp))
тоже, но они стараются сгенирироваться самостоятельно). Причем в конструкторе `Derived` мы всегда обязаны
сконструировать базовый класс, поэтому, если у `Base` нет конструктора по умолчанию, то мы должны явно его вызвать. В
отличие от других языков программирования, в C++ всего один способ вызвать конструктор родительского класса:
использовать member initialization list (когда задаем конструкторы через запятую после двоеточия). Пример:

```c++
struct Base {
    int x;
    Base(int x_) : x(x_) {}
};

struct Derived : Base {
    int y = 20;

    Derived() : Base(10) {} // Здесь нельзя вызывать без Base(10)
//    Derived(int y_) : y(y_), Base(0) {}  // -Wreorder, могут быть проблемы, потому что БАЗовый класс должен инициализироваться первым, 
//                                            -Wreorder как раз про это
//    Derived(int y_) : Base(y_), y(y_) {} // ok
    Derived(int y_) : Base(y_), y(y_) {}  // OK
};

struct SubDerived : Derived {
    SubDerived(int) {}  // : Derived() is implied. All right, no UB
};
```

Второй важный момент: родительские классы всегда инициализируются раньше, чем производные. Это очень важный принцип,
который используется дальше.

### final

Пока говорим о `final` для структур, а здесь все просто. После имени класса пишем `final` и запрещаем наследование от
нас:

```c++
struct Base {};
struct Derived1 final : Base {
    int value = 123;
};
struct SubDerived : Derived1 {}; // ban. Будет ошибка компиляции
```

### Пример неполиморфного наследование при реализации двусвязного списка с фиктивным элементом

Второй пример уже от Егора. Пусть мы хотим реализовать двусвязный список с фиктивной вершиной (то есть с вершиной, в
которой не лежит никаких данных). Для этого можно реализовать базовый класс `node`, который будет содержать только
**указатели** на соседей и сделать от него наследника `node_with_data`, в которого дополнительно положить данные.

После этого добавление и удаление из списка ни коем образом не завязано на том какого типа у нас вершины. При этом, если
у нас фиктивная вершина только стартовая, то можно удобно итерироваться и получать данные при помощи derivedcast. Полный
код:

```c++
#include <iostream>

struct node {
    node *prev = nullptr;
    node *next = nullptr;
};

struct node_with_data : node {
    int data;

    node_with_data(int data_) : data(data_) {}
};

void link(node &x, node &y) {
    x.next = &y;
    y.prev = &x;
}

int main() {
    node l;
    node_with_data a(10), b(20), c(30);

    link(l, a);
    link(a, b);
    link(b, c);
    link(c, l);

    for (node *it = l.next; it != &l; it = it->next) {
        auto it_data = static_cast<node_with_data*>(it);
        std::cout << it_data->data << "\n";
    }
    std::cout << "=====\n";

    node_with_data d(40);
    link(a, d);
    link(d, b);

    for (node *it = l.next; it != &l; it = it->next) {
        auto it_data = static_cast<node_with_data*>(it);
        std::cout << it_data->data << "\n";
    }
}
```

### Вызов невиртуальной функции

Тут важный момент, что если сделать `basecast`, то всегда будет вызываться функция из `Base`, даже если в `Derived` было
какое-то новое определение. Например, такое может происходить с деструкторами и поэтому все может ломаться в такой
ситуации:

```c++
struct Base {};
struct Derived : Base{ int x };

...

Base* b = new Derived(10); // законно, произошел basecast

delete b; // Утечка памяти, не почистили поле x
```
</details>

<details>
<summary>
 Билет 42. Полиморфные классы
</summary>


* ## Полиморфные классы, виртуальные функции, `override` `final` для методов, отличия от hiding, вызовы виртуальных функций

  Виртуальная функция - функция, объявленная в базовом классе и переопределенная в наследниках. Создается с помощью ключевого слова `virtual`. Наследники могут перезаписать её поведение словом override.

  До использования виртуальных функций столкнулись с такой проблемой: (не смотря на то что bd указывает на derived мы вызываем функцию из base тк колмпилятор решает какую функцию вызвать только на основании информации полученной на момент компиляции - видит, что ссылка на бэйс и вызывает функцию оттуда). Исправляется просто с помощью virtual.

  ```c++
  #include <iostream>
  #include <vector>
  
  struct Base {
      int x = 10;
  
      /*virtual*/ void print() const {
          std::cout << "x = " << x << "\n";
      }
  };
  
  struct Derived : Base {
      void print() const /*override /* C++11 */ {  // override: добавить virtual, проверить, что в родителе virtual есть. На самом деле virtual добавляется автоматически, если был в родителе.
          std::cout << "x = " << x << ", y = " << y << "\n";
      }
  };
  
  int main() {
      Base b;
      Derived d;
      b.print();
      d.print();
  
      Base &db = d;
      db.print();
  
      std::cout << sizeof(Base) << ", " << sizeof(Derived) << "\n";
  }
  ```

  Класс полиморфный, если у него есть хотя бы 1 виртуалная фнукция.

  * #### `override`

    Проверяет что эта функция действительно перезаписывает какую-то функцию из родителя.

    override можно не писать (но можно случайно не перезаписать функцию), если функция совпадает с какой-то сверху - она вирутальная.

  * #### `final`

    Запрещает наследование для классов:

    ```c++
    struct Derived1 final : Base {
        int value = 123;
    };
    struct SubDerived : Derived1 {}; // ban
    ```

    А еще и наследование методов:

    ```c++
    struct Base {
        virtual void foo() = 0;
        virtual void bar() = 0;
    };
    
    struct Derived : Base {
        void foo() final {  // final implies 'virtual'
        }
    
        // 'override' is redundant:
        // void fooo() final {}  // CE, which is fine.
        // virtual void fooo() final {}  // Not CE, which is not fine.
        virtual void fooo() final override {}  // CE, which is fine.
    
        void bar() override {
        }
    };
    
    struct SubDerived : Derived {
        // 'override' is not important, will not compile either way.
        // void foo() override {}
    
        void bar() override {
        }
    };
    ```

    `final override` - избыточно

  * #### отличия от hiding

    Отличия: Виртуальные функции нужны, чтобы вызываться из самого вложенного класса, а hiding про перегрузки - ищем наиболее подходящую функцию.

    [Из лекции про hiding](https://youtu.be/8-7duHce3Bo?list=PL8a-dtqmQc8obAqSKqGkau8qiafPRCxV7&t=1384)

    4 этапа правила поиска нужной функции:

    1. Name resolution (поиск по имени) Output: "overload set". (множество перегрузок)

    2. Overload resolution. Output: a single overload. Выбираем наиболее подходящую перегрузку

    3. Access check. Определяем можно ли трогать.

    4. Call, can be virtual or non-virtual. Вызываемся, смотря на виртуальность.

       Мы смотрим на все перегрузки foo, которые есть в структуре и только на них. На родителя мы не смотрим и не находим функции, которые нам подходят. (Если в структуре вообще нет нужной функции - тогда идем в родителя). 

    Если хотим перегрузки от родителя, то есть два способа:

    1. руками все сделать
    2. сделать unhiding: в теле класса написать `using <BaseClass>::<FunctionName>`.

    Мем: unhiding <<наследуется>> в смысле того, что пока еще раз не сделать hiding, то все перегрузки будут доступны.

    ```c++
    struct Base {
        void foo() {
            std::cout << "no args\n";
        }
        void foo(int) {
            std::cout << "int\n";
        }
    };
    
    struct Derived : Base {};
    
    struct SubDerived : Derived {
        void foo(double) {
            std::cout << "double\n";
        }
    
        // Will hide, no compilation error.
        // void foo(int x) { std::cout << "SubDerived int\n"; Derived::foo(x); }
        // void foo() { std::cout << "SubDerived no args\n"; Derived::foo(); }
    
        // Introduce members of Base/Derived called 'foo' into the definition, "unhide".
        // using Derived::foo;
        // using Base::foo;
    };
    
    struct SubSubDerived : SubDerived {
        // Has the same overloads as Derived, unless we add new overloads:
        void foo(int, int, int) {}
        using Derived::foo;
    };
    
    int main() {
        Base b;
        b.foo(1);    // int
        b.foo(1.2);  // int
        b.foo();     // no args
    
        SubDerived sd;
        sd.foo(1.2);  // double
        sd.foo(1);    // double :(
        sd.foo();     // compilation error?
        // Rule: if the derived class has a method called `foo`, do not look at
        //       base's methods, "hide" them.
    
        Derived &d = sd;
        d.foo(1);    // int
        d.foo(1.2);  // int
    
        SubSubDerived ssd;
        ssd.foo(1.2);  // int, because of 'using Derived::foo' instead of 'using SubDerived::foo'
    }
    ```

  * #### Вызовы виртуальных функции

    > Егор: есть указатель на таблицу виртуальных функций, мы в него пошли - посмотрели. - низкий уровень
    >
    > Высокий - посмотрели куда ссылается ссылка или указатель. Вызвали оттуда метод. 

* ### Один из способов реализации: таблица виртуальных функций, в том числе с наследованием

  От `std::function` до `vtable` :

  Наивная реализация полиморфизма:

  ```c++
  struct Base {
  int x = 10;
  
      std::function<void()> print = [&]() {
           std::cout << "x = " << x << "\n";
       };
       // std::function<void()> pretty_print = ....;
       // std::function<void()> read = ....;
  };
  struct Derived : Base {
      int y = 20;
  
      Derived() {
          print = [&]() { std::cout << "x = " << x << ", y = " << y << "\n"; };
      }
  };
  ```

  Проблема: `std::function` занимает много памяти (где-то 32 байта) и линейно растет  размер структуры с ростом количества функций.

  Заменим `std::function` на указатель на функцию `void (*)(Base *)`  (который может указывать только на глобальную или статическую функцию, на функци.-члены класса он указывать не может - поэтому функцию сделаем статической и будем явно принимать параметр Base*).  Указатель на функцию маленький. Занимает 4 или 8 байт в зависимости от архитектуры.

  В чем разница? Эта лямбда внутри себя хранит не только код, но еще и запоминает this - что избыточно, мы и так знаем, в каком объекте мы лежим.

  Обычно создают псевдоник для указателя на функцию, потому что тип страшный.   `using print_impl_ptr = void(*)(Base*)`

  Создаем в Base и  Derived отдельную статическую функцию print_impl, параметр у которой - явно переданный объект Base *.  Дальше возьмем эту функцию и сохраним её в поле типа указатель на функцию.

  Но print_ptr нужно явно передавать, на каком объекте мы вызваем. Поэтому желаем такую обычную функцию print, которая вызовет print_ptr на this

  ```c++
   struct Base {
   int x = 10;
  
   using print_impl_ptr = void(*)(Base*);
   static void print_impl(Base *b) {
       std::cout << "x = " << b->x << "\n";
   }
  
   print_impl_ptr print_ptr = print_impl;
   // pretty_print_impl_ptr pretty_print_ptr;
   // read_impl_ptr read_ptr;
  
   void print() {
       print_ptr(this);
   }
  };
  
  struct Derived : Base {
      int y = 20;
      static void print_impl(Base *b) {
          Derived *d = static_cast<Derived*>(b);
          std::cout << "x = " << d->x << ", y = " << d->y << "\n";
      }
      Derived() {
          print_ptr = print_impl;
      }
  };
  // вызов все еще x.print();
  ```

  У нас все еще есть линейный рост.

  Оптимизируем это.

  Пусть у нас много функций и мы сохранили много полей. Но все поля либо указывают на реализации из Base, либо из Derived. Не может быть такого, что какая-то часть на Base, другая - на Derived. Заведем 2 таблицы с этими полями. В структурах будем хранить указатель на табличку, которую мы используем.

  `Vtable` - таблицы виртуальных функций
  В каждой структуре храним указатель таблицы виртуальных функций `BaseVtable *vptr = &BASE_VTABLE;`

  Независимо от количества виртуальных функций размеры структур не меняются. Растет размер только vtable.

  ```c++
  struct Base;
  
  struct BaseVtable {  // virtual functions table
      using print_impl_ptr = void(*)(Base*);
      print_impl_ptr print_ptr;
      // pretty_print_impl_ptr pretty_print_ptr;
      // read_impl_ptr read_ptr;
  };
  
  struct Base {
      static const BaseVtable BASE_VTABLE;
  
      BaseVtable *vptr = &BASE_VTABLE;
      int x = 10;
  
      static void print_impl(Base *b) {
          std::cout << "x = " << b->x << "\n";
   }
  
      void print() {
          vptr->print_ptr(this);
      }
  };
  const BaseVtable Base::BASE_VTABLE{Base::print_impl};
  struct Derived : Base {
      static const BaseVtable DERIVED_VTABLE;
      int y = 20;
  
  static void print_impl(Base *b) {
      Derived *d = static_cast<Derived*>(b);
      std::cout << "x = " << d->x << ", y = " << d->y << "\n";
  }
  
  Derived() {
      vptr = &DERIVED_VTABLE;
  }
  };
  const BaseVtable Derived::DERIVED_VTABLE{Derived::print_impl};
  ```

  Что если хотим добавить в derived новые виртуальные функции? В данной реализации: нужно заводить новую табличку, хранить указатели на старую и новую таблички. Размер Derived растет линейно с уровнем вложенности.
  Решение: наследуем виртуальные таблицы друг от друга. Сделаем структуру `struct DerivedVtable : BaseVTable` и туда добавим новые поля.

  ```c++
  struct Base;
  struct BaseVtable {
      using print_impl_ptr = void(*)(Base*);
      print_impl_ptr print_ptr;
  };
    
  struct Base {
      static BaseVtable BASE_VTABLE;
      
      BaseVtable *vtr = &BASE_VTABLE;
      int x = 10;
        
      static void print_impl(Base *b) {
          std::cout << "x = " << b->x << "\n";
      }
        
      void print() {
          vtable->print_ptr(this);
      }
  };
  BaseVtable Base::BASE_VTABLE{Base::print_impl};
    
  struct Derived;
  struct DerivedVtable : BaseVtable {
      using mega_print_impl_ptr = void(*)(Derived*);
      mega_print_impl_ptr mega_print_ptr;
  };
    
  struct Derived : Base {
      static DerivedVtable DERIVED_VTABLE;
    
      int y = 20;
        
      static void print_impl(Base *b) {
          Derived *d = static_cast<Derived*>(b);
          std::cout << "x = " << d->x << ", y = " << d->y << "\n";
      }
        
        static void mega_print_impl(Derived *b) {
            std::cout << "megapring! y = " << b->y << "\n";
        }
        
        Derived() {
            vptr = &DERIVED_VTABLE;
        }
        
        void mega_print() {
            static_cast<DerivedVtable*>(vtable)->mega_print_ptr(this);
        }
    };
    DerivedVtable Derived::DERIVED_VTABLE{Derived::print_impl, Derived::mega_print_impl};
    
    struct SubDerivedVtable : DerivedVtable {
        // no new "virtual" functions
    };
    struct SubDerived : Derived {
        static SubDerivedVtable SUBDERIVED_VTABLE;
    
        int z = 20;
        
        static void mega_print_impl(Derived *b) {
            SubDerived *sd = static_cast<SubDerived*>(b);
            std::cout << "megaprint! y = " << sd->y << ", z = " << sd->z << "\n";
        }
        
        SubDerived() {
            vptr = &SUBDERIVED_VTABLE;
        }
    };
    SubDerivedVtable SubDerived::SUBDERIVED_VTABLE{Derived::print_impl, SubDerived::mega_print_impl};
  ```

  Здесь понятно, почему виртуальные вызовы --- это долго. Нам надо ВСЕГДА переходить по указателю, а это долго. А еще можно мазать мимо кэша.

  Кстати, `Vtable` может хранить данные для типа. Например, его название.

- #### Чисто виртуальные функции и абстрактные классы

  Идея: есть семейство объектов, у которых какие-то общие вещи, но нет общей реализации (типа ширина, высота, но формулы нет).

  `virtual int width() const = 0` - чисто виртуальная функция. У нее нет реализации. И мы должны переопредилить в каком-то из наследников.

  Абстрактный класс - есть хотя бы 1 чисто виртуальная функция. (Нельзя создать экзэмпляр такого класса, тк у него нет каких-то методов)

- #### Возможность вызвать чисто виртуальную функцию

  Чисто виртуальную функцию можно использовать в коде от наследников, если она реализована там. 

  ```c++
  #include <iostream>
  
  struct Widget {
      virtual int width() const = 0;  // pure virtual => Widget is 'abstract'
      virtual int height() const = 0;
  
      int area() const {
          return width() * height();
      }
  };
  
  struct Button : Widget {
      std::string label;
  
      Button(std::string label_) : label(std::move(label_)) {}
  
      int width() const override {
          return 10 + 8 * label.length();
      }
  
      int height() const override {
          return 10 + 12;
      }
  };
  
  struct Image : Widget {
      int w, h;
  
      Image(int w_, int h_) : w(w_), h(h_) {}
  
      int width() const override {
          return w;
      }
  
      int height() const override {
          return h;
      }
  };
  
  void print_area(const Widget &w) {
      std::cout << w.area() << "\n";
  }
  
  int main() {
      Button btn("Click Me!");
      Image img(60, 70);
      print_area(btn);
      print_area(img);
      // Widget w;  // CE
      // new Widget();  // CE
  }
  ```

- ## Виртуальный деструктор: когда, зачем, что будет, если не сделать

  [Часть лекции про это](https://youtu.be/_lUC9fJ2fcM?list=PL8a-dtqmQc8obAqSKqGkau8qiafPRCxV7&t=4752)

  Правило: если есть хотя бы 1 виртуальная функция - скорее всего деструктор тоже должен быть виртуальным.

  В наследниках виртуальный деструктор генерируется автоматически.

  ```c++
  struct Widget {
      ...
      virtual ~Widget() = default;  // IMPORTANT! Rule: add virtual dtor in polymorphic base.
      // virtual ~Widget() {};
      
  };
  
  struct Button : Widget {
      ...
      // virtual ~Button() = default; // automatically generated
  
  };
  
  struct Image : Widget { ... };
  
  int main() {
      {
          Button *b = new Button("Click me!");
          delete b;
      }
      {
          Image *i = new Image(60, 70);
          delete i;
      }
      {
          Widget *w = new Button("Click me!");
          delete w;  // Not UB: ~Button() because ~Widget() is virtual
      }
  }
  ```

  Если не виртуальный деструктор:

  ```c++
  Widget *w = new Button("Click me!");
  delete w; 
  ```

  Вызываем деструктор widget, а надо Button. UB - вызов деструктора не того типа.

- ## Запрет копирования и перемещения полиморфных объектов: синтаксиc

  Создаем базовый класс noncopyable. И наследуемся от него. Теперь класс некопируемый.

  ([Лекция](https://youtu.be/GNDBJ3i_JII?list=PL8a-dtqmQc8obAqSKqGkau8qiafPRCxV7&t=3227 ))

  ```c++
  struct noncopyable {  // boost::noncopyable
      noncopyable() = default;
      noncopyable(const noncopyable &) = delete;
      noncopyable(noncopyable &&) = delete;
      noncopyable &operator=(const noncopyable &) = delete;
      noncopyable &operator=(noncopyable &&) = delete;
  };
  
  struct Foo : private noncopyable {};
  struct Bar : private noncopyable {};
  struct Baz : private noncopyable {};
  
  int main() {
      Foo f;
      // noncopyable &n = f;  // WTF, 'private' prevents that.
  
      // Foo f2 = f;
  }
  ```

- ## Вызовы виртуальных функций в конструкторах и деструкторах: обычные, с явным указанием класса через `::`

  Виртуальные функции в коснструкторах и деструкторах вызываются без виртуальности. Рассмотрим в примере констурктор от derived. В нем мы вызываем коструктор от Base. Но на этот момент Derived еще не создан - вызываем foo из base. Потом уже из Derived. Аналогично с деструктором. Сначала уничтожили Derived. Идем уничтожать base, и функцию из derived вызвать уже нельзя.

  [Пример из лекции](https://youtu.be/GNDBJ3i_JII?list=PL8a-dtqmQc8obAqSKqGkau8qiafPRCxV7&t=2371)

  ```c++
  #include <iostream>
  
  struct Base {
      int value = 123;
  
      virtual void foo() {
          std::cout << "foo(" << value << ")\n";
      };
  
      Base() {
          foo(); //Base
      }
  
      ~Base() {
          foo(); //Base
      }
  };
  
  struct Derived : Base {
      int value2 = 456;
  
      void foo() override {
          std::cout << "foo(" << value << ", " << value2 << ")\n";
      }
  
      Derived() : Base(), value2(100) {
          foo(); //Base, Derived
      }
  
      ~Derived() {
          foo(); //Derived, Base
      }
  };
  
  int main() {
      Derived d;
      std::cout << "== constructed ==\n";
      d.foo();
      static_cast<Base &>(d).foo();
      std::cout << "== foo called ==\n";
  }
  ```

  Чисто виртуальные:

  Ошибка компиляции, тк функция printTo( ) не реализована. Но можно реализовать (расскомитеть строчки Base::printTo())

  ```c++
  #include <iostream>
  
  struct Base {
      int value = 123;
  
      virtual void printTo() = 0;
  
      Base() {
          printTo();
      }
  };
  
  /*void Base::printTo() {  // BUT WHY
      std::cout << "Not so pure, eh?\n";
  }*/
  
  struct Derived : Base {
      void printTo() override {
      }
  };
  
  int main() {
      // Base b;  // class is still abstract.
      Derived d;
  }
  ```



- ## `dynamic_cast` для указателей и ссылок (без обработки исключений), проверка `dynamic_cast` внутри `if` одновременно с определением новой переменной, требование на полиморфность класса

  Один из умных кастов: `static_cast` делал down cast, если попали, иначе UB. А `dynamic_cast` кастует, если можно, иначе кидает `nullptr`.

  При этом, чтобы `dynamic_cast<T>` скомпилися нужно, чтобы `T` был полиморфным. В основном используется для проверки можно ли скастовать:

  ```
  if (const SubDerived1 *md1 =
          dynamic_cast<const SubDerived1 *>(&b)) {  // C++03
      std::cout << "SubDerived1 " << md1->value << "\n";
  }
  // md1 is not visible
  
  if (const Derived2 *d2 = dynamic_cast<const Derived2 *>(&b);
      d2 != nullptr) {  // C++17: if with init statement
      std::cout << "Derived2 " << d2->value << "\n";
  }
  // d2 is not visible
  ```

  `dynamic_cast` для `nullptr` всегда возвращает `nullptr` (стандарт).

  Иногда `dynamic_cast` вместе с RTTI отрубают ибо медленно/раздувайте бинарник. Ключ в gcc: `-fno-rtti`

  ### Ссылки

  Второе использование: вместе со ссылками.

  Если нельзя скастовать, то получим исключение, которое можно поймать.



- ## RTTI, оператор `typeid`, типы `type_info` и `type_index`, использование `boost::core::demangle`

  * ### RTTI - run time type information

    > Информация про типы, которая доступна во время выполнения.
    > Полезен для полиморфных классов.

  * ### оператор `typeid`

    [cppreference](https://en.cppreference.com/w/cpp/language/typeid)

    Один из двух базовых операторов, который использует RTTI. Позволяет узнать, что за объект. Требуется именно ссылка, не умный указатель (он скажет, что там `std::unique_ptr<Base, std::defualt_delete<Base>>`)

    1. typeid от какого-то конкретного типа
       `const std::type_info &info_base = typeid(Base);` Компилятор возвращает константную ссылку на некоторую структуру type_info. В ней лежит какая-то информация про тип

       ```
       const std::type_info &info_base = typeid(Base);
       const std::type_info &info_derived = typeid(Derived);
       const std::type_info &info_int = typeid(int);
       
       // Получить имя типа
       std::cout << boost::core::demangle(info_base.name()) << "\n";
       std::cout << boost::core::demangle(info_derived.name()) << "\n";
       std::cout << boost::core::demangle(info_int.name()) << "\n";
       ```

    2. typeid от неполиморфного выражения

       Если класс не полиморфный, например, `int`, то тип будет выведен очень просто.
       (foo() - возвращает инт и эта функция не вызывается вообще)

       ```
       typeid(2 + 2 + foo()) = typeid(int)
       ```

    3. А если полиморфный, то получится прикольно:

       (переменная полиморфного типа, ссылка на полиморфный класс)

       typeid честно вычисляет значение полностью. Компилятор берет ссылку и смотрит, на какой объект эта ссылка на самом деле указывает.

       ```
       std::cout << "===== 2a (polymorphic) =====\n";
           Base b;
           Derived d;
           std::cout << boost::core::demangle(typeid(b).name()) << "\n";
           std::cout << boost::core::demangle(typeid(d).name()) << "\n";
           std::cout << boost::core::demangle(typeid(bar()).name())
                     << "\n";  // bar() is called
       
           Base &bd = d; // именно ссылка, (умный) указатель не сработает
           std::cout << boost::core::demangle(typeid(bd).name()) << "\n";
       ```

    ### операции с typeid

    У `typeid` есть `operator==`:

    ```
    Base b;
    Derived d;
    
    const std::type_info &info_base = typeid(Base);
    const std::type_info &info_derived = typeid(Derived);
    const std::type_info &info_b = typeid(b);
    const std::type_info &info_d = typeid(d);
    
    std::cout << (info_base == info_b) << "\n";     // 1
    std::cout << (info_base == info_d) << "\n";     // 0
    std::cout << (info_derived == info_b) << "\n";  // 0
    std::cout << (info_derived == info_d) << "\n";  // 1
    ```

    Заметим, что названия выводятся криво: `i` vs `int` (gcc vs MSVC) и так далее. Есть `type_index`, который позволяет класть `typeid` в сеты.

  * ### тип `type_info`

    `std::type_info` - класс, который содержит информацию о типе, включая имя типа, средства сравнения, порядок сортировки. Возвращается оператором `typeid` - [cppreference](https://en.cppreference.com/w/cpp/types/type_info)

    Можно брать константную ссылку, name, сравнивать на равно - не равно. Рефлексия.

  * ### тип `type_index`

    Обертка над type_info. Можно копировать, сравнивать, класть в set и unordered set

    [cppreference](https://en.cppreference.com/w/cpp/types/type_index)

  * ### использование `boost::core::demangle`

    Использовали в typeid.

    `std::cout << boost::core::demangle(info_base.name()) << "\n";`

    Эта функция в зависимости от того, каким компилятором мы компилируем пытается догадаться, что хотела сказать функция name и вывести имя типа.

    [Документация](https://www.boost.org/doc/libs/1_63_0/libs/core/doc/html/core/demangle.html)

    `info_base.name()` выводит разное в зависимости от компилятора

- ##### Не было: эмуляция виртуальных операторов (вроде `operator<<`, практика `14-210121`)

- ##### Не было: виртуальные конструкторы и паттерн "фабричная функция" (в том числе для `make_unique` и копирования)

</details>

<details>
<summary>
 Билет 43. Множественное наследование
</summary>


Ссылка на репо практики - `13-211208/01-mi-virtual` - [клик](https://github.com/hse-spb-2021-cpp/lectures/tree/master/13-211208).
<!-- 1 -->
### Синтаксис, пример
Когды мы делаем множественное наследование, у нас (в данном примере) существует два разных `Base` у `Derived`:
```cpp
struct Base {
	int data;
	Base(int data_): data(data_) {}
};

struct X : Base {
	X(): Base(1) {}
	void print() {
		std::cout << "X: " << data << std::endl; 
	}
};

struct Y : Base {
	Y(): Base(-1) {}
	void print() {
		std::cout << "Y: " << data << std::endl; 
	}
};
struct Derived: X, Y {};
/*
   Base         Base
    ^            ^
    |            |
    X            Y
    ^            ^
     \          /
        \    /
       Derived
*/
int main() {
	Derived d;
	// d.print(); // CE - print() is ambiguous
	d.X::print(); // X: -1
	d.Y::print(); // Y: 1
}
```
<!-- 2 -->
### Возможное представление в памяти, пример изменения адреса при static_cast (потому что начало подобъект теперь не всегда совпадает с началом объекта)
- Возможное представление в памяти выглядит следующим образом:
```cpp
// Layout is guaranteed, exact sizes and padding vary:
+---------------------------------------------------------+
| +---------------------+ +----------------------+        |
| | +------------+      | | +------------+       |        |
| | | Base       |      | | | Base       |       |        |
| | | +data      |      | | | +data      |       |        |
| | +------------+      | | +------------+       |        |
| |   X                 | |   Y                  |        |
| |                     | |                      |        |
| +---------------------+ +----------------------+        |
| Derived                                                 |
|                                                         |
+---------------------------------------------------------+
```
- Пример изменения адреса при `static_cast`: при касте к `X` все будет как раньше, при касте к `Y` сдвиг на нужный адрес.
```cpp
struct Base {
	int data = 10;
};

struct X : Base {};
struct Y : Base {};

struct Derived : X, Y {};

int main() {
	Derived d;
	X& x = static_cast<X&>(d);
	std::cout << &x << ' ' << &d << std::endl;
	// 0x7ffcb09b8530 0x7ffcb09b8530

	Y& y = static_cast<Y&>(d);
	// Тут отступ на размер int, так как в Derived X и Y лежат один за другим в таком порядке 
	std::cout << &y << ' ' << &d << std::endl;
	// 0x7ffcb09b8534 0x7ffcb09b8530
}
```
<!-- 3 -->
### Порядок инициализации/уничтожения подобъектов и полей, как передать параметры конструкторам
- Инициализация: при инциализации у нас вначале вызовутся конструторы родительских классов (в порядке перечисления наследования), затем наш конструтор. Чтобы передать параметры в конструкторы родителей, мы передаем их в наш конструктор, а в его списке инциализации членов (member initialization list) мы вызываем нужные конструкторы родителей.
- Удаление: вначале вызывается наш деструтор, внутри он вызывает дескрукторы родителей.
```cpp
struct Base {
	int data;
	Base(int data_): data(data_) { std::cout << "Base()\n"; }
	~Base() { std::cout << "~Base()\n"; }
};
struct X : Base {
	X(): Base(1) { std::cout << "X()\n"; }
	~X() { std::cout << "~X()\n"; }
};
struct Y : Base {
	Y(): Base(-1) { std::cout << "Y()\n"; }
	~Y() { std::cout << "~Y()\n"; }
};
struct Derived: Y, X {
	Derived() { std::cout << "Derived()\n"; }
	~Derived() { std::cout << "~Derived()\n"; }
};

int main() {
	Derived d;
}
/*
Base()
Y()
Base()
X()
Derived()
~Derived()
~X()
~Base()
~Y()
~Base()
*/
```
<!-- 4 -->
### Возможное дублирование базового класса и возникающие неоднозначности при приведении типа
Если мы пытаемся скастовать класс, у которого имеется дубликаты среди родителей, то мы получим CE (все классы в примере кода имееют ту же структуру, что и в примерах выше): 
```cpp
/*
   Base         Base
    ^            ^
    |            |
    X            Y
    ^            ^
     \          /
        \    /
       Derived
*/
...
Derived d;
Base& b = static_cast<Base&> (d); // CE - ‘Base’ is an ambiguous base of ‘Derived’
X& x = static_cast<X&> (d); // OK
Y& y = static_cast<Y&> (d); // OK
...
```
<!-- 5 -->
### Cross-cast (он же side-cast, `13-211208`/`01-mi-virtual`/`25-side-cast.cpp`)
Ссылка на код упражнения - [тык](https://github.com/hse-spb-2021-cpp/lectures/blob/master/13-211208/01-mi-virtual/25-side-cast.cpp).

Основная идея в том, что если у нас базовый класс полиморфный (равносильно тому, что есть хотя бы один виртуальный метод), то с помощью `dynamic_cast<...>()` мы можем получить ссылку на своего брата:
```cpp
struct Base1 { virtual ~Base1() {} };
struct Base2 { virtual ~Base2() {} };
struct Base3 { virtual ~Base3() {} };

struct Derived1 : virtual Base1 {};
struct Derived12 : virtual Base1, virtual Base2 {};
struct Derived23 : virtual Base2, virtual Base3 {};
struct Derived3 : virtual Base3 {};

struct DerivedX : Derived1, Derived12, Derived23, Derived3 {};
/*
  B1  B2  B3
  /\  /\  /\
 /  \/  \/  \
D1  12  23  D3
  \  \  /   /
   --\\//---
      DX
*/
...
void foo(Derived1 &d1) {
	// NOTE: 'virtual' inheritance is not important here.
	std::cout << dynamic_cast<Derived3*>(&d1) << std::endl;
}
...
DerivedX d;
foo(d); // 0x7ffc4733fa68 - some memory address
```
Что тут произошло: в `foo()` мы передали объект типа `DerivedX`, при передачи параметра случился каст к родителю (к `Derived1`), после чего мы с помощью `dynamic_cast` снова перешли в `DerivedX` и уже у него поискали `Derived3`.
<!-- 6 -->
### Как теперь работают dynamic_cast/static_cast/неявное преобразование/override/hiding/приватное и защищённое наследование
- `dynamic_cast`: можем кастовать классы по иерархии, но при этом базовый класс обязан быть полиморфным.
- `static_cast`: если используем обычное множественное наследование то все ок. Если используем виртуальное наследование, то можно делать `static_cast` от ребенка к родителю, но мы не можем сделать `static_cast` в обратную сторону, поскольку представление объектов в памяти будет отличаться в зависимости от иерархии наследования, и мы просто не сможем понять, кем на самом деле являемся:
```cpp
/*
   Base
   ^  ^
  /    \
 /      \
X        Y
^        ^
 \      /
  \    /
 Derived
*/
struct Base {
	int base_data = 0;
	virtual ~Base() {}
};
struct X : virtual Base { int x_data = 0; };
struct Y : virtual Base { int y_data = 0; };
struct Derived : X, Y { };

int main() {
	Derived d1;
	X &x1 = static_cast<X&>(d1); // статический каст к родителю - OK
	Base &b1 = d1; // неявное преобразование к родителю - OK
	// d1: (baseptr x_data) (baseptr y_data) base_data

	X x2;
	Base &b2 = x2; // static_cast<Base&>(x2); is also ok
	// x2: (baseptr x_data) base_data

	dynamic_cast<X*>(&b1); // OK
	static_cast<X&>(b1);   // CE - cannot convert from pointer to base class ‘Base’ to pointer to derived class ‘X’ because the base is virtual
}
``` 
- Неявное преобразование: тут рили хз, что писать (на лекциях такого отдельно не проговаривали)
- override: Если мы наследуемся от двух классов, у которых есть виртуальные функции с одинаковой сигнатурой, то при перезаписи мы перезапишем оба метода (смотреть пример) - [ссылка на упражнение с кодом](https://github.com/hse-spb-2021-cpp/lectures/blob/master/13-211208/01-mi-virtual/02-override-independent.cpp).  
- hiding: 
	- перекрывает методы с таким же названием (не сигнатурой) у родителей:
	```cpp
	struct Base1 {
		void foo(int) {
			std::cout << "foo(int)\n";
		}
	};
	struct Base2 {
		void foo(double) {
			std::cout << "foo(double)\n";
		}
		void foo() {
			std::cout << "foo()\n";
		}
	};
	struct Derived : Base1, Base2 {
		void foo(char) {
			std::cout << "foo(char)\n";
		}
	};

	int main() {
		Derived d;
		d.foo(1.1); // foo(char)
	}
	```

	- Возникает неоднозначность, если в нескольких родителях есть методы с одинаковым именем:
	```cpp
	// Order:
	// 1. Name resolution. Output: "overload set".
	// 2. Overload resolution. Output: a single overload.
	// 3. Access check.
	// 4. Call, can be virtual or non-virtual.
	struct Base1 {
		void foo(int) {
			std::cout << "foo(int)\n";
		}
	};
	struct Base2 {
		void foo(double) {
			std::cout << "foo(double)\n";
		}
		void foo() {
			std::cout << "foo()\n";
		}
	};
	struct Derived : Base1, Base2 {};

	int main() {
		Derived d;
		d.foo(1.1);
	}
	``` 
	- При все при этом можем использовать `using` - никто не запрещает, также если все перегрузки лежали в одном из родителей, то все скомпилируется без проблем и разрешится корректно.
- Приватное и защищённое наследование: квалификаторы перечисляются вместе с родительскими классами: `struct Class: public Base1, private Base2, protected Base3 {};`. В целом тут все очев, но есть локальные приколы, [например](https://github.com/hse-spb-2021-cpp/lectures/blob/master/13-211208/01-mi-virtual/21-most-accessible-path.cpp):
```cpp
struct Base {
	int data;
};
struct X : private virtual Base {};
struct Y : public virtual Base {};
struct X1 : X {
	void foo() {
		data = 10;  // access through X, private - bad, you'll suck a ****!!!
	}
};

struct Derived : X, Y {
	void foo() {
		data = 10;  // access is public through Y
		Y::data = 20;  // accessible as well, not surprising
		X::data = 30;  // accessible as well, wow
	}
};
```
В этом примере, так как наследование виртуальное, то у нас один экземпляр `Base`, поэтому у нас есть доступ к его полям через `Y`, который наследуется от `Base` публично. 

#### В том числе при наличии одинаковых виртуальных функций в независимых базах
При наличии независимых баз с одинаковыми виртуальными методами при перезаписывании мы перекроем сразу оба:
```cpp
struct Base1 {
	virtual void foo() {
		std::cout << "Base1: foo()\n";
	}
};

struct Base2 {
	virtual void foo() {
		std::cout << "Base2: foo()\n";
	}
};

struct Derived : Base1, Base2 {
	void foo() override {
		std::cout << "Derived: foo()\n";
	}
};


int main() {
	Derived d;
	d.foo(); // Derived: foo()

	Base1 &b1 = d;
	b1.foo(); // Derived: foo()

	Base1 &b2 = d;
	b2.foo(); // Derived: foo()
}
```

</details>

<details>
<summary>
 Билет 45. Бонусный
</summary>

По словам Егора, достаточно этих двух примеров.  
[первый](https://github.com/hse-spb-2021-cpp/exercises/blob/master/13-211213/solution/03-logger.cpp)  
[второй](https://github.com/hse-spb-2021-cpp/exercises/blob/master/10-211122/solution/12-add-visitor.cpp)   
[хабр](https://habr.com/ru/post/463385/)  

Ну мы немного не сделали, если у вас есть силы... (с меня Strongbow/что угодно с такой же стоимостью)
</details>

