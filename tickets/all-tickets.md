<details>
<summary>
 Template Ticket
</summary>


**Р¶РёСЂРЅС‹Р№ С‚РµРєСЃС‚** _РєСѓСЂСЃРёРІ_ ~~РѕС€РёР±РєР°~~ ==РјРЅРµРЅРёСЏ?== `inline code block` [СЃСЃС‹Р»РєР° РЅР° С„СѓР»Р»](https://www.markdownguide.org/cheat-sheet/)
```c++
int main() {
    return 0;
}
```

### РџРѕРґР·Р°РіРѕР»РѕРІРѕРє

LMAO
Not bottom text, lol
</details>

<details>
<summary>
 4. Р¤СѓРЅРєС†РёРё
</summary>

* ## РџР°СЂР°РјРµС‚СЂС‹
  * ### РЎРёРЅС‚Р°РєСЃРёСЃ (РїСЂРѕРїСѓС‰РµРЅРЅРѕРµ РёРјСЏ, Р·РЅР°С‡РµРЅРёРµ РїРѕ СѓРјРѕР»С‡Р°РЅРёСЋ РІ РѕР±СЉСЏРІР»РµРЅРёРё/РѕРїСЂРµРґРµР»РµРЅРёРё)  
  РЈ С„СѓРЅРєС†РёРё РµСЃС‚СЊ РѕР±СЉСЏРІР»РµРЅРёРµ Рё РѕРїСЂРµРґРµР»РµРЅРёРµ, С…РѕС‚СЏ РѕР±С‹С‡РЅРѕ РѕРЅРё РїРёС€СѓС‚СЃСЏ СЃСЂР°Р·Сѓ РІРјРµСЃС‚Рµ. РЈ С„СѓРЅРєС†РёРё РµСЃС‚СЊ С‚РёРї, РЅР°Р·РІР°РЅРёРµ, РІ РєСЂСѓРіР»С‹С… СЃРєРѕР±РєР°С… РїРµСЂРµРґР°СЋС‚СЃСЏ РїР°СЂР°РјРµС‚СЂС‹, РІ С„РёРіСѓСЂРЅС‹С… СЃР°РјРѕ С‚РµР»Рѕ С„СѓРЅРєС†РёРё.  
  ```C++
  void foo(int a, int b){}
  void foo(vector v = {1, 2, 3}){} // РїР°СЂР°РјРµС‚СЂ РїРѕ СѓРјРѕР»С‡Р°РЅРёСЋ
  ```
  Р’РѕС‚ С‚Р°Рє Р±СѓРґРµС‚ РІС‹РіР»СЏРґРµС‚СЊ, РµСЃР»Рё С…РѕС‚РёРј СЂР°Р·РґРµР»РёС‚СЊ РѕР±СЉСЏРІР»РµРЅРёРµ Рё РѕРїСЂРµРґРµР»РµРЅРёРµ.  
  ```C++
  void foo(int a, int b);
  void foo(int a, int b){
     return a + b;
  }
  ```
  Р­С‚Рѕ РјРѕР¶РµС‚ Р±С‹С‚СЊ РїРѕР»РµР·РЅРѕ, РЅР°РїСЂРёРјРµСЂ РєРѕРіРґР° РјС‹ С…РѕС‚РёРј РёСЃРїРѕР»СЊР·РѕРІР°С‚СЊ РґРІРµ С„СѓРЅРєС†РёРё РґСЂСѓРі РІ РґСЂСѓРіРµ. РџСЂРё СЌС‚РѕРј РѕРґРЅР° РёР· РЅРёС… Р±СѓРґРµС‚ РѕРїСЂРµРґРµР»РµРЅР° РІСЃРµРіРґР° СЂР°РІРЅСЊС€Рµ РґСЂСѓРіРѕР№, РїРѕСЌС‚РѕРјСѓ РїСЂРёС…РѕРґРёС‚СЃСЏ РїСЂРёРґРµРіР°С‚СЊ Рє `Forward decloration`. РўРѕ РµСЃС‚СЊ РјС‹ РіРѕРІРѕСЂРёРј, С‡С‚Рѕ С‚Р°РєР°СЏ С„СѓРЅРєС†РёСЏ РµСЃС‚СЊ, Рё РјС‹ РјРѕР¶РµРј РµС‘ РІС‹Р·С‹РІР°С‚СЊ, РЅРѕ РІРѕС‚ РµС‘ РѕРїСЂРµРґРµР»РµРЅРёРµ РјС‹ РїРѕРїРѕР·Р¶Рµ РЅР°РїРёС€РµРј.
  ```C++
  int bar(int x);
  int foo(int y){
      return bar(y - 1) + 1; // OK
  }
  int bar(int x){
      if(x <= 0) return 1;
      return foo(x - 1);
  }
  ```
  Р•С‰С‘ РѕРґРёРЅ СЃР»СѓС‡Р°Р№, РєРѕРіРґР° Сѓ РЅР°СЃ РµСЃС‚СЊ РЅРµСЃРєРѕР»СЊРєРѕ РµРґРёРЅРёС† С‚СЂР°РЅСЃСЏС†РёРё. Р’ СЌС‚РѕРј СЃР»СѓС‡Р°Рµ С‚Р°Рј С‚Р°Рє Р¶Рµ РёРЅРѕРіРґР° РїСЂРёС…РѕРґРёС‚СЃСЏ РёСЃРїРѕР»СЊР·РѕРІР°С‚СЊ С„СѓРЅРєС†РёСЋ РІ РµРґРёРЅРёС†Рµ С‚СЂР°РЅСЃР»СЏС†РёРё РѕС‚Р»РёС‡РЅРѕР№ РѕС‚ С‚РѕР№, РіРґРµ РјС‹ СЃРѕР±СЃС‚РІРµРЅРЅРѕ СЌС‚Сѓ С„СѓРЅРєС†РёСЋ РѕРїСЂРµРґРµР»СЏРµРј. РџРѕСЌС‚РѕРјСѓ РїСЂРёС…РѕРґРёС‚СЃСЏ РІ РєР°Р¶РґРѕР№ РѕС‚РґРµР»СЊРЅРѕР№ РµРґРёРЅРёС†Рµ С‚СЂР°СЃР»СЏС†РёРё РїРёСЃР°С‚СЊ РѕР±СЉСЏРІР»РµРЅРёРµ, РµСЃР»Рё РјС‹ С…РѕС‚РёРј РёСЃРїРѕР»СЊР·РѕРІР°С‚СЊ С„СѓРЅРєРёСЋ.  
  РњРѕР¶РЅРѕ РІ РєР°С‡РµСЃС‚РІРµ РїР°СЂР°РјРµС‚СЂР° РёСЃРїРѕР»СЊР·РѕРІР°С‚СЊ Р°РіСЂСѓРјРµРЅС‚ Р±РµР· РёРјРµРЅРё, СѓРєР°Р·Р°РІ С‚РѕР»СЊРєРѕ РµРіРѕ С‚РёРї. Р­С‚Рѕ, РЅР°РїСЂРёРјРµСЂ, РёСЃРїРѕР»СЊР·СѓРµС‚СЃСЏ, С‡С‚РѕР±С‹ СЂР°Р·Р»РёС‡СЏС‚СЊ РїСЂРµС„РёРєСЃРЅС‹Р№ Рё РїРѕСЃС‚С„РёРєСЃРЅС‹Р№ РґРµРєСЂРёРјРµС‚РЅС‹ Рё РёРЅРєСЂРµРјРµРЅС‚С‹. РћР±СЂР°С‚РёС‚СЊСЃСЏ Рє РїРµСЂРµРґР°РЅРЅРѕРјСѓ С‚Р°РєРёРј РѕР±СЂР°Р·РѕРј Р°СЂРіСѓРјРµРЅС‚Сѓ РІРЅСѓС‚СЂРё С„СѓРЅРєС†РёРё РЅРµ РїРѕР»СѓС‡РёС‚СЃСЏ. РџСЂРё СЌС‚РѕРј СЂР°СЃРїР°Р»Р°РіР°С‚СЊ РёС… РјРѕР¶РЅРѕ РІ РїРµСЂРµРјРµС€РєСѓ СЃ РѕР±С‹С‡РЅС‹РјРё Р°СЂРіСѓРјРµРЅС‚Р°РјРё, РЅРѕ РґРѕ Р°РіСЂСѓРјРµРЅС‚РѕРІ СЃРѕ Р·РЅР°С‡РµРЅРёСЏРјРё РїРѕ СѓРјРѕР»С‡Р°РЅРёСЋ.  
  ```C++
  void foo1(int a, int, int b, int, int, int c = 100){} // OK
  void foo2(int a, int, int b, int, int, int c = 100, int){} // Compilation error
  void foo3(int a, int, int b, int, int, int c = 100, int = 1){} // OK
  ```
  РђСЂРіСѓРјРµРЅС‚С‹ СЃРѕ Р·РЅР°С‡РµРЅРёСЏРјРё РїРѕ СѓРјРѕР»С‡Р°РЅРёСЋ РІСЃРµРіРґР° РёРґСѓС‚ РїРѕСЃР»Рµ РІСЃРµС… РѕСЃС‚Р°Р»СЊРЅС‹С…. РњРѕР¶РЅРѕ РїРµСЂРµРґР°РІР°С‚СЊ РёРј РЅРѕРІС‹Рµ Р·РЅР°С‡РµРЅРёСЏ РїСЂРё РІС‹Р·РѕРІРµ С„СѓРЅРєС†РёРё. Р—Р°РґР°С‚СЊ Р·РЅР°С‡РµРЅРёРµ РїРѕ СѓРјРѕР»С‡Р°РЅРёСЋ РјРѕР¶РЅРѕ РєР°Рє РІ РѕР±СЉСЏРІР»РµРЅРёРё, С‚Р°Рє Рё РІ РѕРїСЂРµРґРµР»РµРЅРёРё С„СѓРЅРєС†РёРё, РЅРѕ С‚РѕР»СЊРєРѕ Р»РёР±Рѕ С‚Р°Рј, Р»РёР±Рѕ С‚Р°Рј.
  ```C++
  void foo1(int c = 100);
  void foo1(int c){
    std::cout << c; // Р’С‹РІРѕРґРёС‚ 100
  }
  ```  
    
  * ### РџРµСЂРµРґР°С‡Р° РїР°СЂР°РјРµС‚СЂРѕРІ РїРѕ: Р·РЅР°С‡РµРЅРёСЋ, `&`, `const&`. Р§С‚Рѕ РІС‹Р±СЂР°С‚СЊ Рё РїРѕС‡РµРјСѓ.  
  РђСЂРіСѓРјРµРЅС‚С‹ РІ С„СѓРЅРєС†РёСЋ РјРѕР¶РЅРѕ РїРµСЂРµРґР°РІР°С‚СЊ РїРѕ Р·РЅР°С‡РµРЅРёСЋ, РїРѕ СЃСЃС‹Р»РєРµ, РїРѕ РєРѕРЅСЃС‚Р°РЅС‚РЅРѕР№ СЃСЃС‹Р»РєРµ. Р•СЃР»Рё РїРµСЂРµРґР°РІР°С‚СЊ РїРѕ Р·РЅР°С‡РµРЅРёСЋ, С‚Рѕ РІ С„СѓРЅРєС†РёСЋ РєРѕРїРёСЂСѓРµС‚СЃСЏ РїРµСЂРµРґР°РЅРЅС‹Р№ Р°СЂРіСѓРјРµРЅС‚. Р•СЃР»Рё РїРѕ СЃСЃС‹Р»РєРµ, С‚Рѕ Р±РµСЂС‘С‚СЃСЏ СЃСЃС‹Р»РєР° РЅР° РїРµСЂРµРґР°РЅРЅС‹Р№ Р°РіСЂСѓРјРµРЅС‚ (С‚Рѕ РµСЃС‚СЊ РµСЃР»Рё С‚РµРїРµСЂСЊ РµРіРѕ РїРѕРјРµРЅСЏС‚СЊ РІРЅСѓС‚СЂРё С„СѓРЅРєС†РёРё, С‚Рѕ РѕРЅ РїРѕРјРµРЅСЏРµС‚СЃСЏ Рё РІ С‚РѕРј РјРµСЃС‚Рµ, РіРґРµ Р±С‹Р»Р° РІС‹Р·РІР°РЅР° С„СѓРЅРєС†РёСЏ). РџРµСЂРµРґР°С‡Р° Р°СЂРіСѓРјРµРЅС‚Р° РїРѕ РєРѕРЅСЃС‚Р°РЅС‚РЅРѕР№ СЃСЃС‹Р»РєРµ РЅРµ РґР°С‘С‚ РЅР°Рј РёР·РјРµРЅСЏС‚СЊ РµРіРѕ РІРЅСѓС‚СЂРё С„СѓРЅРєС†РёРё.  
  РџРµСЂРµРґР°С‡Р° РїРѕ СЃСЃС‹Р»РєРµ РЅСѓР¶РЅР°, РµСЃР»Рё РјС‹ С…РѕС‚РёРј РєР°Рє-С‚Рѕ РјРѕРґРёС„РёС†РёСЂРѕРІР°С‚СЊ РїРµСЂРµРґР°РЅРЅС‹Р№ Р°СЂРіСѓРјРµРЅС‚ РІ С„СѓРЅРєС†РёСЋ.  
  РџРµСЂРµРґР°С‡Р° РїРѕ РєРѕРЅСЃС‚Р°РЅС‚РЅРѕР№ СЃСЃС‹Р»РєРµ РЅСѓР¶РЅР°, РµСЃР»Рё РјС‹ РЅРµ С…РѕС‚РёРј РјРµРЅСЏС‚СЊ РЅР°С€ РѕР±СЉРµРєС‚ РІРЅСѓС‚СЂРё С„СѓРЅРєС†РёРё. РџСЂРё СЌС‚РѕРј, РєРѕРїРёСЂРѕРІР°С‚СЊ РµРіРѕ Р»РёС€РЅРёР№ СЂР°Р· СЃР»РёС€РєРѕРј РґРѕСЂРѕРіРѕ (РЅР°РїСЂРёРјРµСЂ РєРѕРїРёСЂРѕРІР°С‚СЊ РјР°С‚СЂРёС†Сѓ 1000 РЅР° 1000 СЌР»РµРјРµРЅС‚РѕРІ, РїРѕ РєРѕС‚РѕСЂРѕР№ РјС‹ С…РѕС‚РёРј Р»РёС€СЊ СЂР°Р·РѕРє РїСЂРѕР±РµР¶Р°С‚СЊСЃСЏ, РЅРµ СЂРµРґР°РєС‚РёСЂСѓСЏ РµС‘, С‚СѓРїРѕ, РїРѕС‚СЂР°С‚РёРј РЅР° СЌС‚Рѕ РєСѓС‡Сѓ Р»РёС€РЅРµРіРѕ РІСЂРµРјРµРЅРё), РїРѕСЌС‚РѕРјСѓ Р»СѓС‡С€Рµ РїРµСЂРµРґР°С‚СЊ РµРіРѕ РїРѕ СЃСЃС‹Р»РєРµ Рё Р·Р°РїСЂРµС‚РёС‚СЊ СЂРµРґР°РєС‚РёСЂРѕРІР°РЅРёРµ.  
  РћС‚РґРµР»СЊРЅС‹Р№ СЂР°Р·РіРѕРІРѕСЂ РїСЂРѕ РІРµСЂРјРµРЅРЅС‹Рµ РѕР±СЉРµРєС‚С‹. Р•СЃР»Рё РїРµСЂРµРґР°С‚СЊ РІСЂРµРјРµРЅС‚С‹Р№ РѕР±СЉРµРєС‚ РІ С„СѓРЅРєС†РёСЋ РєР°Рє РїР°СЂР°РјРµС‚СЂ, С‚Рѕ Р»РёР±Рѕ РїРѕ Р·РЅР°С‡РµРЅРёСЋ, Р»РёР±Рѕ РїРѕ РєРѕРЅСЃС‚Р°РЅС‚РЅРѕР№ СЃСЃС‹Р»РєРµ. РџРѕ СЃСЃС‹Р»РєРµ РЅРµ РїРѕР»СѓС‡РёС‚СЃСЏ (РѕР±С‹С‡РЅРѕ РЅРµ СЃРєРѕРјРїРёР»РёСЂСѓРµС‚СЃСЏ, РЅРѕ РјРѕР¶РЅРѕ СЌС‚Рѕ РєР°Рє-С‚Рѕ РѕР±РѕР№С‚Рё Рё РїРѕР»СѓС‡РёС‚СЊ UB). РџСЂРё РїРµСЂРµРґР°С‡Рµ РІСЂРµРјРµРЅРЅРѕРіРѕ РѕР±СЉРµРєС‚Р° РїРѕ РєРѕРЅСЃС‚Р°РЅС‚РЅРѕР№ СЃСЃС‹Р»РєРµ, РІСЂРµРјСЏ РµРіРѕ Р¶РёР·РЅРё РїСЂРѕРґР»РµРІР°РµС‚СЃСЏ.  
  ```C++
  size_t foo(const std::vector<int> &a){
      return a.size(); // 3
  }
  int main() {
      std::cout << foo({1, 2, 3});
  }
  ``` 
  РР·-Р·Р° СЌС‚РѕР№ С„РёС‡Рё Р»РµРіР°Р»СЊРЅС‹РјРё СЏРІР»СЏСЋС‚СЃСЏ Рё С‚Р°РєРёРµ РєРѕРЅСЃС‚СЂСѓРєС†РёРё, РіРґРµ РІСЂРµРјСЏ Р¶РёР·РЅРё РѕРїСЏС‚СЊ Р¶Рµ РїСЂРѕРґР»РµРІР°РµС‚СЃСЏ.  
  ```C++
  int main() {
      const std::vector<int> &a = std::vector<int>{1, 2, 3};
      std::cout << a.size(); // 3
  }
  ``` 
  * ### РџРµСЂРµРґР°С‡Р° `{}` РІ РїР°СЂР°РјРµС‚СЂС‹.  
  РљРѕРјРїРёР»СЏС‚РѕСЂ СѓРјРЅР°СЏ С€С‚СѓРєР°. РњРѕР¶РЅРѕ РїРµСЂРµРґР°РІР°С‚СЊ С‡С‚Рѕ-С‚Рѕ РІ С„РёРіСѓСЂРЅС‹С… СЃРєРѕР±РєР°С…, РѕРЅ РїРѕ РєРѕРЅС‚РµРєСЃС‚Сѓ РґРѕРіР°РґР°РµС‚СЃСЏ, С‡РµРј СЌС‚Рѕ РґРѕР»Р¶РЅРѕ Р±С‹С‚СЊ. РќР°РїСЂРёРјРµСЂ С‚СѓС‚ РѕРЅ РїСЂРµРѕР±СЂР°Р·СѓРµС‚ СЌС‚Рѕ РІ РІРµРєС‚РѕСЂ РёРЅС‚РѕРІ. Р­С‚Рѕ С‚Р°Рє РЅР°Р·С‹РІР°РµРјРѕРµ `List-initialization`. (СЃРј. СЃРѕРѕС‚РІРµС‚СЃС‚РІСѓСЋС‰РёР№ Р±РёР»РµС‚)
  ```C++
  void foo1(std::vector<int> arr){}
  int main() {
      foo1({1, 2, 3});
  }
  ```  
  * ### РќРµРёРјРµРЅРѕРІР°РЅС‹Р№ РїР°СЂР°РјРµС‚СЂ Рё `[[maybe_unused]]`  
  РќРµРёРјРµРЅРѕРІР°РЅРЅС‹Р№ РїР°СЂР°РјРµС‚СЂ РїРѕРґСЂРѕР±РЅРѕ РѕРїРёСЃР°РЅ РІС‹С€Рµ. Р’РјРµСЃС‚Рѕ РЅРµРіРѕ РјРѕР¶РЅРѕ РёСЃРїРѕР»СЊР·РѕРІР°С‚СЊ Р°СЂРіСѓРјРµРЅС‚ СЃ РєР°РєРёРј-С‚Рѕ С„РёРєС‚РёРІРЅС‹Рј РЅР°Р·РІР°РЅРёРµРј Рё РїРѕРјРµС‚РёС‚СЊ РµРіРѕ `[[maybe_unused]]`  
  РџСЂРёРІРµРґСѓ РµС‰С‘ РѕРґРёРЅ РїСЂРёРјРµСЂ, РіРґРµ СЌС‚Рѕ РёСЃРїРѕР»СЊР·СѓРµС‚СЃСЏ: С‚РµРіРё РІ Р°СЂРіСѓРјРµРЅС‚Р°С… С„СѓРЅРєС†РёРё. РњС‹ Р·Р°РІРѕРґРёРј РґРІРµ С„РёРєС‚РёРІРЅС‹Рµ СЃС‚СЂСѓРєС‚СѓСЂС‹ СЃ РіРѕРІРѕСЂСЏС‰РёРјРё РёРјРµРЅР°РјРё, РґРµР»Р°РµРј РїРµСЂРµРіСЂСѓР·РєСѓ С„СѓРЅРєС†РёРё. Р’ РѕРґРЅРѕРј РјРµСЃС‚Рµ РїРµСЂРµРґР°С‘Рј С„РёРєС‚РёРІРЅС‹Р№ РїР°СЂР°РјРµС‚СЂ С‚РёРїР° РїРµСЂРІРѕР№ СЃС‚СЂСѓРєС‚СѓСЂС‹, РІРѕ РІС‚РѕСЂРѕР№ С„СѓРЅРєС†РёРё С„РёРєС‚РёРІРЅС‹Р№ РїР°СЂР°РјРµС‚СЂ РІС‚РѕСЂРѕР№ СЃС‚СЂСѓРєС‚СѓСЂС‹.  
  ```C++
  struct multi_five{};
  struct multi_ten{};
  int foo(int a, multi_five){
      return a * 5;
  }
  int foo(int a, multi_ten){
      return a * 10;
  }
  int main() {
      foo(1, multi_five{}); // 5
      foo(1, multi_ten{}); // 10
  }
  ```  
  
* ## Р’РѕР·РІСЂР°С‰Р°РµРјРѕРµ Р·РЅР°С‡РµРЅРёРµ
  * ### Р’РѕР·РІСЂР°С‚ РїРѕ Р·РЅР°С‡РµРЅРёСЋ, СЃСЃС‹Р»РєРµ, РєРѕРЅСЃС‚Р°РЅС‚РЅРѕР№ СЃСЃС‹Р»РєРµ.  
  РџСЂРё РІРѕР·РІСЂР°С‚Рµ РїРѕ Р·РЅР°С‡РµРЅРёСЋ, РІРѕР·РІСЂР°С‰Р°РµРјС‹Р№ РѕР±СЉРµРєС‚ Р±СѓРґРµС‚ РєРѕРїРёСЂРѕРІР°С‚СЊСЃСЏ РІ РїРµСЂРµРјРµРЅРЅСѓСЋ, РєСѓРґР° РІС‹ РµРіРѕ Р·Р°РїРёС€РёС‚Рµ.  
  РџСЂРё РІРѕР·РІСЂР°С‚Рµ РїРѕ СЃСЃС‹Р»РєРµ, С„СѓРЅРєС†РёСЏ РІРѕР·РІСЂР°С‰Р°РµС‚СЃСЏ СЃСЃС‹Р»РєСѓ РЅР° РѕР±СЉРµРєС‚. РџРѕСЌС‚РѕРјСѓ СЃС‚РѕРёС‚ Р±С‹С‚СЊ Р°РєРєСѓСЂР°С‚РЅС‹Рј. Р’ СЃР»РµРґСѓСЋС‰РµРј РїСЂРёРјРµСЂРµ РїС‹С‚Р°РµРјСЃСЏ РІРµСЂРЅСѓС‚СЊ СЃСЃС‹Р»РєСѓ РЅР° Р»РѕРєР°Р»СЊРЅСѓСЋ РїРµСЂРµРјРµРЅРЅСѓСЋ, РєРѕС‚РѕСЂР°СЏ СѓР±РµСЂС‘С‚СЃСЏ СЃРѕ СЃС‚РµРєР° РїРѕСЃР»Рµ РѕРєРѕРЅС‡Р°РЅРёСЏ РІС‹РїРѕР»РЅРµРЅРёСЏ С„СѓРЅРєС†РёРё, РїРѕСЌС‚РѕРјСѓ РїРѕР»СѓС‡Р°РµРј UB.  
  ```C++
  int& foo1(int a){
      int b = a + 1;
      return b; // UB
  }
  int main() {
      int c = foo1(4);
      std:: cout << c;
  }
  ```  
  РџСЂРёРјРµРЅСЏС‚СЊ РІРѕР·СЂР°С‰РµРЅРёРµ Р·РЅР°С‡РµРЅРёСЏ РїРѕ СЃСЃС‹Р»РєРµ РјРѕР¶РЅРѕ РЅР°РїСЂРёРјРµСЂ, РµСЃР»Рё РЅР°Рј РІ РїР°СЂР°РјРµС‚СЂР°С… РїРµСЂРµРґР°Р»Рё РєР°РєРѕР№-С‚Рѕ Р°СЂРіСѓРјРµРЅС‚ РїРѕ СЃСЃС‹Р»РєРµ. РўРѕ РµСЃС‚СЊ РїРѕСЃР»Рµ РѕРєРѕРЅС‡Р°РЅРёСЏ С„СѓРЅРєС†РёРё, РѕРЅ РЅРµ Р±СѓРґРµС‚ СѓРЅРёС‡С‚РѕР¶РµРЅ, РїРѕСЌС‚РѕРјСѓ РїРѕР·РІСЂР°С‰Р°С‚СЊ РЅР° РЅРµРіРѕ СЃСЃС‹Р»РєСѓ СЃРѕРІРµСЂС€РµРЅРЅРѕ Р»РµРіР°Р»СЊРЅРѕ.  
  ```C++
  int& foo1(int &a){
      a++;
      return a; // OK
  }
  int main() {
      int c = 5;
      int &b = foo1(c); // 6
      b++; // 7
      std::cout << c; // 7
  }
  ```
  РР»Рё РЅР°РїСЂРёРјРµСЂ, РјРѕР¶РЅРѕ РІРѕР·РІСЂР°С‰Р°С‚СЊ СЃСЃС‹Р»РєСѓ РЅР° СЃС‚Р°С‚РёС‡РµСЃРєРёР№ РѕР±СЉРµРєС‚, РѕР±СЉСЏРІР»РµРЅРЅС‹Р№ РІРЅСѓС‚СЂРё С„СѓРЅРєС†РёРё.
  ```C++
  int& foo1(){
      static int a = 100;
      a++;
      return a; // OK
  }
  int main() {
      int &c = foo1();
      std::cout << c << "\n"; // 101
      foo1();
      std::cout << c << "\n"; // 102
  }
  ```  
  РќСѓ Рё РјРѕР¶РЅРѕ РІРѕР·РІСЂР°С‰Р°С‚СЊ РєРѕРЅСЃС‚Р°РЅС‚РЅС‹Рµ СЃСЃС‹Р»РєРё. Р’СЃС‘ СЂР°Р±РѕС‚Р°РµС‚ РёРЅС‚СѓРёС‚РёРІРЅРѕ.  
  ```C++
  const int& foo1(int &a){
      a++;
      return a; // OK
  }
  int main() {
      int c = 5;
      const int &b = foo1(c); // 6
      b++; // Compilation error
  }
  ```
  * ### Р’РѕР·РІСЂР°С‚ `{}`.  
  Р’РѕР·РІСЂР°С‰РµРЅРёРµ РёР· С„СѓРЅРєС†РёРё `{}` РІРѕР·РјРѕР¶РЅРѕ С‚РѕР»СЊРєРѕ РµСЃР»Рё РІРѕР·РІСЂР°С‰Р°С‚СЊ С‡С‚Рѕ-С‚Рѕ РїРѕ Р·РЅР°С‡РµРЅРёСЋ (РЅСѓ РѕС‡РµРІРёРґРЅРѕ, РЅРµ РїРѕРЅСЏС‚РЅРѕ С‡С‚Рѕ Р±С‹ РѕР·РЅР°С‡Р°Р»Рѕ РІРµСЂРЅСѓС‚СЊ СЃСЃС‹Р»РєСѓ РЅР° РїСѓСЃС‚С‹Рµ СЃРєРѕР±РєРё. Р­С‚Рѕ РїСЂРѕСЃС‚Рѕ РЅРµ СЃРєРѕРјРїРёР»РёС‚СЃСЏ). Р’ СЌС‚РѕРј СЃР»СѓС‡Р°Рµ, РІС‹Р·РѕРІРѕРІРµС‚СЃСЏ Default initialization Сѓ СЌР»РµРјРµРЅС‚Р° РІРѕР·РІСЂР°С‰Р°РµРјРѕРіРѕ С‚РёРїР°. РўРѕ РµСЃС‚СЊ РµСЃР»Рё С„СѓРЅРєС†РёСЏ РѕС‚ РёРЅС‚Р°, С‚Рѕ РІРµСЂРЅС‘С‚СЃСЏ 0.  
   ```C++
  int foo1(){
      return {};
  }
  int main() {
      std::cout << foo1(); // 0
  }
  ```
  * ### `[[nodiscard]]`, РІРѕР·РјРѕР¶РЅС‹Рµ СЃС‚СЂР°С‚РµРіРёРё РїСЂРёРјРµРЅРµРЅРёСЏ: РєРѕРіРґР° РЅРµ РёРјРµРµС‚ СЃРјС‹СЃР»Р° РёРіРЅРѕСЂРёСЂРѕРІР°С‚СЊ РІРѕР·РІСЂР°С‰Р°РµРјРѕРµ Р·РЅР°С‡РµРЅРёРµ, РєРѕРіРґР° РёРіРЅРѕСЂРёСЂРѕРІР°С‚СЊ РѕРїР°СЃРЅРѕ  
  РќР°РїСЂРёРјРµСЂ, РѕРїР°СЃРЅРѕ РёРіРЅРѕСЂРёСЂРѕРІР°С‚СЊ РІРѕР·РІСЂР°С‰Р°РµРјС‹Р№ РѕР±СЉРµРєС‚ РєР°РєРѕР№-С‚Рѕ СЃС‚СЂСѓРєС‚СѓСЂС‹. Р•СЃР»Рё РјС‹ РёСЃРїРѕР»СЊР·РѕРІР°Р»Рё РІРЅСѓС‚СЂРё С„СѓРЅРєС†РёРё Dynamic storage duration, Рё РІРѕР·РІСЂР°С‰Р°РµРј РєР°РєРѕР№-С‚Рѕ РѕР±СЉРµРєС‚, РІ РїСЂРµРґРїРѕР»РѕР¶РµРЅРёРё С‡С‚Рѕ РµРіРѕ РїРѕСЃР»Рµ РЅСѓР¶РЅРѕ РїСѓРґРµС‚ СѓРґР°Р»РёС‚СЊ. Р•СЃР»Рё Р¶Рµ РјС‹ РµРіРѕ РЅРёРєСѓРґР° РЅРµ СЃРѕС…СЂР°РЅРёРј, РїСЂРѕРёР·РѕР№РґС‘С‚ СѓС‚РµС‡РєР° РїР°РјСЏС‚Рё. РРјРµРµС‚ СЃРјС‹СЃР» Р·Р°РїСЂРµС‰Р°С‚СЊ РёРіРЅРѕСЂРёСЂРѕРІР°С‚СЊ РІРѕР·РІСЂР°С‰Р°РµРјРѕРµ Р·РЅР°С‡РµРЅРёРµ, РЅР°РїСЂРёРјРµСЂ РµСЃР»Рё РјС‹ РїРµСЂРµРѕРїСЂРµРґРµР»СЏРµРј РєР°РєРѕР№-С‚Рѕ Р°СЂРёС„РјРµС‚РёС‡РµСЃРєРёР№ РѕРїРµСЂР°С‚РѕСЂ, РєР°Рє `+` РІ `bigint`. (Р РµС‡СЊ РёРґС‘С‚ Рѕ `C-style pointer`, СЃ `unique_ptr` РІСЃС‘ РЅРѕСЂРјР°Р»СЊРЅРѕ Р±СѓРґРµС‚, РѕРЅ РїРѕС‡РёСЃС‚РёС‚СЃСЏ).  
  РўР°Рє Р¶Рµ РµСЃР»Рё С„СѓРЅРєС†РёСЏ РЅРёС‡РµРіРѕ РЅРµ РјРµРЅСЏРµС‚ РІРЅРµ СЃРµР±СЏ, С‚Рѕ СЃРёС‚СѓР°С†РёСЏ, РєРѕРіРґР° РјС‹ РЅРёРєСѓРґР° РЅРµ СЃРѕС…СЂР°РЅРёР»Рё РµС‘ Р·РЅР°С‡РµРЅРёРµ РѕР·РЅР°С‡Р°РµС‚, С‡С‚Рѕ РјС‹ РїРѕРїСЂРѕСЃС‚Сѓ РІРїСѓСЃС‚СѓСЋ РїРѕС‚СЂР°С‚РёР»Рё РІСЂРµРјСЏ РЅР° РµС‘ РІС‹РїРѕР»РЅРµРЅРёРµ, Рё СЌС‚Рѕ РЅРµ РґРµР»Рѕ.  
  РР»Рё РµСЃР»Рё С„СѓРЅРєС†РёСЏ СЃРІСЏР·Р°РЅР° СЃ РѕР±СЂР°Р±РѕС‚РєРѕР№ РѕС€РёР±РєРё, С‚Рѕ РёРґРµР№РЅРѕ РјС‹ РѕР±СЏР·Р°РЅС‹ РєР°Рє-С‚Рѕ РёСЃРїРѕР»Р·РѕР»СЊР·РѕРІР°С‚СЊ РІРѕР·РІСЂР°С‰Р°РµРјРѕРµ РµР№ Р·РЅР°С‡РµРЅРёРµ.  
* ## РџРµСЂРµРіСЂСѓР·РєР° С„СѓРЅРєС†РёР№:
  * ### Р§С‚Рѕ РІС…РѕРґРёС‚ РІ СЃРёРіРЅР°С‚СѓСЂСѓ, С‡С‚Рѕ РЅРµ РІС…РѕРґРёС‚ (РЅР°РїСЂРёРјРµСЂ, Р·РЅР°С‡РµРЅРёРµ РїРѕ СѓРјРѕР»С‡Р°РЅРёСЋ).  
  РЎРёРіРЅР°С‚СѓСЂР° С„СѓРЅРєС†РёРё РІРєР»СЋС‡Р°РµС‚ РёРјСЏ С„СѓРЅРєС†РёРё, Р° С‚Р°РєР¶Рµ РєРѕР»РёС‡РµСЃС‚РІРѕ, РїРѕСЂСЏРґРѕРє Рё С‚РёРї РµРµ С„РѕСЂРјР°Р»СЊРЅС‹С… РїР°СЂР°РјРµС‚СЂРѕРІ.  
  Р”РІРµ РїРµСЂРµРіСЂСѓР¶РµРЅРЅС‹Рµ С„СѓРЅРєС†РёРё РЅРµ РґРѕР»Р¶РЅС‹ РёРјРµС‚СЊ РѕРґРёРЅР°РєРѕРІСѓСЋ СЃРёРіРЅР°С‚СѓСЂСѓ.  
  Р’РѕР·РІСЂР°С‰Р°РµРјРѕРµ Р·РЅР°С‡РµРЅРёРµ РЅРµ СЏРІР»СЏРµС‚СЃСЏ С‡Р°СЃС‚СЊСЋ СЃРёРіРЅР°С‚СѓСЂС‹ С„СѓРЅРєС†РёРё.  
  Р”РІРµ СЌС‚Рё С„СѓРЅРєС†РёРё РёРјРµСЋС‚ РѕРґРёРЅР°РєРѕРІСѓСЋ СЃРёРіРЅР°С‚СѓСЂСѓ:  
  ```C++
  int Divide (int n, int m) ; 
  double Divide (int n, int m) ;
  ```
  * РўРёРїС‹-С‚СЌРіРё РґР»СЏ РїРѕСЏСЃРЅРµРЅРёР№ Рє РїРµСЂРµРіСЂСѓР·РєР°Рј (04-210923/01-functions/04-tags)
  РџРѕСЏСЃРЅРёР» Р·Р° С‚СЌРіРё РІ РїСѓРЅРєС‚Рµ РїСЂРѕ Р±РµР·С‹РјСЏРЅРЅС‹Рµ Рё `[[maybe_unused]]`Р°СЂРіСѓРјРµРЅС‚С‹.  
  * ### РЎРёРЅС‚Р°РєСЃРёСЃ `= delete` СЃ C++11.  
  Р•СЃР»Рё РјС‹ С…РѕС‚РёРј Р·Р°РїСЂРµС‚РёС‚СЊ, РЅР°РїСЂРёРјРµСЂ РєРѕРїРёСЂСѓСЋС‰РёР№ РєРѕРЅСЃС‚СЂСѓРєС‚РѕСЂ, РјРѕР¶РµРј РІРѕСЃРїРѕР»СЊР·РѕРІР°С‚СЊСЃСЏ РєРѕРЅСЃС‚СЂСѓРєС†РёРµР№ = delete: С‡С‚РѕР±С‹ РїРѕРјРµС‚РёС‚СЊ РёС… РєР°Рє СѓРґР°Р»РµРЅРЅС‹Рµ С„СѓРЅРєС†РёРё.  
  ```C++
  unique_ptr(const unique_ptr&) = delete;
  unique_ptr& operator=(const unique_ptr&) = delete;
  ```
  РћС‚Р»РёС‡РёРµ СѓРґР°Р»РµРЅРёСЏ СЌС‚РёС… С„СѓРЅРєС†РёР№ РѕС‚ РёС… РѕР±СЉСЏРІР»РµРЅРёСЏ РєР°Рє private.РЈРґР°Р»РµРЅРЅС‹Рµ С„СѓРЅРєС†РёРё РЅРµ РјРѕРіСѓС‚ РёСЃРїРѕР»СЊР·РѕРІР°С‚СЊСЃСЏ РЅРёРєРѕРёРј РѕР±СЂР°Р·РѕРј, С‚Р°Рє С‡С‚Рѕ РґР°Р¶Рµ РєРѕРґ С„СѓРЅРєС†РёРёС‡Р»РµРЅР° РёР»Рё С„СѓРЅРєС†РёР№, РѕР±СЉСЏРІР»РµРЅРЅС‹С… РєР°Рє friend, РЅРµ Р±СѓРґРµС‚ РєРѕРјРїРёР»РёСЂРѕРІР°С‚СЊСЃСЏ, РµСЃР»Рё РїРѕРїС‹С‚Р°РµС‚СЃСЏ.  
  РўР°Рє Р¶Рµ РјРѕР¶РЅРѕ Р·Р°РїСЂРµС‰Р°С‚СЊ РїРµСЂРµРіСЂСѓР¶Р°С‚СЊ РјРµС‚РѕРґ:  
  ```C++
  void foo(int x) {
      std::cout << "foo(" << x << ")\n";
  }

  void foo(double) = delete;  // Last step: if chosen by overload resolution, fail compilation.
  ```
  * ### РџСЂРѕР±Р»РµРјС‹ СЃ СЂР°Р·РґРµР»РµРЅРёРµРј `nullptr`, `NULL`, `0`.  
  nullptr: СЌС‚Рѕ РѕС‚РґРµР»СЊРЅС‹Р№ С‚РёРї, Р° РІРѕС‚ 0/NULL вЂ” СЌС‚Рѕ РёРЅС‚С‹. РџРѕСЌС‚РѕРјСѓ СЃ РїРµСЂРµРіСЂСѓР·РєР°РјРё Р±РµРґР°. Р Р°Р·Р»РёС‡РёРµ РјРµР¶РґСѓ NULL Рё 0 С‡Р°С‰Рµ РІСЃРµРіРѕ РїСЂР°РєС‚РёС‡РµСЃРєРё РЅРёРєР°РєРѕРіРѕ - (РёРґРµРѕР»РѕРіРёС‡РµСЃРєРё NULL РїРѕРєР°Р·С‹РІР°РµС‚, С‡С‚Рѕ С‚Р°Рј РїСѓСЃС‚Рѕ.  
  `#define NULL 0` //С‡Р°С‰Рµ РІСЃРµ СЌС‚Рѕ РёРјРµРЅРЅРѕ С‚Р°Рє Рё РµСЃС‚СЊ  
  `nullptr` - Р·РЅР°С‡РёС‚ С‡С‚Рѕ РЅРё РЅР° С‡С‚Рѕ РЅРµ СѓРєР°Р·С‹РІР°РµС‚ - РЅРµРѕР±С…РѕРґРёРјРѕ РёСЃРїРѕР»СЊР·РѕРІР°С‚СЊ РґР»СЏ СѓРєР°Р·Р°С‚РµР»РµР№
  ```C++
  int *a=nullptr;
  *a; //UB!!!
  ```
  РџРѕСЃР»Рµ 11 РїР»СЋСЃРѕРІ СЃ РІР·Р°РёРјРЅРѕР·Р°РјРµРЅСЏРµРјРѕСЃС‚СЊСЋ СЌС‚РёС… С‚СЂС‘С… С€С‚СѓРє РїРѕР»РЅР°СЏ Р»Р°Р¶Р°, С‚Р°Рє С‡С‚Рѕ `NULL` РЅРµ СЃС‚РѕРёС‚ РёСЃРїРѕР»СЊР·РѕРІР°С‚СЊ РІРѕРѕР±С‰Рµ РЅРёРєРѕРіРґР°.
  * ### РќРµ Р±С‹Р»Рѕ: `noexcept`.
  * ### РќРµ Р±С‹Р»Рѕ: РїСЂР°РІРёР» РІС‹Р±РѕСЂР° РїРµСЂРµРіСЂСѓР·РєРё С‚РѕС‡РЅРµРµ "РІС‹Р±РёСЂР°РµС‚СЃСЏ РїРµСЂРµРіСЂСѓР·РєР° РЅР°РёР±РѕР»РµРµ С‚РѕС‡РЅР°СЏ РёР»Рё ambiguous".
* ## РЈРєР°Р·Р°С‚РµР»Рё РЅР° С„СѓРЅРєС†РёРё: СЃРёРЅС‚Р°РєСЃРёСЃ, РёСЃРїРѕР»СЊР·РѕРІР°РЅРёРµ.
  * ### РќРµ Р±С‹Р»Рѕ: РєРѕРЅРІРµСЂСЃРёРё РјРµР¶РґСѓ СѓРєР°Р·Р°С‚РµР»СЏРјРё, С‡С‚Рѕ РїСЂРѕРёСЃС…РѕРґРёС‚ СЃ РїРµСЂРµРіСЂСѓР·РєР°РјРё.

РўРµСЃРЅРѕ СЃРІСЏР·Р°РЅРѕ СЃ: РјРµС‚РѕРґС‹.
</details>

<details>
<summary>
 Р–РёР·РЅСЊ РѕР±СЉРµРєС‚РѕРІ
</summary>


### РЎРµРјР°РЅС‚РёРєР° РєРѕРїРёСЂРѕРІР°РЅРёСЏ

Р’ C++ РїРѕ СѓРјРѕР»С‡Р°РЅРёСЋ РїСЂРё РїСЂРёСЃРІР°РёРІР°РЅРёРё РѕР±СЉРµРєС‚Р° / 
РїРµСЂРµРґР°С‡Рµ РѕР±СЉРµРєС‚Р° РІ С„СѓРЅРєС†РёСЋ РёР»Рё РІРѕР·РІСЂР°С‚Рµ РёР· С„СѓРЅРєС†РёРё РѕР¶РёРґР°РµС‚СЃСЏ, С‡С‚Рѕ РѕР±СЉРµРєС‚ Р±СѓРґРµС‚ СЃРєРѕРїРёСЂРѕРІР°РЅ Рё 
РёР·РјРµРЅРµРЅРёСЏ, РїСЂРѕРёР·РѕС€РµРґС€РёРµ СЃ РєРѕРїРёРµР№ РЅРµ РјСѓС‚РёСЂСѓСЋС‚ СЃР°Рј РѕР±СЉРµРєС‚.

РџСЂРё СЌС‚РѕРј СЃСѓС‰РµСЃС‚РІСѓРµС‚ СЃРїРѕСЃРѕР± СЃРѕР·РґР°С‚СЊ СЃСЃС‹Р»РєСѓ РЅР° РѕР±СЉРµРєС‚, С‚Рѕ РµСЃС‚СЊ РґРѕР±Р°РІРёС‚СЊ РЅРѕРІРѕРµ РёРјСЏ РґР»СЏ СЂРѕРІРЅРѕ С‚РѕРіРѕ Р¶Рµ РѕР±СЉРµРєС‚Р° РІ РїР°РјСЏС‚Рё.
Р”Р»СЏ СЌС‚РѕРіРѕ РёРјРїРѕР»СЊР·СѓРµС‚СЃСЏ СЃРёРЅС‚Р°РєСЃРёСЃ `Type &refer = ....;`, С„СѓРЅРєС†РёРё С‚Р°РєР¶Рµ РјРѕРіСѓС‚ РїСЂРёРЅРёРјР°С‚СЊ Р°СЂРіСѓРјРµРЅС‚С‹ РїРѕ СЃСЃС‹Р»РєРµ. 
РџСЂРё РІРѕР·РІСЂР°С‰РµРЅРёРё СЃСЃС‹Р»РєРё РёР· С„СѓРЅРєС†РёРё РЅСѓР¶РЅРѕ Р±С‹С‚СЊ РѕС‡РµРЅСЊ РѕСЃС‚РѕСЂРѕР¶РЅС‹Рј - Р»РѕРєР°Р»СЊРЅС‹Рµ РїРµСЂРµРјРµРЅРЅС‹Рµ СѓРјРёСЂР°СЋС‚ РїСЂРё Р·Р°РІРµСЂС€РµРЅРёРё С„СѓРЅРєС†РёРё, 
РІРѕР·РЅРёРєР°РµС‚ dangling reference - СЃСЃС‹Р»РєР° РЅР° СѓРјРµСЂС€РёР№ РѕР±СЉРµРєС‚. РћР±СЂР°С‰РµРЅРёРµ РїРѕ РЅРµР№ - UB. [stackowerflow](https://stackoverflow.com/questions/46011510/what-is-a-dangling-reference)


```c++
void foo(std::vector<int> a) {
    a.push_back(1);
    std::cout << a.size(); 
} 

void bar(std::vector<int>& a) {
    a.push_back(1);
    std::cout << a.size();                                  
} 


int main() {
    std::vector<int> a{0};
    foo(a); // 2
    std::cout << a.size(); // 1 
    bar(a); // 2
    std::cout << a.size(); // 2  
    return 0;
}
```

РџСЂРёРјРµСЂ СЃ dangling reference

```c++
#include <iostream>
#include <vector>

std::vector<int>& foo() {
    std::vector<int> vec{1, 2, 3};
    return vec;
}

int main() {
    std::vector<int> vec = foo();
    std::cout << vec.size() << "\n"; // UB
}
```

### Storage duration

Storage duration - С…Р°СЂР°РєС‚РµСЂРёСЃС‚РёРєР° РѕР±СЉРµРєС‚РѕРІ, РѕРїРёРёСЃР°РЅРёРµ РёС… РІСЂРµРјРµРЅРё Р¶РёР·РЅРё - РјРѕРјРµРЅС‚Р°, РєРѕРіРґР° РѕРЅРё СЃРѕР·РґР°СЋС‚СЃСЏ Рё СѓРјРёСЂР°СЋС‚.
[cppreference](https://en.cppreference.com/w/cpp/language/storage_duration) - РїРѕР»РЅРѕРµ РѕРїРёСЃР°РЅРёРµ.
РњС‹ СЂР°СЃСЃРјР°С‚СЂРёРІР°РµРј automatic, static Рё dynamic.

#### Automatic storage duration

РќР°РёР±РѕР»РµРµ СЂР°СЃРїСЂРѕСЃС‚СЂР°РЅС‘РЅРЅР°СЏ storage duration - РјС‹ СЃРѕР·РґР°С‘Рј РѕР±СЉРµРєС‚ РїСЂРё РїСЂРѕС…РѕРґРµ С‡РµСЂРµР· РѕР±СЉСЏРІР»РµРЅРёРµ РїРµСЂРµРјРµРЅРЅРѕР№ - РµС‘ Р·РЅР°С‡РµРЅРёРµ 
(РѕР±С‹С‡РЅРѕ РѕРЅРѕ РєР»Р°РґС‘С‚СЃСЏ РЅР° СЃС‚СЌРє, РЅРѕ СЃС‚Р°РЅРґР°СЂС‚ СЌС‚Рѕ РЅРёРєР°Рє РЅРµ РѕРіРѕРІР°СЂРёРІР°РµС‚). РћР±СЉРµРєС‚ СѓРјРёСЂР°РµС‚, РєРѕРіРґР° СЌС‚Р° РїРµСЂРµРјРµРЅРЅР°СЏ 
СЃС‚Р°РЅРѕРІРёС‚СЃСЏ РЅРµРІРёРґРёРјРѕР№ РЅР°РІСЃРµРіРґР° (shadowing РЅРµ СЃС‡РёС‚Р°РµС‚СЃСЏ, С‚.Рє. РІ РєР°РєРѕР№-С‚Рѕ РјРѕРјРµРЅС‚ РїРµСЂРµРјРµРЅРЅС‹Рµ СЃРЅРѕРІР° СЃС‚Р°РЅРѕРІСЏС‚СЃСЏ РІРёРґРёРјС‹РјРё).
РЈ РїРѕР»РµР№ СЃС‚СЂСѓРєС‚СѓСЂС‹ СЃ automatic storage duration - С‚Р°РєРѕР№ Р¶Рµ storage duration. 

```c++
int main() {
    std::vector<int> v;                    // (1) - created

    for (int i = 0; i < 10; i++) {
        std::vector<int> v;                // (2) - created (10 times)
        if (i % 2 == 0) {
             break;                        // (2) - deleted
        }
    }                                      // (2) - deleted
    v.push_back(1);                      
    return 0;                              // (1) deleted
}


```

#### Static storage duration

РџРµСЂРµРјРµРЅРЅС‹Рµ РёРЅРёС†РёР°Р»РёР·РёСЂСѓСЋС‚СЃСЏ РІ РєР°РєРѕР№-С‚Рѕ РјРѕРјРµРЅС‚ Рё Р¶РёРІСѓС‚ РґРѕ РѕРєРѕРЅС‡Р°РЅРёСЏ РІСЃРµР№ РїСЂРѕРіСЂР°РјРјС‹. РћСЃРЅРѕРІРЅРѕР№ РїСЂРёРјРµСЂ -
РіР»РѕР±Р°Р»СЊРЅС‹Рµ РїРµСЂРµРјРµРЅРЅС‹Рµ. РњРѕР¶РЅРѕ СЃРѕР·РґР°С‚СЊ Рё Р»РѕРєР°Р»СЊРЅС‹Рµ РѕР±СЉРµРєС‚С‹ СЃ С‚Р°РєРёРј Р¶Рµ storage duration - РґР»СЏ СЌС‚РѕРіРѕ
РёС… РЅСѓР¶РЅРѕ РїРѕРјРµС‚РёС‚СЊ `static Type var;`. РћРЅРё РёРЅС†РёР°Р»РёР·РёСЂСѓСЋС‚СЃСЏ С‚РѕР»СЊРєРѕ РїСЂРё РїРµСЂРІРѕРј РїСЂРѕС…РѕР¶РґРµРЅРёРё С‡РµСЂРµР· СЃС‚СЂРѕС‡РєСѓ СЃ РёС…
РѕР±СЉСЏРІР»РµРЅРµРј, Р° Р·Р°С‚РµРј СЃСѓС‰РµСЃС‚РІСѓСЋС‚ РґРѕ РєРѕРЅС†Р° РІС‹РїРѕР»РЅРµРЅРёСЏ РїСЂРѕРіСЂР°РјРјС‹. РџСЂРё РёС… РёРЅРёС†РёР°Р»РёР·Р°С†РёРё РґРѕСЃС‚СѓРїРЅС‹ РІСЃРєРµ РІРёРґРёРјС‹Рµ РѕР±СЉРµРєС‚С‹, 
СЃСѓС‰РµСЃС‚РІСѓСЋС‰РёРµ РІ СЌС‚РѕС‚ РјРѕРјРµРЅС‚ (РІ С‡Р°СЃС‚РЅРѕСЃС‚Рё - Р°СЂРіСѓРјРµРЅС‚С‹ С„СѓРЅРєС†РёРё, РІ РєРѕС‚РѕСЂРѕР№ РѕРЅРё СЃРѕР·РґР°РЅС‹).

```c++
std::vector foo(1000, 0);                 // (1) - created before main

int count(int start) {
    static int current = start;           // (2) - Created on first call; 
    return current++;
}

int bad_counter(int b){
    static int a{};                       // (3) Value-initialzation on first call
    a = b;                                // assigment on every call
    return a++;                                
}

int main() {
    foo.push_back(0);
    std::cout << count(5) << std::endl;           // 5
    std::cout << count(5) << std::endl;           // 6
    std::cout << count(0) << std::endl;           // 7
    std::cout << count(101) << std::endl;         // 8
    std::cout << bad_counter(5) << std::endl;     // 5
    std::cout << bad_counter(5) << std::endl;     // 5
    std::cout << bad_counter(0) << std::endl;     // 0
    std::cout << bad_counter(101) << std::endl;   // 101
}

```

РћР±С‹С‡РЅРѕ С‚Р°РєРёРµ РїРµСЂРµРјРµРЅРЅС‹Рµ РїРѕРјРµС‰Р°СЋС‚СЃСЏ РІ РѕР±Р»Р°СЃС‚СЊ РіР»РѕР±Р°Р»СЊРЅС‹С… РїРµСЂРµРјРµРЅРЅС‹С…, РїРѕСЌС‚РѕРјСѓ РЅР° РїСЂР°РєС‚РёРєРµ РёРјРµРµС‚ СЃРјС‹СЃР» СЃРѕР·РґР°РІР°С‚СЊ
Р±РѕР»СЊС€РёРµ РѕР±СЉРµРєС‚С‹ РёРјРµРЅРЅРѕ С‚Р°РєРёРј СЃРїРѕСЃРѕР±РѕРј, С‡С‚РѕР±С‹ РЅРµ С‚СЂР°С‚РёС‚СЊ РїР°РјСЏС‚СЊ РЅР° СЃС‚СЌРєРµ.

Р—РґРµСЃСЊ РјРѕР¶РЅРѕ РІСЃС‚СЂРµС‚РёС‚СЊ РІСЃРµ РїСЂРѕР±Р»РµРјС‹, СЃРІСЏР·Р°РЅРЅС‹Рµ СЃ SIOF [Р±РёР»РµС‚ 33](https://github.com/khbminus/CppTickets/blob/master/tickets/ticket33.md).
РџСЂРѕ РїРѕСЂСЏРґРѕРєСЃ (РёР»Рё РµРіРѕ РѕС‚СЃСѓС‚СЃРІРёРµ РёРЅРёС†РёР°Р»РёР·Р°С†РёРё С‚Р°РєРёС… РїРµСЂРµРјРµРЅРЅС‹С… РјРѕР¶РЅРѕ РїРѕС‡РёС‚Р°С‚СЊ [С‚СѓС‚](https://en.cppreference.com/w/cpp/language/initialization#Non-local_variables))
Рё РІ Р±РёР»РµС‚Рµ РїСЂРѕ РёРЅРёС†РёР°Р»РёР·Р°С†РёСЋ


#### Dynamic storage duration

РџСЂРѕРіСЂР°РјРјР° СЃР°РјР° РїРѕР»РЅРѕСЃС‚СЊСЋ СѓРїСЂР°РІР»СЏРµС‚ РІСЂРµРјРµРЅРµРј Р¶РёР·РЅРё. РџСЂРё РІС‹Р·РѕРІРµ РѕРїРµСЂР°С‚РѕСЂР° `new Type;` - СЃРѕР·РґР°С‘С‚СЃСЏ
РѕР±СЉРµРєС‚, Р·РЅР°С‡РµРЅРёРµ СЌС‚РѕРіРѕ РІС‹СЂР°Р¶РµРЅРёСЏ - СѓРєР°Р·Р°С‚РµР»СЊ РЅР° РЅРµРіРѕ. Р”Р»СЏ С‚РѕРіРѕ, С‡С‚РѕР±С‹С‹ СѓРЅРёС‡С‚РѕР¶РёС‚СЊ РѕР±СЉРµРєС‚ РёСЃРїРѕР»СЊР·СѓРµС‚СЃСЏ
`delete ptr;`.

РџСЂРё РїРѕРїС‹С‚РєРµ СѓРґР°Р»РёС‚СЊ РѕР±СЉРµРєС‚ 2 СЂР°Р·Р° РёР»Рё СѓРґР°Р»РёС‚СЊ РѕР±СЉРµРєС‚, СЃРѕР·РґР°РЅС‹Р№ РЅРµ РїСЂРё РїРѕРјРѕС‰Рё РѕРїСЂРµС‚Р°РѕСЂР° `new` - 
РІРѕР·РЅРёРєР°РµС‚ UB.
              
```c++

struct Foo {
    std::vector<int> vec(100);
}

int main() {
    Foo *ptr = new Foo;
    int bar;
    std::cout << ptr->vec.size() << std::cout;
    delete ptr; // To avoid memory leak
    //delete ptr; // Double free - UB; 
    //delete &bar; // UB;
}

```

РќРµРѕСЃРІРѕР±РѕР¶РґС‘РЅРЅР°СЏ РїР°РјСЏС‚СЊ Р¶РёРІС‘С‚ РґРѕ РѕРєРѕРЅС‡Р°РЅРёСЏ РїСЂРѕРіСЂР°РјРјС‹ - РґР°Р»СЊС€Рµ СЃРѕРІСЂРµРјРµРЅРЅС‹Рµ РћРЎ РµС‘ РѕСЃРІРѕР±РѕР¶РґР°СЋС‚. РўР°РєР°СЏ СЃРёС‚СѓР°С†РёСЏ РЅР°Р·С‹РІР°РµС‚СЃСЏ СѓС‚РµС‡РєРѕР№ РїР°РјСЏС‚Рё, 
РѕРЅР° РјРѕР¶РµС‚ РІС‹Р·РІР°С‚СЊ РѕС‚Р»РѕР¶РµРЅРЅС‹Рµ РїСЂРѕР±Р»РµРјС‹.

Р•СЃС‚СЊ С†РµР»С‹Р№ Р·РѕРѕРїР°СЂРє new/delete; 

РњРѕР¶РЅРѕ РІС‹РґРµР»СЏС‚СЊ С†РµР»С‹Рµ РјР°СЃСЃРёРІС‹ РїСЂРё РїРѕРјРѕС‰Рё `new Type[n]` - РІ С‚Р°РєРѕРј СЃР»СѓС‡Р°Рµ РѕСЃРІРѕР±РѕР¶РґР°С‚СЊ РїР°РјСЏС‚СЊ СЃР»РµРґСѓРµС‚ РїСЂРё РїРѕРјРѕС‰Рё `delete[] ptr` - 
РёРЅР°С‡Рµ UB (Р’ С‚РѕРј С‡РёСЃР»Рµ РїСЂРё РїРѕРїС‹С‚РєРµ СЃРґРµР»Р°С‚СЊ `delete ptr;`). 

Р”Р»СЏ new СЂР°Р±РѕС‚Р°РµС‚ РјРЅРѕРіРѕ РёРЅРёС†РёР°Р»РёР·Р°С†РёР№:

* default - `new Type`
* default - `new Type()`
* default - `new Type{}`
* direct - `new Type(10)`
* direct list - `new Type{10}`

* РРЅРёС†РёР°Р»РёР·Р°С†РёСЏ РјР°СЃСЃРёРІРѕРІ - `new Foo[n]{val1, val2, val3}` - РЅРµРёРЅРёС†РёР°Р»РёР·РёСЂРѕРІР°РЅРЅС‹Рµ РёРЅРёС†РёР°Р»РёР·РёСЂСѓСЋС‚СЃСЏ РїРѕ СѓРјРѕР»С‡Р°РЅРёСЋ.




### Р’СЂРµРјСЏ Р¶РёР·РЅРё РІСЂРµРјРµРЅРЅС‹С… РѕР±СЉРµРєС‚РѕРІ

Р’СЂРµРјРµРЅРЅС‹Рµ РѕР±СЉРµРєС‚С‹ СѓРјРёСЂР°СЋС‚ РїРѕ Р·Р°РІРµСЂС€РµРЅРёРё РІС‹С‡РјСЃР»РµРЅРёСЏ РІС‹СЂР°Р¶РµРЅРёСЏ РіРґРµ РѕРЅРё РІРѕР·РЅРёРєР»Рё, РЅРѕ РїСЂРё СЌС‚РѕРј РµСЃР»Рё СЃРѕР·РґР°С‚СЊ
РєРѕРЅСЃС‚Р°РЅС‚РЅСѓСЋ СЃСЃС‹Р»РєСѓ РЅР° РІСЂРµРјРµРЅРЅС‹Р№ РѕР±СЉРµРєС‚, РµРіРѕ РІСЂРµРјСЏ Р¶РёР·РЅРё РїСЂРѕРґР»РёС‚СЃСЏ, С‡С‚РѕР±С‹ СЃРѕРѕС‚РІРµС‚СЃРІРѕРІР°С‚СЊ РІСЂРµРјРµРЅРё Р¶РёР·РЅРё СЌС‚РѕР№ СЃСЃС‹Р»РєРё.

Р’Р°Р¶РЅРѕ, С‡С‚Рѕ СЌС„С„РµРєС‚ С‚РµСЂСЏРµС‚СЃСЏ, РµСЃР»Рё РјС‹ РёРЅРёС†РёР°Р»РёР·РёСЂСѓРµРј РЅРѕРІСѓСЋ СЃСЃС‹Р»РєСѓ РЅР° РІСЂРµРјРµРЅРЅС‹Р№ РѕР±СЉРµРєС‚ СЃС‚Р°СЂРѕР№.


```c++

const std::vector<int> &first = std::vectorP{0, 0, 0};
std::cout << first.size() << std::endl; // NO UB
 ....
// maybe another scope
const std::vector<int> &second = first; // would have been dangling if lifetime of second had been wider than lifetime of first;     
}
```

Р­С‚Рѕ РјРѕР¶РµС‚ РёРјРµС‚СЊ Р·РЅР°С‡РµРЅРёРµ, РµСЃР»Рё 


```c++
int const& func(int const& x) {
    return x;
} 


int main() {
    const int &first = func(1);
    std::cout << first; // UB
}
```
С‚.Рє. РІСЂРµРјСЏ Р¶РёР·РЅРё РѕР±СЉРµРєС‚Р° РїСЂРѕРґР»РµРІР°РµС‚СЃСЏ С‚РѕР»СЊРєРѕ РґРѕ РІСЂРµРјРµРЅРё Р¶РёР·РЅРё x. x - РёСЃС‡РµР·Р°РµС‚ РїРѕСЃР»Рµ Р·Р°РІРµСЂС€РµРЅРёСЏ РІС‹С‡РёСЃР»РµРЅРёСЏ С„СѓРЅРєС†РёРё.

РџРѕРґРѕР±РЅРѕРµ РјРѕР¶РЅРѕ РІСЃС‚СЂРµС‚РёС‚СЊ Рё РІ STL - С„СѓРЅРєС†РёСЏ std::min - РїСЂРёРЅРёРјР°РµС‚ Рё РІРѕР·РІСЂР°С‰Р°РµС‚ СЃСЃС‹Р»РєРё

```c++
int main() {
    const auto &val = std::min(0, 1); // Dangling reference
}
```
[РЅСѓ РёР»Рё РїСЂРѕР±Р»РµРјС‹ range-based for СЃРІСЏР·Р°РЅРЅР°СЏ СЃ С‚РµРј, С‡С‚Рѕ РµРіРѕ СЂР°СЃСЃР°С…Р°СЂРёРІР°РЅРёРµ - РЅРµСЃРєРѕР»СЊРєРѕ РІС‹СЂР°Р¶РµРЅРёР№](https://github.com/Nekrolm/ubbook/blob/master/lifetime/for_loop.md) 
</details>

<details>
<summary>
</summary>


## Содержание

Каждый указатель относится к одному из 4 видов:
1. Указатель на объект или функцию.
2. Указатель на память следующую за последним элементом объекта.
3. Нулевой указатель - `nullptr`.
4. Invalid указатель - указывает куда угодно (мы не знаем, что в той памяти лежит).

* ## Базовый синтаксис
  * ### Объявление
    В общем случае (насколько это надо на экзамене) выгладит так: `T *P`, где `T` - 
    это тип того, на что указатель указывает, `P` - это имя указателя.
    
    Примеры объявления (и инициализации в одном месте, а на самом месте в двух):
    ```c++
    const int ci = 10;       // просто cosnt int (не указатель)
    const int *pc = &ci;     // pс - указатель на переменную ci
    int i;                   // i - просто int (не указатель)
    int *p;                  // p - указатель (не инициализировали)
    
    struct node {
        int value;
        node *next, *prev;   // со структурками/классами синтаксис ровно такой же синтаксис
    };
    
    int main() {
    }
    ```
    
    >_Замечание:_ звездочка пишется именно перед указателем 
    (то есть для каждого указателя нужна отдельная звездочка)
    `node *next, *prev;`
    
    Приколы ([zero initialization](https://en.cppreference.com/w/cpp/language/zero_initialization)):
    ```c++
    int *ptr; // по-умолчанию ставится в nullptr (zero initialization)
              // кратко: nullptr ставится всем неинициализированным указателям со static storage duration
    
    int main() {
        int *another_ptr; // указывает на рандомное место в памяти (Invalid указатель)
    }
    ```

  * ### Разыменование
    
    Чтобы получить объект, на который ссылается указатель `ptr`, надо написать `*ptr`.

    >При разыменовании указателей вида 2,3,4 получаем UB.      

    Собственно, пример:
    ```c++
    #include <iostream>
      
    int *p;        			// просто указатель (nullptr по умолчанию)
    int x = 10;      		// просто int
    int *xp = &x; 			// xp с этого момента - указатель на x
      
    int main() {
      int y = *xp;          // в y копируем значение x
      int *nxp = xp;    	// nxp теперь тоже указатель на x
      
      std::cout << (*nxp) << " " << x << "\n";  // 10 10
      if (*nxp == x) {
          std::cout << "true\n";                // prints true
      }
    
      // int z = *p;      	// UB при разыминовании nullptr
      // int *p;         	// указатель p (invalid указатель)
      // *p;             	// тоже UB, потому что указатель - invalid
    }    
    ```
    >_Замечание:_ При выводе скобочки потерять нельзя из-за [приоритетов операторов](https://en.cppreference.com/w/cpp/language/operator_precedence).
  * ### Взятие адреса
        
    Собственно, чтобы получить адрес, на который указывает указатель `ptr`, 
    нужно написать `ptr` (то есть адрес, куда указывает указатель - это просто его значение).
  
    Пример:
    ```c++
    #include <iostream>
    
    int x = 10;        // просто int 
    int *px1 = &x;     // указатель на x
    int *px2 = &x;     // еще указатель на x
   
    int main() {
      std::cout << px1 << " " << px2 << "\n";    // выводим адреса переменной,
                                                 // на которую указывают px1 и px2
                                                 // (они совпадут)
      
      std::cout << &px1 << " " << &px2 << "\n";   // выводим адреса самих указателей
                                                  // (они разные) 
    }
    ```
    >_Замечание 1:_ `&ptr` - память, где лежит указатель. 
    `ptr` - память, где лежит переменная, на которую указывает указатель.   

  * ### Стрелочка `->`
    
    `->` - это просто синтаксический сахар для того, чтобы работать со структурками/классами
    было удобней.
  
    Написать стрелочку - то же самое, что и разыменовать указатель и применить к результату `operator.`.
    
    Пример:
    ```c++
    #include<iostream>
    
    struct node {            // структурка для двусвязного списка
      int data;              // значение node  
      node *next, *prev;     // указатели на предыдущий и следующий элементы списка
    }
    
    int main() {
      node a{10}, b{20}, c{30};  // создаем три элемента (пока что раздельных)
      a.prev = nullptr;          // говорим, что a - это начало списка, проинициализировав 
                                 // его предыдущий элемент nullptr (такой у нас инвариант)
      
      a.next = &b;               // связали элементы в список
      b.next = &c;               
      
      // теперь хотим вывести значение следующего элемента после a
      // давайте сделаем, как умеем
    
      std::cout << (*a.next).data << "\n";        // фуу
      
      // чтобы писать было на два символа короче, директор c++ придумал стрелочку:
    
      std::cout << a->data << "\n";               // теперь красиво 
    }              
    ```
  
* ## Реализация двусвязного списка
  Ну вот она:
  ```c++
  #include <iostream>
  
  struct node {
      int data;
      node *prev = nullptr, *next = nullptr;
  };
  
  void add_after(node& a, node&  b) {          // добавление элемента между a и a->next
      b.next = a.next;                         // говорим, что следующий за b элемент - это следующий за a в прошлом элемент
      if (b.next != nullptr) {                 // разыменование nullptr - UB
          b.next->prev = &b;                   // обновляем указатель на элемент идущий перед следующим за b
      }                                                                               
      a.next = &b;                             // все понятно: следующий за a теперь b
      b.prev = &a;                             // тоже понятно: предыдущий от b - это a
  }
  
  void add_before(node& a, node& b) {          // добавление элемента b между a->prev и a
      b.prev = a.prev;                         // элемент перед b теперь - это элемент перед a в прошлом
      if (b.prev != nullptr) {                 // разыменование nullptr - UB
          b.prev->next = &b;                   // обновляем указатель на идущий после элемента перед b
      }
      b.next = &a;                             // все понятно: следующий за b - теперь a
      a.prev = &b;                             // тоже понятно: следующий за a - теперь b
  }
  
  void remove(node& a) {                       // удаление элемента a 
      if (a.prev != nullptr) {                 // если есть элемент перед a, то обновим его
          a.prev->next = a.next;               // обновляем указатель на следующего за предыдущим элементом
      }
      if (a.next != nullptr) {                 // если есть элемент после a, то обновим его
          a.next->prev = a.prev;               // обновляем указатель на идущего пред слудющим за a
      }		
  }
  
  void print_list(node& head) {                // печть списка: не интеллектуально
      node *cur = &head;
      while (cur != nullptr) {                 // собственно, пока текущий выводмимый - не конец списка
          std::cout << cur->data << " ";       // выводим значение предыдущего head
          cur = cur->next;                     // теперь head - это следующий за head элемент
      }
      std::cout << "\n";                       // вывод пустой строчки, потому что почему бы и нет
  }
  
  int main() {
      node a{10}, b{20}, c{30}, d{40}, e{15};  // создание элементов и их связывание спомощью add-функций
      add_after(a, b);
      add_after(b, c);
      add_before(b, e);
      add_after(c, d);      
  
      print_list(a);  // 10 15 20 30 40
      print_list(b);  // 20 30 40
      print_list(c);  // 30 40
  
      remove(e);
  
      print_list(a);  // 10 20 30 40
  }
  ```
  >_Замечание:_ в конструкции типа `a.next->prev` мы сначала пишем точку, потому что `a` 
    был у нас не указателем, но, `a.next` - это указатель, поэтому, чтобы обратится к 
    его полям надо использовать стрелочку.
* ## Нулевой указатель
  Иногда хочется пометить, что указатель никуда не указывает. Это можно сделать с 
  помощью присвоения `nullptr` указателю. Такой указатель называется нулевым.
  > Разыменование нулевого указателя - это UB.
  
  Пример: 
  ```c++
  int main() {
    int *ptr = nullptr;
    if (ptr) {             // если ptr - это nullptr, то при конвертации к bool
                           // получим false. Иначе - true.
      // do something                  
    }
    if (ptr != nullptr) {  // так тоже делать никто не запрещает
      // do something
    }
    *ptr;                  // разыменование nullptr - UB
  }
  ```
  >_Замечание:_ Единственный случай, когда указатель при конвертации к `bool`
    вернет `false` - это случай, когда указатель нулевой.  
  
  До `C++11` стандартным нулевым указателем был макрос `NULL`, который определен нулем. 
  Ее лучше не использовать из-за вот таких приколов:
  ```c++
  #include <cstddef>
  #include <iostream>
   
  void foo(int*) {
    std::cout << "foo(int*);\n";
  }
   
  void foo(long) {
    std::cout << "foo(long);\n";
  }
   
  int main() {
    foo(nullptr);        // calls foo(int*)
    foo(NULL);           // compilation error (call is ambigous)
    foo(0);              // compilation error (call is ambigous)  
  }
  ```
  >_Замечание1:_ `NULL` и `0` могут быть сконвертированы и в `int`, и в указатель,
    а `nullptr` - это чисто про указатели.
  
  >_Замечание2:_ На cppreference [написано](https://en.cppreference.com/book/pointers#:~:text=Special%20null%20pointer),
    что `foo(NULL)` будет вызывать `foo(long)`, но у меня под всеми компиляторами и всеми разумными стандартами была ошибка компиляции.
  
  Тем не менее, когда вы пишете `foo(NULL)`, вы ожидаете, что вызовется перегрузка `foo(int*)`, чего не происходит.
* ## Отличие ссылок от указателей
  * ### Изменяемость
    
    >Ссылка после создания всегда указывает на один элемент, в то время как указатель 
    можно перепривязывать.
    
    Пример:
    ```c++
    #include <iostream>
    
    int main() {
      int x = 10;
      int y = 20;
      int *ptr = &x;                             // указатель на x
      int &x_ref = x;                            // ссылка на x 
      std::cout << ptr << " " << &x_ref << "\n"; // указывают на одну и ту же память
      ptr = &y;                                  // перепривязали указатель к y
      x_ref = y;                                 // это уже присвоение y в x_ref, т.е. в x
      std::cout << ptr << " " << &x_ref << "\n"; // у ptr адрес поменялся на адрес y, а у x_ref остался тем же
    }
    ```
  * ### Обнуляемость
    
    >Указатели имеют нулевое состояние `nullptr`, в то время как ссылки таким не обладают. 
    Т.е. ссылка всегда должна указывать на объект, а указатель - нет.
    
    Пример:
    ```c++
    #include <iostream>
    
    int *g_ptr;                 // просто указатель (по умолчанию nullptr)
    
    int main() {
      int *ptr = nullptr;       // просто нулевой указатель
      int &ref;                 // compilation error: ref объявлена, как ссылка, но не инициализирована  
    }
    ```
  * ### Хранение в контейнерах
    Указатели спокойно кладутся в контейнеры, а вот ссылки туда класть нельзя. 
    (можно, если использовать `std::reference_wrapper`, который превращает ссылку в 
     копируемый и присваиваемый объект, но это не просто ссылки)
    
    >Ссылки нельзя копировать и присваивать. (Вообще ссылка - это не объект, 
     а в контейнерах должны объекты лежать)
  
    Пример:
    ```c++
    #include <vector>
    
    int main() {
      std::vector<int*> v_ptr(10);       // создается вектор из 10 нулевых указателей
      std::vector<int&> v_ref(10);       // compilation error: с длинной ошибкой
    }
    ```
    
    Пример с `std::reference_wrapper`:
    
* ## Арифметика указателей
  * ### `array-to-pointer decay`
    Ссылка на массив - это ссылка на его первый элемент. Значит можно сделать вот так:
    
    Пример:
    ```c++
    #include <cassert>
    #include <cstddef>
  
    int main() {
      int data[]{10, 20, 30, 40};
      
      int *p1 = &data[0];        // берем адрес первого элемента
      assert(*p1 == 10);
  
      int *p2 = data;            // array-to-pointer decay. Только массивы, не вектора.
      assert(p2 == p1);
      assert(*p2 == 10);
      *p2 = 12;                  // можно менять
      assert(*p2 == 12);
      assert(data[0] == 12);
      *p2 = 10;
    }
    ```
    >_Замечание:_ Только для C-шных массивов (не для векторов).
    
  * ### Операции `+`, `++`, `-`, `--` указателей с `int`
    Указатели в массиве можно смещать (главное, надо остаться либо в массиве,
    в котором мы находились, либо в следующей ячейке после конца массива). Отдельные объекты
    трактуются, как массивы из одного элемента, то есть можно получать указатель следующий за последним.
    
    `+`, `++` - смещение вперед.
    
    `-`, `--` - смещение назад.
  
    >Работает ровно как у итераторов.
    
    Пример:
    ```c++
    #include <cassert>
    #include <cstddef>
  
    int main() {
      int data[]{10, 20, 30, 40};
      
      int *p1 = &data[0];               // взяли указатель на первый элемент
      int *p2 = data;                   // array-to-pointer decay
  
      // Арифметика такая же, как и у итераторов.
    
      int *q = p1 + 2;                  // указатель на data[2]
      assert(q == &data[2]);
      assert(data + 2 == &data[2]);
      assert(*q == 30);
  
      int *r = q;                       // указатель на q, то есть на data[2]
      r--;                              // теперь это указатель на data[1]
      assert(r == &data[1]);
      assert(*r == 20);
  
      int x = *r--;                   
      
      // Эквивалентно вот этой штуке:
      // int *old_r = r;
      // r--;
      // int x = *old_r;
      
      assert(x == 20);
      assert(data[1] == 20);
      assert(data[0] == 10);
      assert(r == &data[0]);
      assert(*r == 10);
  
      // То же самое, только с префиксным оператором
    
      r = &data[1];
      int y = *--r;
      assert(y == data[0]);
      assert(y == 10);
      assert(r == &data[0]);
  
      std::ptrdiff_t diff = r - q;      // std::ptrdiff_t - тип, в который влазит вся память на компе
      assert(diff == -2);
      assert(&data[0] - &data[2] == -2);
  
      assert(data[1] == *(data + 1));  // По определению, синтаксический сахар для массивов (not vectors).
      assert(data[1] == *(1 + data));
      assert(1[data] == *(1 + data));
      int *data_ptr = data;
      assert(data_ptr[1] == *(data_ptr + 1));
      assert(data_ptr[1] == data[1]);
    }
    ```
    >_Замечание:_ `data[1]` - это на самом деле `*(data + 1)`.
  * ### `one-past-the-last`
    > Указатель на память, следующую за последним элементом массива - корректный, но его нельзя разыменовывать.
    
    Пример:
    ```c++
    #include <cassert>
    #include <cstddef>
    #include <iostream>
  
    struct Foo {
      int x = 0;
      int y = 1;
    };
    
    int main() {
      int data[]{40, 20, 10, 30};
  
      int *one_past_end = data + 4;
      assert(one_past_end - data == 4);
      // int var = *one_past_end;                     // разыменование - UB.
        
      Foo a;
      int *val = &a.x;
      val++;                                          // корректно (ope-past-the-last)
      // *val;                                        // разыменование - UB
    }
    ```
  * ### Сравнение указателей
    >`=`,`!=` - можно сравнивать любый указатели. Возвращает, равен ли один другому.
    
    > `>`,`>=`,`<`,`<=` - можно сравнивать указатели из одного массива или из одной структурки. 
      В случае сравнения разных объектов - `unspecified behaviour`.
    
    > `-`: Вычитать два указателя можно только из одного массива
  
    >В контейнерах используется `std::less`, который на всех указателях строит _какой-то_ полный порядок,
      поэтому можно пихать указатели, например, в `std::set`.
    
    Пример:
    ```c++
    #include <cassert>
    #include <functional>
    #include <iostream>
    #include <set>
  
    struct Foo {
      int a = 10;
      int b = 20;
      int c = 30;
    };
  
    int main() {
      {
          int data[4];
          int end;
          std::cout << (&end - data) << "\n";  // UB
          std::cout << (data < &end) << "\n";  // unspecified, может быть неконсистентным!
          std::cout << (data < &end) << "\n";  // unspecified, может быть неконсистентным!
          assert(data != &end);  // ok
      }
      {
        Foo f;
        std::cout << &f.b - &f.a << "\n";  // UB: не массив
        assert(&f.a < &f.b);  // ok: члены с одним уровнем доступа (private/protected/public) упорядочены
        assert(&f.a != &f.b);  // ok: разные int
      }
      {
        std::set<int*> s;
        int a = 10, b = 20;
        s.insert(&a);  // ok
        s.insert(&b);  // ok
  
        std::less<int*> comparator;
        std::cout << comparator(&a, &b) << "\n";  // implementation-defined
      }
    }
    ```

* ## C-style-strings/ASCIIZ-строки/строки в стиле Си
  * ### Определение
    `C-style-strings` - это не тип, а конвенция. 
     > "Если у нас есть массив, где сначала идут символы, символы, символы, а потом символ `\0`,
        то это сишная строка", — Егор Суворов.
  * ### Сохранение строкового литерала в `char *`
    С помощью `array-to-pointer decay` можно сконвертировать массив (сишную строку) в указатель.
    
    Пример:
    ```c++
    int main() {
      char str[] = "hello";                              // сишная строка
      // char str[] = {'h', 'e', 'l', 'l', 'o', 0};      // то же самое
      
      char str_ptr = *str;                               // array-to-pointer decay
    }
    ```
  * ### Сравнение и получение длины
      
    >_Опасно:_ если есть две си-шные строки `s` и `t`, то если написать `a < b`, то будут сравниваться указатели, 
      что приведет к `unspecified behaviour`. 
      
    >_Опасно:_ казалось бы на равенство указатели сравниваются без `unspecified behaviour`,
      почему бы тогда не сравнить `s == t`. Нельзя так как не гарантируется, что у 
      одинаковых строковых литералов один и тот же адрес. Ну и вообще разные строковые
      литералы могут обозначать одну и ту же сишную строку (например `"hello"` и `"hello\0"`). 
      То есть придется тоже цикликом.
      
    Но если написать `*a < *b`, то сравнятся лишь первые символы, а значит придется писать цикл `:(`.
      
    Сравнение на меньше (остальные аналогично):
    ```c++
    bool is_less(char* a, char* b) {
      for (int i = 0; a[i] || b[i]; i++) {           // (a[i] || b[i]) - нулевой символ кастуется к false, остальные - к true
        if (a[i] != b[i]) {
          return a[i] < b[i];
        }
      }
      return false;
    }
    ```
      
    Получить длину сишной строки можно так:
    ```c++
    int get_length(char* s) {
      int res = 0;
      while (s[res] != '\0') {    // идем до последнего символа, ответ - сколько элементов прошли
        res++;
      }
      return res;
    }
    ```
      
    >_Опасно:_ длина сишной строки считается за линию. Даже `std::strlen()`.
      
  * ### Выделение памяти, аллокация, конкатенация {#oper}
      
    Мы хотим сконкатенировать две сишные строки. Беда в том, что сишные строки - 
    это не отдельные объекты, это указатели.
      
    То есть если мы хотим сконкатенировать две строки и получить новую, то нам надо 
    где-то выделить под нее память.
      
    Функция для конкатенации: 
    ```c++
    char* strcat(cosnt char* a, const char* b) {
      char* res = new char[std::strlen(a) + std::strlen(b) + 1]; // +1 для '\0'.
      int res_len = 0;
      for (int i = 0; a[i]; i++) {
        res[res_len++] = a[i];
      }
      for (int i = 0; b[i]; i++) {
        res[res_len++] = b[i];
      }
      res[res_len] = '\0';
      return res;
    }
    ```
      
    >_Опасно:_ теперь про каждую сишную строчку мы обязаны помнить, как мы ее получили.
      В зависимости от способа получение вызывать нужный `delete`.
      
    Пример (реализацию `strcat` возьмем из прошлого примера):
    ```c++
    #include <cstring>
    #include <iostream>
    #inlude "прошлый_пример.h"
      
    int main() {
      char* x = "xyz";
      char* y = strcat("xy", "z") + 1;
      
      // миллион строк кода
      
      delete[] (y - 1); // тут надо не забыть, что мы выделили именно массив и y взят со съездом на 1
      
      // еще надо не забыть, что вызывать delete от x не надо, потому что
      // у x automatic storage duration
    }
    ```
    
  * ### Небезопасность функции чтения

    Рассмотрим реализацию `readWord` из известного среди всей прогрессивной общественности 
    файлика `optimization.h`.
  
    Напоминание реализации readWord:
    ```c++
    void readWord(char *s) {
      int c = readChar();         // readChar просто смотрит на текущий символ из буфера
      while (c > 32)
        *s++ = c, c = getChar();  // c++ выпендреж от Cерёжи. Просто считали очередной символ.
      return с != -1;             // видимо, возвращает, считалось ли что-то?
    }
    ```
    
    >_Опасно:_ что произойдет, если мы считаем больше символов, чем выделено в `s`? 
      UB конечно же.
  
  * ### Кто владеет результатом `c_str`
    
    Что вообще такое `c_str`? Это метод у `std::string`, который возвращает сишную строчки.
    
    >_Собственно ответ:_ результатом `c_str` владеет `std::string`, который его вызвал.
    
    Пример:
    ```c++
    #include <iostream>
    #include <string>
    
    int main() {
      const char *s_ptr;
      {
        std::string s = "hello";
        s_ptr = s.c_str();
        std::cout << s_ptr << " (1)\n";    // корректно вывели сишную строчку
      }                                    // конец зоны видимости s (тут она умирает)
      std::cout << s_ptr << " (2)\n";      // UB: строчка, владеющая той памятью уже не существует
    }
    ```</details>

