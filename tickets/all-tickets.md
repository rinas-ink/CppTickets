<details>
<summary>
 Template Ticket
</summary>


**жирный текст** _курсив_ ~~ошибка~~ ==мнения?== `inline code block` [ссылка на фулл](https://www.markdownguide.org/cheat-sheet/)
```c++
int main() {
    return 0;
}
```

### Подзаголовок

LMAO
Not bottom text, lol

</details>

<details>
<summary>
 Билет 10 Базовый синтаксис
</summary>


### Встроенные типы
[типы](https://en.cppreference.com/w/cpp/language/types)
int - целые числа, в стандарте - минимум 2 байта, обычно 4. Диапазон значений от -2^31 до 2^31 (от −2 · 10^9 до 2 · 10^9).
double - вещественные, обычно 8 байт, диапазон приблизительно 18 единиц. 
0.1 + 0.2 != 0.3, тк компьютер хранит числа в 2СС, поэтому все приблизительно 
(long long - обычно 8 байт, от -2^63 до 2^63  (−9 · 10^18 до 9 · 10^18))
bool - обычно 1 байт, true(1) / false(0), по историческим причинам причисляется к целочисленным   [примеры](https://github.com/hse-spb-2021-cpp/lectures/blob/master/02-210909/01-trivial-types/01-bool.cpp)
char - обычно 1 байт и знаковый, диапазон от -128 до 127, в арифметике ведет себя как целочисленный: [примеры](https://github.com/hse-spb-2021-cpp/lectures/blob/master/02-210909/01-trivial-types/03-char.cpp)
signed - знаковый
unsigned - беззнаковый, значения из отрицательного диапазона перекидываются в положительный (unsigned int от 0 до 2^32), переполнение - берется по модулю (переполнение знакового - UB!).
### Литералы
Литералы - это значения, которые вставляются непосредственно в код. 
[примеры](https://github.com/hse-spb-2021-cpp/lectures/blob/master/02-210909/01-trivial-types/04-literals.cpp)
целочисленный - префикс - основание (СС), суффикс U -unsigned, L - long
вещественный - по умолчанию double, если дописать f ==> float, L ==> long double 
символьный - символьная константа в ' ' или обратный слеш + символ (например [escape-последовательности](https://en.cppreference.com/w/cpp/language/escape)) ,  применяются коды из ASCII или Unicode.
### Строковые литералы
[строковые и символьные литералы](https://docs.microsoft.com/ru-ru/cpp/cpp/string-and-character-literals-cpp?view=msvc-170)
Строковый литерал – последовательность символов в " " с завершающим нулем.
raw string literal - необработанные строковые литералы [пример](https://www.geeksforgeeks.org/raw-string-literal-c/)

### Склейка подряд написанных строковых литералов на этапе компиляции 
```c++
    std::string s1 = "hello" "world"; //препроцессор склеит в один строковый литерал
    std::string s2 = "he\n\t\xFF" R"foo(Hello World)foo"; //и обработает все эти штуки 
    "AB" + "CD"; //не скомпилируется
```

### static_cast<> 
Приведения типов, есть еще вариант в стиле C - (int), но со сложными типами static_cast<> безопаснее
Пример избавления от переполнения при умножении int'ов.
```c++
int x = 1e9; 
long long y = x * x; 
```
Будет UB, тк выполнится вначале правая часть int * int = int, а тут переполнение типа. 
Решение:
```c++
int x = 1e9; 
long long y = static_cast<long long> (x) * x; 
```
### Разница между i++ и ++i.
i++ - возвращает значение, увеличивает  
++i - наоборот
```c++
a = b++; // a = b; b++;
a = ++b; // b++; a = b;
```
### Составные операторы присваивания
сокращенные операторы присваивания типа *=, /=, %=
Возвращают ссылку на объект
` y = x += 10; // x+= 10; y = x;`
### Expression и statement
expression - выражение, что-то вычисляющее значение: выражения, вызовы функций, обращения к переменной [примеры](https://en.cppreference.com/w/cpp/language/expressions) 
statement - инструкция, команда. Что-то типа if, while, for, объявления переменных [примеры](https://en.cppreference.com/w/cpp/language/statements)
[пример с лекции](https://github.com/hse-spb-2021-cpp/lectures/blob/master/05-210930/00-before/00-comma.cpp)
[типы expression](https://docs.microsoft.com/en-us/cpp/cpp/types-of-expressions?view=msvc-170)
### Оператор ,
[этот же пример с лекции](https://github.com/hse-spb-2021-cpp/lectures/blob/master/05-210930/00-before/00-comma.cpp)
Объединяет выражения, вычисляет их, возвращает результат правого. Циклы через запятую не записать, тк это statement.
Еще используется, когда несколько параметров в цикле.
Еще пример (у запятой низкий приоритет):
```c++
a = b, c; // a = b
a = (b,c); // a = c
```
### Синтаксис: for, while, if.
E - expression, S - statement
```c++
for(E,E,E)
    S
```
[цикл](https://en.cppreference.com/w/cpp/language/for)
например: 
```c++
for (int i = 0; //происходит перед циклом 
i < n; //проверяется перед каждой итерацией 
i++) { //выполняется в конце каждой итерации 
} 
```
break - выход из цикла 
continue - следующая итерация

```c++
while(E)
    S
```
```c++
if(E) // еще может быть if(<создание переменной>; E)
    S1
else 
    S2
```
### Тернарный оператор
<проверяемое условие> ? <оператор выбора 1> : <оператор выбора 2> 
Может возникнуть проблема,когда ветки разных типов, тогда непонятно, какой тип возвращать:
[пример с лекции](https://github.com/hse-spb-2021-cpp/lectures/blob/master/04-210923/01-functions/02-lcm.cpp)
[таймкод](https://youtu.be/f2aiF6dQQ7c?t=217)
### Range-based for
[cppreference](https://en.cppreference.com/w/cpp/language/range-for)
Вместо for (int i = 0; i < n; ++i) - for (int x : vec) - инициализируется новая переменная x на каждой итерации, в которую копируется элемент вектора.
Если взять по ссылке: 
for (int &x : vec)
то можно изменить значение переменной в векторе, копирования не происходит.
Константная ссылка - нельзя изменить значение переменной, копирования не происходит.

auto - в некоторых контейнерах удобнее писать auto it, чем typename std::set<int>::iterator it;
Каким типом будет auto определяется во время компиляции
Можно использовать auto, когда храним пары или некоторые структуры, итерируемся по map.
[примеры](https://github.com/hse-spb-2021-cpp/lectures/blob/master/03-210916/01-extra-stl/03-map.cpp)
`auto a; // не скомпилируется` 
### Порядок вычислений
[ссылка](https://notes.algoprog.ru/cpp/additional.html#id4)
Если вкратце: 
порядок вычислений аргументов функций происходит на усмотрение компилятора, когда он хочет что-то соптимизировать 
в логических операторах  `if(i < v.size() && v[i] == 0)` - порядок слева направо
инициализация переменных в порядке объявления
`f(), b() // через запятую тоже все в порядке`
при инициализации при помощи {} (обычно у вектора) порядок тоже слева направо
в стандарте C++17 в некоторых выражениях зафиксирован порядок вычислений: слева-направо вычисляются выражения при вводе через >> и выводе через << . При присваивании через =, +=  и похожие операторы: сначала вычисляется часть справа, а потом часть слева. 
Пример:
```c++
int a,b;
a = b = 5; // b = 5; a = b;
```
если бы порядок был другой, получили бы UB


</details>

<details>
<summary>
 4. Функции
</summary>

* ## Параметры
  * ### Синтаксис (пропущенное имя, значение по умолчанию в объявлении/определении)  
  У функции есть объявление и определение, хотя обычно они пишутся сразу вместе. У функции есть тип, название, в круглых скобках передаются параметры, в фигурных само тело функции.  
  ```C++
  void foo(int a, int b){}
  void foo(vector v = {1, 2, 3}){} // параметр по умолчанию
  ```
  Вот так будет выглядеть, если хотим разделить объявление и определение.  
  ```C++
  void foo(int a, int b);
  void foo(int a, int b){
     return a + b;
  }
  ```
  Это может быть полезно, например когда мы хотим использовать две функции друг в друге. При этом одна из них будет определена всегда равньше другой, поэтому приходится придегать к `Forward decloration`. То есть мы говорим, что такая функция есть, и мы можем её вызывать, но вот её определение мы попозже напишем.
  ```C++
  int bar(int x);
  int foo(int y){
      return bar(y - 1) + 1; // OK
  }
  int bar(int x){
      if(x <= 0) return 1;
      return foo(x - 1);
  }
  ```
  Ещё один случай, когда у нас есть несколько единиц трансяции. В этом случае там так же иногда приходится использовать функцию в единице трансляции отличной от той, где мы собственно эту функцию определяем. Поэтому приходится в каждой отдельной единице трасляции писать объявление, если мы хотим использовать функию.  
  Можно в качестве параметра использовать агрумент без имени, указав только его тип. Это, например, используется, чтобы различять префиксный и постфиксный декриметны и инкременты. Обратиться к переданному таким образом аргументу внутри функции не получится. При этом распалагать их можно в перемешку с обычными аргументами, но до агрументов со значениями по умолчанию.  
  ```C++
  void foo1(int a, int, int b, int, int, int c = 100){} // OK
  void foo2(int a, int, int b, int, int, int c = 100, int){} // Compilation error
  void foo3(int a, int, int b, int, int, int c = 100, int = 1){} // OK
  ```
  Аргументы со значениями по умолчанию всегда идут после всех остальных. Можно передавать им новые значения при вызове функции. Задать значение по умолчанию можно как в объявлении, так и в определении функции, но только либо там, либо там.
  ```C++
  void foo1(int c = 100);
  void foo1(int c){
    std::cout << c; // Выводит 100
  }
  ```  
    
  * ### Передача параметров по: значению, `&`, `const&`. Что выбрать и почему.  
  Аргументы в функцию можно передавать по значению, по ссылке, по константной ссылке. Если передавать по значению, то в функцию копируется переданный аргумент. Если по ссылке, то берётся ссылка на переданный агрумент (то есть если теперь его поменять внутри функции, то он поменяется и в том месте, где была вызвана функция). Передача аргумента по константной ссылке не даёт нам изменять его внутри функции.  
  Передача по ссылке нужна, если мы хотим как-то модифицировать переданный аргумент в функцию.  
  Передача по константной ссылке нужна, если мы не хотим менять наш объект внутри функции. При этом, копировать его лишний раз слишком дорого (например копировать матрицу 1000 на 1000 элементов, по которой мы хотим лишь разок пробежаться, не редактируя её, тупо, потратим на это кучу лишнего времени), поэтому лучше передать его по ссылке и запретить редактирование.  
  Отдельный разговор про верменные объекты. Если передать врементый объект в функцию как параметр, то либо по значению, либо по константной ссылке. По ссылке не получится (обычно не скомпилируется, но можно это как-то обойти и получить UB). При передаче временного объекта по константной ссылке, время его жизни продлевается.  
  ```C++
  size_t foo(const std::vector<int> &a){
      return a.size(); // 3
  }
  int main() {
      std::cout << foo({1, 2, 3});
  }
  ``` 
  Из-за этой фичи легальными являются и такие конструкции, где время жизни опять же продлевается.  
  ```C++
  int main() {
      const std::vector<int> &a = std::vector<int>{1, 2, 3};
      std::cout << a.size(); // 3
  }
  ``` 
  * ### Передача `{}` в параметры.  
  Компилятор умная штука. Можно передавать что-то в фигурных скобках, он по контексту догадается, чем это должно быть. Например тут он преобразует это в вектор интов. Это так называемое `List-initialization`. (см. соответствующий билет)
  ```C++
  void foo1(std::vector<int> arr){}
  int main() {
      foo1({1, 2, 3});
  }
  ```  
  * ### Неименованый параметр и `[[maybe_unused]]`  
  Неименованный параметр подробно описан выше. Вместо него можно использовать аргумент с каким-то фиктивным названием и пометить его `[[maybe_unused]]`  
  Приведу ещё один пример, где это используется: теги в аргументах функции. Мы заводим две фиктивные структуры с говорящими именами, делаем перегрузку функции. В одном месте передаём фиктивный параметр типа первой структуры, во второй функции фиктивный параметр второй структуры.  
  ```C++
  struct multi_five{};
  struct multi_ten{};
  int foo(int a, multi_five){
      return a * 5;
  }
  int foo(int a, multi_ten){
      return a * 10;
  }
  int main() {
      foo(1, multi_five{}); // 5
      foo(1, multi_ten{}); // 10
  }
  ```  
  
* ## Возвращаемое значение
  * ### Возврат по значению, ссылке, константной ссылке.  
  При возврате по значению, возвращаемый объект будет копироваться в переменную, куда вы его запишите.  
  При возврате по ссылке, функция возвращается ссылку на объект. Поэтому стоит быть аккуратным. В следующем примере пытаемся вернуть ссылку на локальную переменную, которая уберётся со стека после окончания выполнения функции, поэтому получаем UB.  
  ```C++
  int& foo1(int a){
      int b = a + 1;
      return b; // UB
  }
  int main() {
      int c = foo1(4);
      std:: cout << c;
  }
  ```  
  Применять возращение значения по ссылке можно например, если нам в параметрах передали какой-то аргумент по ссылке. То есть после окончания функции, он не будет уничтожен, поэтому позвращать на него ссылку совершенно легально.  
  ```C++
  int& foo1(int &a){
      a++;
      return a; // OK
  }
  int main() {
      int c = 5;
      int &b = foo1(c); // 6
      b++; // 7
      std::cout << c; // 7
  }
  ```
  Или например, можно возвращать ссылку на статический объект, объявленный внутри функции.
  ```C++
  int& foo1(){
      static int a = 100;
      a++;
      return a; // OK
  }
  int main() {
      int &c = foo1();
      std::cout << c << "\n"; // 101
      foo1();
      std::cout << c << "\n"; // 102
  }
  ```  
  Ну и можно возвращать константные ссылки. Всё работает интуитивно.  
  ```C++
  const int& foo1(int &a){
      a++;
      return a; // OK
  }
  int main() {
      int c = 5;
      const int &b = foo1(c); // 6
      b++; // Compilation error
  }
  ```
  * ### Возврат `{}`.  
  Возвращение из функции `{}` возможно только если возвращать что-то по значению (ну очевидно, не понятно что бы означало вернуть ссылку на пустые скобки. Это просто не скомпилится). В этом случае, вызововется Default initialization у элемента возвращаемого типа. То есть если функция от инта, то вернётся 0.  
   ```C++
  int foo1(){
      return {};
  }
  int main() {
      std::cout << foo1(); // 0
  }
  ```
  * ### `[[nodiscard]]`, возможные стратегии применения: когда не имеет смысла игнорировать возвращаемое значение, когда игнорировать опасно  
  Например, опасно игнорировать возвращаемый объект какой-то структуры. Если мы использовали внутри функции Dynamic storage duration, и возвращаем какой-то объект, в предположении что его после нужно пудет удалить. Если же мы его никуда не сохраним, произойдёт утечка памяти. Имеет смысл запрещать игнорировать возвращаемое значение, например если мы переопределяем какой-то арифметический оператор, как `+` в `bigint`. (Речь идёт о `C-style pointer`, с `unique_ptr` всё нормально будет, он почистится).  
  Так же если функция ничего не меняет вне себя, то ситуация, когда мы никуда не сохранили её значение означает, что мы попросту впустую потратили время на её выполнение, и это не дело.  
  Или если функция связана с обработкой ошибки, то идейно мы обязаны как-то исползользовать возвращаемое ей значение.  
* ## Перегрузка функций:
  * ### Что входит в сигнатуру, что не входит (например, значение по умолчанию).  
  Сигнатура функции включает имя функции, а также количество, порядок и тип ее формальных параметров.  
  Две перегруженные функции не должны иметь одинаковую сигнатуру.  
  Возвращаемое значение не является частью сигнатуры функции.  
  Две эти функции имеют одинаковую сигнатуру:  
  ```C++
  int Divide (int n, int m) ; 
  double Divide (int n, int m) ;
  ```
  * Типы-тэги для пояснений к перегрузкам (04-210923/01-functions/04-tags)
  Пояснил за тэги в пункте про безымянные и `[[maybe_unused]]`аргументы.  
  * ### Синтаксис `= delete` с C++11.  
  Если мы хотим запретить, например копирующий конструктор, можем воспользоваться конструкцией = delete: чтобы пометить их как удаленные функции.  
  ```C++
  unique_ptr(const unique_ptr&) = delete;
  unique_ptr& operator=(const unique_ptr&) = delete;
  ```
  Отличие удаления этих функций от их объявления как private.Удаленные функции не могут использоваться никоим образом, так что даже код функциичлена или функций, объявленных как friend, не будет компилироваться, если попытается.  
  Так же можно запрещать перегружать метод:  
  ```C++
  void foo(int x) {
      std::cout << "foo(" << x << ")\n";
  }

  void foo(double) = delete;  // Last step: if chosen by overload resolution, fail compilation.
  ```
  * ### Проблемы с разделением `nullptr`, `NULL`, `0`.  
  nullptr: это отдельный тип, а вот 0/NULL — это инты. Поэтому с перегрузками беда. Различие между NULL и 0 чаще всего практически никакого - (идеологически NULL показывает, что там пусто.  
  `#define NULL 0` //чаще все это именно так и есть  
  `nullptr` - значит что ни на что не указывает - необходимо использовать для указателей
  ```C++
  int *a=nullptr;
  *a; //UB!!!
  ```
  После 11 плюсов с взаимнозаменяемостью этих трёх штук полная лажа, так что `NULL` не стоит использовать вообще никогда.
  * ### Не было: `noexcept`.
  * ### Не было: правил выбора перегрузки точнее "выбирается перегрузка наиболее точная или ambiguous".
* ## Указатели на функции: синтаксис, использование.
  * ### Не было: конверсии между указателями, что происходит с перегрузками.

Тесно связано с: методы.

</details>

<details>
<summary>
 Жизнь объектов
</summary>


### Семантика копирования

В C++ по умолчанию при присваивании объекта / 
передаче объекта в функцию или возврате из функции ожидается, что объект будет скопирован и 
изменения, произошедшие с копией не мутируют сам объект.

При этом существует способ создать ссылку на объект, то есть добавить новое имя для ровно того же объекта в памяти.
Для этого импользуется синтаксис `Type &refer = ....;`, функции также могут принимать аргументы по ссылке. 
При возвращении ссылки из функции нужно быть очень осторожным - локальные переменные умирают при завершении функции, 
возникает dangling reference - ссылка на умерший объект. Обращение по ней - UB. [stackowerflow](https://stackoverflow.com/questions/46011510/what-is-a-dangling-reference)


```c++
void foo(std::vector<int> a) {
    a.push_back(1);
    std::cout << a.size(); 
} 

void bar(std::vector<int>& a) {
    a.push_back(1);
    std::cout << a.size();                                  
} 


int main() {
    std::vector<int> a{0};
    foo(a); // 2
    std::cout << a.size(); // 1 
    bar(a); // 2
    std::cout << a.size(); // 2  
    return 0;
}
```

Пример с dangling reference

```c++
#include <iostream>
#include <vector>

std::vector<int>& foo() {
    std::vector<int> vec{1, 2, 3};
    return vec;
}

int main() {
    std::vector<int> vec = foo();
    std::cout << vec.size() << "\n"; // UB
}
```

### Storage duration

Storage duration - характеристика объектов, опиисание их времени жизни - момента, когда они создаются и умирают.
[cppreference](https://en.cppreference.com/w/cpp/language/storage_duration) - полное описание.
Мы рассматриваем automatic, static и dynamic.

#### Automatic storage duration

Наиболее распространённая storage duration - мы создаём объект при проходе через объявление переменной - её значение 
(обычно оно кладётся на стэк, но стандарт это никак не оговаривает). Объект умирает, когда эта переменная 
становится невидимой навсегда (shadowing не считается, т.к. в какой-то момент переменные снова становятся видимыми).
У полей структуры с automatic storage duration - такой же storage duration. 

```c++
int main() {
    std::vector<int> v;                    // (1) - created

    for (int i = 0; i < 10; i++) {
        std::vector<int> v;                // (2) - created (10 times)
        if (i % 2 == 0) {
             break;                        // (2) - deleted
        }
    }                                      // (2) - deleted
    v.push_back(1);                      
    return 0;                              // (1) deleted
}


```

#### Static storage duration

Переменные инициализируются в какой-то момент и живут до окончания всей программы. Основной пример -
глобальные переменные. Можно создать и локальные объекты с таким же storage duration - для этого
их нужно пометить `static Type var;`. Они инциализируются только при первом прохождении через строчку с их
объявленем, а затем существуют до конца выполнения программы. При их инициализации доступны вске видимые объекты, 
существующие в этот момент (в частности - аргументы функции, в которой они созданы).

```c++
std::vector foo(1000, 0);                 // (1) - created before main

int count(int start) {
    static int current = start;           // (2) - Created on first call; 
    return current++;
}

int bad_counter(int b){
    static int a{};                       // (3) Value-initialzation on first call
    a = b;                                // assigment on every call
    return a++;                                
}

int main() {
    foo.push_back(0);
    std::cout << count(5) << std::endl;           // 5
    std::cout << count(5) << std::endl;           // 6
    std::cout << count(0) << std::endl;           // 7
    std::cout << count(101) << std::endl;         // 8
    std::cout << bad_counter(5) << std::endl;     // 5
    std::cout << bad_counter(5) << std::endl;     // 5
    std::cout << bad_counter(0) << std::endl;     // 0
    std::cout << bad_counter(101) << std::endl;   // 101
}

```

Обычно такие переменные помещаются в область глобальных переменных, поэтому на практике имеет смысл создавать
большие объекты именно таким способом, чтобы не тратить память на стэке.

Здесь можно встретить все проблемы, связанные с SIOF [билет 33](https://github.com/khbminus/CppTickets/blob/master/tickets/ticket33.md).
Про порядокс (или его отсутсвие инициализации таких переменных можно почитать [тут](https://en.cppreference.com/w/cpp/language/initialization#Non-local_variables))
и в билете про инициализацию


#### Dynamic storage duration

Программа сама полностью управляет временем жизни. При вызове оператора `new Type;` - создаётся
объект, значение этого выражения - указатель на него. Для того, чтобыы уничтожить объект используется
`delete ptr;`.

При попытке удалить объект 2 раза или удалить объект, созданый не при помощи опретаора `new` - 
возникает UB.
              
```c++

#include <vector>
#include "iostream"
struct Foo {
    std::vector<int> vec{0, 0, 0};
};

int main() {
    Foo *ptr = new Foo;
    int bar;
    std::cout << ptr->vec.size() << std::endl; // 3
    delete ptr; // To avoid memory leak
    //delete ptr; // Double free - UB;
    //delete &bar; // UB;
}
```

Неосвобождённая память живёт до окончания программы - дальше современные ОС её освобождают. Такая ситуация называется утечкой памяти, 
она может вызвать отложенные проблемы.

Есть целый зоопарк new/delete; 

Можно выделять целые массивы при помощи `new Type[n]` - в таком случае освобождать память следует при помощи `delete[] ptr` - 
иначе UB (В том числе при попытке сделать `delete ptr;`). 

Для new работает много инициализаций:

* default - `new Type`
* default - `new Type()`
* default - `new Type{}`
* direct - `new Type(10)`
* direct list - `new Type{10}`

* Инициализация массивов - `new Foo[n]{val1, val2, val3}` - неинициализированные инициализируются по умолчанию.




### Время жизни временных объектов

Временные объекты умирают по завершении вычмсления выражения где они возникли, но при этом если создать
константную ссылку на временный объект, его время жизни продлится, чтобы соответсвовать времени жизни этой ссылки.

Важно, что эффект теряется, если мы инициализируем новую ссылку на временный объект старой.


```c++

const std::vector<int> &first = std::vectorP{0, 0, 0};
std::cout << first.size() << std::endl; // NO UB
 ....
// maybe another scope
const std::vector<int> &second = first; // would have been dangling if lifetime of second had been wider than lifetime of first;     
}
```

Это может иметь значение, если 


```c++
int const& func(int const& x) {
    return x;
} 


int main() {
    const int &first = func(1);
    std::cout << first; // UB
}
```
т.к. время жизни объекта продлевается только до времени жизни x. x - исчезает после завершения вычисления функции.

Подобное можно встретить и в STL - функция std::min - принимает и возвращает ссылки

```c++
int main() {
    const auto &val = std::min(0, 1); // Dangling reference
}
```
[ну или проблемы range-based for связанная с тем, что его рассахаривание - несколько выражений](https://github.com/Nekrolm/ubbook/blob/master/lifetime/for_loop.md) 

</details>

<details>
<summary>
 Стандартная библиотека
</summary>


<!-- 1 -->
### Что такое `namespace std`
`namespace std` - это пространство имен стандартной библиотеки. Когды мы пишем `std::something`, это означает "взять что-то из стандартной библиотеки". Namespaces используются во избежания конфликтов имен, когда в больших проектах может использоваться много разных библиотек (более подробно - в билете про `namespaces`, уверен, что такой есть. Где-то....).  


<!-- 2 -->
### Контейнеры

#### `std::vector`, `std::string`, `std::list`, `std::map`: когда что использовать 

- `std::vector` - динамически расширяемый массив. Хранение вектора происходит автоматически: дополнительная память под элементы выделяется/освобождается, когда нужно. Память выделяется с запасом на будущие элементы, таким образом вектору не нужно перевыделять память каждый раз при добавлении нового элемента.

- `std::string` - контейнер для работы со строками. В `std::string` можно присвоить сишную строчку, для нее определены многие методы, например, `size()`, также можно обратиться к конкретному символу в строке с помощью оператора `operator[]`.

- `std::list` - обычно реализован как двусвязный список, поддерживающий удаление и встаку элементов за O(1). При этом не поддерживает быстрый доступ к произвольному элементу.

- `std::map` - контейнер, хранящий пары (уникальный ключ, значение) в отсортированном порядке. Наиболее похож на `set<pair<const T1, T2>>`. При этом ключ константный (это важно помнить)!



#### Основные операции и время работы: `push_back`/`emplace_back`, `front()`/`back()`, `operator[]`, `size()`, `capacity()`, `resize()`, `reserve()`

| `vector`, `string`, `list` | push_back | emplace_back | front | back | operator[] | size | capacity | resize | reserve |
|---|---|---|---|---|---|---|---|---|---|
| Время работы | O*(1) | O*(1) | O(1) | O(1) | O(1) | O(1) | O(1) | O(n) | O(n) |
| Возвращаемое значение | - | Начиная с C++17 - ссылка на добавленный элемент | Ссылка на первый элемент | Ссылка на последний элемент | Ссылка на i-ый элемент  | Кол-во элементов в контейнере   | Кол-во элементов, под которое выделена память | - | - |
| Описание | Вставляет элемент в конец копированием или перемещением | Конструирует элемент на месте (в конце контейнера). Не определен для `string` |  |  | Не определен для `list` |  | Не определен для `list` (есть аналог `max_size`) | Изменяет размер контейнера (обрезает с конца или увеличивает, заполняя дефолтными значениями) | Выделяет доп. память (влияет на capacity). Не определен для `list` |


| `map` | insert  | emplace | operator[] | size | max_size |
|---|---|---|---|---|---|
| Время работы | O(logn) | O(logn) | O(logn) | O(1) | O(1) |
| Возвращаемое значение | Итератор на вставленный элемент (или на то, что уже был в контейнере), либо пару (итератор, `bool`), второй параметр показывает произошла ли настоящая вставка элемента   | Пару (итератор, `bool`) | Ссылка на элемент по ключу  | Кол-во элементов в контейнере   | Кол-во элементов, под которое выделена память |
| Описание | Вставляет элемент копированием или перемещением | Конструирует элемент на месте |  |  |  |



#### Особенность `operator[]` у `std::map`: элемент всегда создаётся, даже если его не было, почему
Несмотря на то, что `std::map` похож на сет пар, у него есть свои отличия. Оператор `operator[]` у `std::map` принимает значение ключа, создают элемент с таким ключом (инициализирует его дефолтным значением), если такого ключа раньше не было, и возвращает ссылку на значение.

Этот оператор работает именно таким образом, поскольку возвращает **ссылку** на значение (значение должно быть проинициалиированно, чтобы вернуть его по ссылке).


#### Инвалидация итераторов и ссылок на элементы: когда, какие последствия
Для стандарта `C++17` (для других стандартов правила могут отличаться! Подробнее [тут](https://stackoverflow.com/questions/6438086/iterator-invalidation-rules-for-c-containers)):
- `std::vector`: итераторы (ссылки на элементы тоже!) инвалидируются при удалении и при добавлении в любое место, если произошла реаллокация памяти (вектор расширился). Также инвалидируются указатели (и ссылки) на удаленные элементы (в случае `push_back`).
- `std::string`: также как у `std::vector`.
- `std::list`: при добавлении итераторы (и ссылки) не инвалидируются, при удалении инвалидируются только итератор (и ссылка) на удаленный элемент.
- `std::map`: при добавлении итераторы (и ссылки) не инвалидируются, при удалении (это про `std::map::erase()`, у `std::map::extract()` поведение схоже, но ссылки остаются валидными) инвалидируются итераторы (и ссылки) только на удаленный элемент.

Обращение к невалидному итератору - UB!

<!-- 3 -->
### Итераторы
#### Конвенции с `begin()`/`end()`
Эти два итератора представляют собой полуинтервал, включающий левую, но не правую границу. Иными словами: `[begin; end)`

<!-- 4 -->
### Алгоритмы
#### `sort`, передача своего компаратора
`std::sort` - сортирует элементы контейнера на заданом полуинтервале в соответсвии в предоставленным компаратором (или компаратором по умолчанию).

```cpp
std::vector <int> arr = {2, 4, 3, 1, 6, 5};
std::sort(arr.begin() + 2, arr.begin() + 4); // 2 4 1 3 6 5
std::sort(arr.begin(), arr.end()); // 1 2 3 4 5 6 
```

Способы передать компаратор (TODO: ссфлка на билет про **функторы**):
- Классом компаратором с определенным оператором `operator()`:
```cpp
struct comp {
	bool operator() (const T& a, const T& b) {
		return (a > b);
	}
};
...
std::sort(arr.begin(), arr.end(), comp());
```
- Функцией, возвращающей `bool`:
```cpp
bool comp(const int& a, const int& b) {
	return (a > b);
}
...
std::sort(arr.begin(), arr.end(), comp);
```
- Лямбда функцию:
```cpp
std::sort(arr.begin(), arr.end(), [](const int& a, const int& b) {
	return a > b;
});
``` 

#### `lower_bound`, `upper_bound`, точные инварианты
`lower_bound`, `upper_bound` - принимают полуинтервал (границы поиска) отсортированного контейнера, значение для сравнения, опциональный компаратор.

`lower_bound` - вернет итератор на первый элемент **не меньший**, чем переданный, если такого нет, то на end.

`upper_bound` - вернет итератор на первый элемент **больший**, чем переданный, если такого нет, то на end.

<!-- 5 -->
### Ввод-вывод
#### `cin`/`cout`/`ifstream`/`ofstream`/`istream`/`ostream`/`sstream`
- `cin`/`cout` - глобальные объекты ввода/вывода в стандартные Сишные потоки ввода/вывода. 
```cpp
#include <iostream>
...
int a;
std::cin >> a;
std::cout << a; 
```

- `ifstream`/`ofstream` - типы для файлового ввода/вывода.
```cpp
#include <fstream>
...
std::ifstream input("input.txt");
std::ofstream output("output.txt");
int num; std::string str;

input >> num >> str; // 123 Anime
output << str << ' ' << num; // Anime 123
```

- `istream`/`ostream` - типы для стандартного ввода/вывода (объекты `cin`/`cout` - преставители этих типов). 

- `sstream` - поток для чтения/записи строчек.
```cpp
#include <sstream>
...
std::stringstream ss;
ss << "Hello" << ", World!"; // Hello, World!
std::string s1, s2;
ss >> s1 >> s2;
std::cout << s1 << '\n' << s2 << std::endl;
// Hello,
// World!
```

#### Какие `#include` бывают (2 шт)
`#include` - указывает препроцессору включить содержимое указанного файла в точку, где отображается директива. Типы скобок принципиально отличаются тем, что указывают порядок поиска файлов при указании не полного пути. 

- `#include "..."`: сперва искать этот заголовочный файл следует в текущей директории нашего проекта, затем в системный директориях. 
- `#include <...>`: сперва искать этот заголовочный файл следует в системных директориях.
#### Синтаксис ввода и вывода
Примеры синтаксиса два пункта выше.

#### Перегрузка операторов ввода-вывода для своих классов: конвенции, почему так работает, когда нужны `friend`-операторы и зачем
Когда мы перегружаем операторы ввода/вывода, мы обязаны возвращать ссылки на объекты ввода/вывода, которыми пользуемся. Это позволит нам применять много операторов последовательно в одной строчке. Примеры перегрузок операторов ввода/вывода:
```cpp
std::istream& operator>>(std::istream &is, Type &obj) {
	...
	return is;
}
...
in >> obj1 >> obj2 >> obj3; // равносильно тому, что ниже
// ((in >> obj1) >> obj2) >> obj3; - так как в перегрузке возвращается ссылка на объект типа std::istream
...
std::ostream& operator<<(std::ostream &os, const Type &obj) {
	...
	return os;
}
...
out << obj1 << obj2 << obj3; // по аналогии с вводом
```
- Ввод: Принимаем вторым параметром ссылку на объект, который хотим ввести, так как мы собираемся положить введенное значение по этому адресу. Первым параметром принимаем `std::istream&` (почему именно ссылку - в комментариях в коде расписано почему), почему именно ссылку на этот тип - чтобы, мы могли перегрузить оператор ввода единожды, и он работал для всех типов потоков ввода (так как `std::istream` - базовый класс для всех остальных типов ввода). 
- Вывод: Принимаем вторым параметром константную ссылку на объект, который хотим вывети, либо же копируем по значению, но так скорее делать не стоит (особого смысла нет). Остальное по аналогии с вводом.

Если у нас есть класс, у которого имеется приватное поле, которое нам уметь выводить, можно воспользоваться `friend`:
```cpp
class T {
  public:
    friend std::ostream& operator<<(std::ostream&, const T&);
  private:
    int data;
};
...
std::ostream& operator<<(std::ostream& os, const T& obj) {
	os << obj.data;
	return os;
}
``` 

<!-- remark -->
**Замечание**: тесно связано с: функторы, лямбда-функции, базовый синтаксис (порядок вычислений).




</details>

<details>
<summary>
 17. Указатели
</summary>


## Содержание

Каждый указатель относится к одному из 4 видов:
1. Указатель на объект или функцию.
2. Указатель на память следующую за последним элементом объекта.
3. Нулевой указатель - `nullptr`.
4. Invalid указатель - указывает куда угодно (мы не знаем, что в той памяти лежит).

* ## Базовый синтаксис
  * ### Объявление
    В общем случае выгладит так: `T *P`, где `T` - 
    это тип того, на что указатель указывает, `P` - это имя указателя.
    
    Примеры объявления (и инициализации в одном месте, а на самом месте в двух):
    ```c++
    const int ci = 10;       // просто cosnt int (не указатель)
    const int *pc = &ci;     // pс - указатель на переменную ci
    int i;                   // i - просто int (не указатель)
    int *p;                  // p - указатель (не инициализировали)
    
    struct node {
        int value;
        node *next, *prev;   // со структурками/классами синтаксис ровно такой же синтаксис
    };
    
    int main() {
    }
    ```
    
    >_Замечание:_ звездочка пишется именно перед указателем 
    (то есть для каждого указателя нужна отдельная звездочка)
    `node *next, *prev;`
    
    Приколы ([zero initialization](https://en.cppreference.com/w/cpp/language/zero_initialization)):
    ```c++
    int *ptr; // по-умолчанию ставится в nullptr (zero initialization)
              // кратко: nullptr ставится всем неинициализированным указателям со static storage duration
    
    int main() {
        int *another_ptr; // указывает на рандомное место в памяти (Invalid указатель)
    }
    ```

  * ### Разыменование
    
    Чтобы получить объект, на который ссылается указатель `ptr`, надо написать `*ptr`.

    >При разыменовании указателей вида 2,3,4 получаем UB.      

    Собственно, пример:
    ```c++
    #include <iostream>
      
    int *p;        			// просто указатель (nullptr по умолчанию)
    int x = 10;      		// просто int
    int *xp = &x; 			// xp с этого момента - указатель на x
      
    int main() {
      int y = *xp;          // в y копируем значение x
      int *nxp = xp;    	// nxp теперь тоже указатель на x
      
      std::cout << (*nxp) << " " << x << "\n";  // 10 10
      if (*nxp == x) {
          std::cout << "true\n";                // prints true
      }
    
      // int z = *p;      	// UB при разыминовании nullptr
      // int *p;         	// указатель p (invalid указатель)
      // *p;             	// тоже UB, потому что указатель - invalid
    }    
    ```
    >_Замечание:_ При выводе скобочки потерять нельзя из-за [приоритетов операторов](https://en.cppreference.com/w/cpp/language/operator_precedence).
  * ### Взятие адреса
        
    Собственно, чтобы получить адрес, на который указывает указатель `ptr`, 
    нужно написать `ptr` (то есть адрес, куда указывает указатель - это просто его значение).
  
    Пример:
    ```c++
    #include <iostream>
    
    int x = 10;        // просто int 
    int *px1 = &x;     // указатель на x
    int *px2 = &x;     // еще указатель на x
   
    int main() {
      std::cout << px1 << " " << px2 << "\n";    // выводим адреса переменной,
                                                 // на которую указывают px1 и px2
                                                 // (они совпадут)
      
      std::cout << &px1 << " " << &px2 << "\n";   // выводим адреса самих указателей
                                                  // (они разные) 
    }
    ```
    >_Замечание 1:_ `&ptr` - память, где лежит указатель. 
    `ptr` - память, где лежит переменная, на которую указывает указатель.   

  * ### Стрелочка `->`
    
    `->` - это просто синтаксический сахар для того, чтобы работать со структурками/классами
    было удобней.
  
    Написать стрелочку - то же самое, что и разыменовать указатель и применить к результату `operator.`.
    
    Пример:
    ```c++
    #include<iostream>
    
    struct node {            // структурка для двусвязного списка
      int data;              // значение node  
      node *next, *prev;     // указатели на предыдущий и следующий элементы списка
    }
    
    int main() {
      node a{10}, b{20}, c{30};  // создаем три элемента (пока что раздельных)
      a.prev = nullptr;          // говорим, что a - это начало списка, проинициализировав 
                                 // его предыдущий элемент nullptr (такой у нас инвариант)
      
      a.next = &b;               // связали элементы в список
      b.next = &c;               
      
      // теперь хотим вывести значение следующего элемента после a
      // давайте сделаем, как умеем
    
      std::cout << (*a.next).data << "\n";        // фуу
      
      // чтобы писать было на два символа короче, директор c++ придумал стрелочку:
    
      std::cout << a->data << "\n";               // теперь красиво 
    }              
    ```
  
* ## Реализация двусвязного списка
  Ну вот она:
  ```c++
  #include <iostream>
  
  struct node {
      int data;
      node *prev = nullptr, *next = nullptr;
  };
  
  void add_after(node& a, node&  b) {          // добавление элемента между a и a->next
      b.next = a.next;                         // говорим, что следующий за b элемент - это следующий за a в прошлом элемент
      if (b.next != nullptr) {                 // разыменование nullptr - UB
          b.next->prev = &b;                   // обновляем указатель на элемент идущий перед следующим за b
      }                                                                               
      a.next = &b;                             // все понятно: следующий за a теперь b
      b.prev = &a;                             // тоже понятно: предыдущий от b - это a
  }
  
  void add_before(node& a, node& b) {          // добавление элемента b между a->prev и a
      b.prev = a.prev;                         // элемент перед b теперь - это элемент перед a в прошлом
      if (b.prev != nullptr) {                 // разыменование nullptr - UB
          b.prev->next = &b;                   // обновляем указатель на идущий после элемента перед b
      }
      b.next = &a;                             // все понятно: следующий за b - теперь a
      a.prev = &b;                             // тоже понятно: следующий за a - теперь b
  }
  
  void remove(node& a) {                       // удаление элемента a 
      if (a.prev != nullptr) {                 // если есть элемент перед a, то обновим его
          a.prev->next = a.next;               // обновляем указатель на следующего за предыдущим элементом
      }
      if (a.next != nullptr) {                 // если есть элемент после a, то обновим его
          a.next->prev = a.prev;               // обновляем указатель на идущего пред слудющим за a
      }		
  }
  
  void print_list(node& head) {                // печть списка: не интеллектуально
      node *cur = &head;
      while (cur != nullptr) {                 // собственно, пока текущий выводмимый - не конец списка
          std::cout << cur->data << " ";       // выводим значение предыдущего head
          cur = cur->next;                     // теперь head - это следующий за head элемент
      }
      std::cout << "\n";                       // вывод пустой строчки, потому что почему бы и нет
  }
  
  int main() {
      node a{10}, b{20}, c{30}, d{40}, e{15};  // создание элементов и их связывание спомощью add-функций
      add_after(a, b);
      add_after(b, c);
      add_before(b, e);
      add_after(c, d);      
  
      print_list(a);  // 10 15 20 30 40
      print_list(b);  // 20 30 40
      print_list(c);  // 30 40
  
      remove(e);
  
      print_list(a);  // 10 20 30 40
  }
  ```
  >_Замечание:_ в конструкции типа `a.next->prev` мы сначала пишем точку, потому что `a` 
    был у нас не указателем, но, `a.next` - это указатель, поэтому, чтобы обратится к 
    его полям надо использовать стрелочку.
* ## Нулевой указатель
  Иногда хочется пометить, что указатель никуда не указывает. Это можно сделать с 
  помощью присвоения `nullptr` указателю. Такой указатель называется нулевым.
  > Разыменование нулевого указателя - это UB.
  
  Пример: 
  ```c++
  int main() {
    int *ptr = nullptr;
    if (ptr) {             // если ptr - это nullptr, то при конвертации к bool
                           // получим false. Иначе - true.
      // do something                  
    }
    if (ptr != nullptr) {  // так тоже делать никто не запрещает
      // do something
    }
    *ptr;                  // разыменование nullptr - UB
  }
  ```
  >_Замечание:_ Единственный случай, когда указатель при конвертации к `bool`
    вернет `false` - это случай, когда указатель нулевой.  
  
  До `C++11` стандартным нулевым указателем был макросовая константа `NULL`, которая определен нулем. 
  Ее лучше не использовать из-за вот таких приколов:
  ```c++
  #include <cstddef>
  #include <iostream>
   
  void foo(int*) {
    std::cout << "foo(int*);\n";
  }
   
  void foo(long) {
    std::cout << "foo(long);\n";
  }
   
  int main() {
    foo(nullptr);        // calls foo(int*)
    foo(NULL);           // compilation error (call is ambigous)
    foo(0);              // compilation error (call is ambigous)  
  }
  ```
  >_Замечание1:_ `NULL` и `0` могут быть сконвертированы и в `int`, и в указатель,
    а `nullptr` - это чисто про указатели.
  
  >_Замечание2:_ На cppreference [написано](https://en.cppreference.com/book/pointers#:~:text=Special%20null%20pointer),
    что `foo(NULL)` будет вызывать `foo(long)`, но у меня под всеми компиляторами и всеми разумными стандартами была ошибка компиляции.
  
  > _Замечаание3 (от ХБ):_ лично у меня при компиляции руками `g++ -std=c++17/03/11` g++ выкидывал предупреждение, что `NULL` кастуется к лонгу, при этом `clang++` вообще ничего не выкидывал. 
  
  Тем не менее, когда вы пишете `foo(NULL)`, вы ожидаете, что вызовется перегрузка `foo(int*)`, чего не происходит.
* ## Отличие ссылок от указателей
  * ### Изменяемость
    
    >Ссылка после создания всегда указывает на один элемент, в то время как указатель 
    можно перепривязывать.
    
    Пример:
    ```c++
    #include <iostream>
    
    int main() {
      int x = 10;
      int y = 20;
      int *ptr = &x;                             // указатель на x
      int &x_ref = x;                            // ссылка на x 
      std::cout << ptr << " " << &x_ref << "\n"; // указывают на одну и ту же память
      ptr = &y;                                  // перепривязали указатель к y
      x_ref = y;                                 // это уже присвоение y в x_ref, т.е. в x
      std::cout << ptr << " " << &x_ref << "\n"; // у ptr адрес поменялся на адрес y, а у x_ref остался тем же
    }
    ```
  * ### Обнуляемость
    
    >Указатели имеют нулевое состояние `nullptr`, в то время как ссылки таким не обладают. 
    Т.е. ссылка всегда должна указывать на объект, а указатель - нет.
    
    Пример:
    ```c++
    #include <iostream>
    
    int *g_ptr;                 // просто указатель (по умолчанию nullptr)
    
    int main() {
      int *ptr = nullptr;       // просто нулевой указатель
      int &ref;                 // compilation error: ref объявлена, как ссылка, но не инициализирована  
    }
    ```
  * ### Хранение в контейнерах
    Указатели спокойно кладутся в контейнеры, а вот ссылки туда класть нельзя. 
    (можно, если использовать `std::reference_wrapper`, который превращает ссылку в 
     копируемый и присваиваемый объект, но это не просто ссылки)
    
    >Ссылки нельзя копировать и присваивать. (Вообще ссылка - это не объект, 
     а в контейнерах должны объекты лежать)
  
    Пример:
    ```c++
    #include <vector>
    
    int main() {
      std::vector<int*> v_ptr(10);       // создается вектор из 10 нулевых указателей
      std::vector<int&> v_ref(10);       // compilation error: с длинной ошибкой
    }
    ```
    
    Пример с `std::reference_wrapper`:
    
* ## Арифметика указателей
  * ### `array-to-pointer decay`
    Ссылка на массив - это ссылка на его первый элемент. Значит можно сделать вот так:
    
    Пример:
    ```c++
    #include <cassert>
    #include <cstddef>
  
    int main() {
      int data[]{10, 20, 30, 40};
      
      int *p1 = &data[0];        // берем адрес первого элемента
      assert(*p1 == 10);
  
      int *p2 = data;            // array-to-pointer decay. Только массивы, не вектора.
      assert(p2 == p1);
      assert(*p2 == 10);
      *p2 = 12;                  // можно менять
      assert(*p2 == 12);
      assert(data[0] == 12);
      *p2 = 10;
    }
    ```
    >_Замечание:_ Только для C-шных массивов (не для векторов).
    
  * ### Операции `+`, `++`, `-`, `--` указателей с `int`
    Указатели в массиве можно смещать (главное, надо остаться либо в массиве,
    в котором мы находились, либо в следующей ячейке после конца массива). Отдельные объекты
    трактуются, как массивы из одного элемента, то есть можно получать указатель следующий за последним.
    
    `+`, `++` - смещение вперед.
    
    `-`, `--` - смещение назад.
  
    >Работает ровно как у итераторов.
    
    > Происходит UB при выходе за границы массива (кроме элемента следующего за последним, но про это следующий пункт).
      Причем UB даже без разыменования указателя, то есть UB - сам факт его существования.

    Пример:
    ```c++
    #include <cassert>
    #include <cstddef>
  
    int main() {
      int data[]{10, 20, 30, 40};
      
      int *p1 = &data[0];               // взяли указатель на первый элемент
      int *p2 = data;                   // array-to-pointer decay
  
      // Арифметика такая же, как и у итераторов.
    
      int *q = p1 + 2;                  // указатель на data[2]
      assert(q == &data[2]);
      assert(data + 2 == &data[2]);
      assert(*q == 30);
      
      int *ub1 = data - 1;              // UB: вышли за границу массива
      int *ub2 = data - 1 + 1;          // UB: в промежуточных вычислениях у нас произошло UB (посчитали data - 1)
      int *ub3 = data + 5;              // UB: вышли слишком далеко 
      int *not_ub = data + 4;           // НЕ UB: - one-past-the-last (про него в следующем пункте)
      
    
      int *r = q;                       // указатель на q, то есть на data[2]
      r--;                              // теперь это указатель на data[1]
      assert(r == &data[1]);
      assert(*r == 20);
  
      int x = *r--;                   
      
      // Эквивалентно вот этой штуке:
      // int *old_r = r;
      // r--;
      // int x = *old_r;
      
      assert(x == 20);
      assert(data[1] == 20);
      assert(data[0] == 10);
      assert(r == &data[0]);
      assert(*r == 10);
  
      // То же самое, только с префиксным оператором
    
      r = &data[1];
      int y = *--r;
      assert(y == data[0]);
      assert(y == 10);
      assert(r == &data[0]);
  
      std::ptrdiff_t diff = r - q;      // std::ptrdiff_t - тип, в который влазит вся память на компе
      assert(diff == -2);
      assert(&data[0] - &data[2] == -2);
  
      assert(data[1] == *(data + 1));  // По определению, синтаксический сахар для массивов (not vectors).
      assert(data[1] == *(1 + data));
      assert(1[data] == *(1 + data));
      int *data_ptr = data;
      assert(data_ptr[1] == *(data_ptr + 1));
      assert(data_ptr[1] == data[1]);
    }
    ```
    >_Замечание:_ `data[1]` - это на самом деле `*(data + 1)`.
  * ### `one-past-the-last`
    > Указатель на память, следующую за последним элементом массива - корректный, но его нельзя разыменовывать.
    
    Пример:
    ```c++
    #include <cassert>
    #include <cstddef>
    #include <iostream>
  
    struct Foo {
      int x = 0;
      int y = 1;
    };
    
    int main() {
      int data[]{40, 20, 10, 30};
  
      int *one_past_end = data + 4;
      assert(one_past_end - data == 4);
      // int var = *one_past_end;                     // разыменование - UB.
        
      Foo a;
      int *val = &a.x;
      val++;                                          // корректно (ope-past-the-last)
      // *val;                                        // разыменование - UB
    }
    ```
  * ### Сравнение указателей
    >`=`,`!=` - можно сравнивать любый указатели. Возвращает, равен ли один другому.
    
    > `>`,`>=`,`<`,`<=` - можно сравнивать указатели из одного массива или из одной структурки. 
      В случае сравнения разных объектов - `unspecified behaviour`.
    
    > `-`: Вычитать два указателя можно только из одного массива
  
    >В контейнерах используется `std::less`, который на всех указателях строит _какой-то_ полный порядок,
      поэтому можно пихать указатели, например, в `std::set`.
    
    Пример:
    ```c++
    #include <cassert>
    #include <functional>
    #include <iostream>
    #include <set>
  
    struct Foo {
      int a = 10;
      int b = 20;
      int c = 30;
    };
  
    int main() {
      {
          int data[4];
          int end;
          std::cout << (&end - data) << "\n";  // UB
          std::cout << (data < &end) << "\n";  // unspecified, может быть неконсистентным!
          std::cout << (data < &end) << "\n";  // unspecified, может быть неконсистентным!
          assert(data != &end);  // ok
      }
      {
        Foo f;
        std::cout << &f.b - &f.a << "\n";  // UB: не массив
        assert(&f.a < &f.b);  // ok: члены с одним уровнем доступа (private/protected/public) упорядочены
        assert(&f.a != &f.b);  // ok: разные int
      }
      {
        std::set<int*> s;
        int a = 10, b = 20;
        s.insert(&a);  // ok
        s.insert(&b);  // ok
  
        std::less<int*> comparator;
        std::cout << comparator(&a, &b) << "\n";  // implementation-defined
      }
    }
    ```

* ## C-style-strings/ASCIIZ-строки/строки в стиле Си
  * ### Определение
    `C-style-strings` - это не тип, а конвенция. 
     > "Если у нас есть массив, где сначала идут символы, символы, символы, а потом символ `\0`,
        то это сишная строка", — Егор Суворов.
  * ### Сохранение строкового литерала в `char *`
    С помощью `array-to-pointer decay` можно сконвертировать массив (сишную строку) в указатель.
    
    Пример:
    ```c++
    int main() {
      char str[] = "hello";                              // сишная строка
      // char str[] = {'h', 'e', 'l', 'l', 'o', 0};      // то же самое
      
      char str_ptr = *str;                               // array-to-pointer decay
    }
    ```
  * ### Сравнение и получение длины
      
    >_Опасно:_ если есть две си-шные строки `s` и `t`, то если написать `s < t`, то будут сравниваться указатели, 
      что приведет к `unspecified behaviour`. 
      
    >_Опасно:_ казалось бы на равенство указатели сравниваются без `unspecified behaviour`,
      почему бы тогда не сравнить `s == t`. Нельзя так как не гарантируется, что у 
      одинаковых строковых литералов один и тот же адрес. Ну и вообще разные строковые
      литералы могут обозначать одну и ту же сишную строку (например `"hello"` и `"hello\0"`). 
      То есть придется тоже цикликом.
      
    Но если написать `*s < *t`, то сравнятся лишь первые символы, а значит придется писать цикл `:(`.
      
    Сравнение на меньше (остальные аналогично):
    ```c++
    bool is_less(char* a, char* b) {
      for (int i = 0; a[i] || b[i]; i++) {           // (a[i] || b[i]) - нулевой символ кастуется к false, остальные - к true
        if (a[i] != b[i]) {
          return a[i] < b[i];
        }
      }
      return false;
    }
    ```
      
    Получить длину сишной строки можно так:
    ```c++
    int get_length(char* s) {
      int res = 0;
      while (s[res] != '\0') {    // идем до последнего символа, ответ - сколько элементов прошли
        res++;
      }
      return res;
    }
    ```
      
    >_Опасно:_ длина сишной строки считается за линию. Даже `std::strlen()`.
      
  * ### Выделение памяти, аллокация, конкатенация
      
    Мы хотим сконкатенировать две сишные строки. Беда в том, что сишные строки - 
    это не отдельные объекты, это указатели.
      
    То есть если мы хотим сконкатенировать две строки и получить новую, то нам надо 
    где-то выделить под нее память.
      
    Функция для конкатенации: 
    ```c++
    char* strcat(cosnt char* a, const char* b) {
      char* res = new char[std::strlen(a) + std::strlen(b) + 1]; // +1 для '\0'.
      int res_len = 0;
      for (int i = 0; a[i]; i++) {
        res[res_len++] = a[i];
      }
      for (int i = 0; b[i]; i++) {
        res[res_len++] = b[i];
      }
      res[res_len] = '\0';
      return res;
    }
    ```
      
    >_Опасно:_ теперь про каждую сишную строчку мы обязаны помнить, как мы ее получили.
      В зависимости от способа получения вызывать или не вызывать нужный `delete`.
      
    Пример (реализацию `strcat` возьмем из прошлого примера):
    ```c++
    #include <cstring>
    #include <iostream>
    #inlude "прошлый_пример.h"
      
    int main() {
      char* x = "xyz";
      char* y = strcat("xy", "z") + 1;
      
      // миллион строк кода
      
      delete[] (y - 1); // тут надо не забыть, что мы выделили именно массив и y взят со съездом на 1
      
      // еще надо не забыть, что вызывать delete от x не надо, потому что
      // у x automatic storage duration
    }
    ```
    
  * ### Небезопасность функции чтения

    Рассмотрим реализацию `readWord` из известного среди всей прогрессивной общественности 
    файлика `optimization.h`.
  
    Напоминание реализации readWord:
    ```c++
    void readWord(char *s) {
      int c = readChar();         // readChar просто смотрит на текущий символ из буфера
      while (c > 32)
        *s++ = c, c = getChar();  // c++ выпендреж от Cерёжи. Просто считали очередной символ.
      return с != -1;             // видимо, возвращает, считалось ли что-то?
    }
    ```
    
    >_Опасно:_ что произойдет, если мы считаем больше символов, чем выделено в `s`? 
      UB конечно же.
  
  * ### Кто владеет результатом `c_str`
    
    Что вообще такое `c_str`? Это метод у `std::string`, который возвращает сишную строчки.
    
    >_Собственно ответ:_ результатом `c_str` владеет `std::string`, который его вызвал.
    
    Пример:
    ```c++
    #include <iostream>
    #include <string>
    
    int main() {
      const char *s_ptr;
      {
        std::string s = "hello";
        s_ptr = s.c_str();
        std::cout << s_ptr << " (1)\n";    // корректно вывели сишную строчку
      }                                    // конец зоны видимости s (тут она умирает)
      std::cout << s_ptr << " (2)\n";      // UB: строчка, владеющая той памятью уже не существует
    }
    ```
</details>

<details>
<summary>
 Билет 20 Классы
</summary>

* **Cинтаксис**

```c++
struct Example{
    int x;
    
    Example(){}; // конструктор
    ~Example(){}; // деструктор
    void do_something(){
        std::cout << "hello";
    }
}; // не забываем ставить всегда точку с запятой в конце
```

* **Поля: обычные, константные, ссылки, порядок создание и уничтожения и когда он важен.**
    * **Поле класса/атрибут** - переменная, описание которой создает программист
при создании класса. Все данные объекта хранятся в его полях. Доступ к полям
осуществляется по их имени.
    * **Константные поля** 
Поля, инициализируемые при помощи синтаксиса списка инициализации получают свое значение еще до входа в тело конструктора. Присваивание константе значения в теле конструктора уже является именно присваиванием, что по определению невозможно для константы.

    ```c++
        struct Foo {
            const int x = 10;
            Foo(int x_) : x(x_) { }
        };
    ```
    * **Ссылки** обязательно надо проинициализировать, чтобы они к чему-то были при-
        вязаны. Если же объект, чья ссылка была передана для инициализации переменной-ссылки внутри структуры, умер, то ссылка невалидна и обращение по ней будет вызывать UB.
    ```c++
        class DateClass{
            int a = 1;
            int &c = a;
        };
    ```
    * Разработчики классов могут гарантировать инициализацию каждого объекта пу-
тем определения особой функции, которая называется конструктор. Если в классе определен конструктор, компилятор автоматически вызывает его в момент создания объекта, до того как отдать его в руки программисту. Программисты не праве даже решать, вызывать конструктор или нет, конструктор вызывается всегда компилятором в момент создания объекта.
    ```c++
        class Example {
            int i;
        public:
            Example(){} // конструктор дефолтный
            Example(int a){} // тоже конструктор, но от int
        };
        
        int main(){
            Example cur;  // создание объекта
        }
    ```
    Как и у любого метода, у конструктора могут быть аргументы, чтобы можно было иметь возможность указать как создавать объект, передать какие-то значения и т.д. В C++, очистка поставлена на одну планку по важности с инициализацией и гарантируется, что она будет осуществлена путем вызова деструктора. Синтаксис деструктора и конструктора схожи. И там, и там, в качестве имени метода используется имя класса. Однако, чтобы отличить деструктор от конструктора, перед именем деструктора добавляется символ тильда ( ). Кроме того, деструктор не может иметь какие-либо аргументы, так как для процесса уничтожения не требуется дополнительных параметров. Вот пример объявления деструктора:
    ```c++
    struct Example{
      ~Example(){
        std::cout << "DELETE object\n";
     }
    };
    ```
    Деструктор вызывается автоматически компилятором, когда объект выходит из своей области существования.
* **Семантика копирования, особенности полей-констант/ссылок при копировании и инициализации.**
Если у нас есть объект и мы его передаем по значению (в функции например) или делаем **=**, то копируются все поля. Существует еще copy-constructor и copy assignment operator, которые и управляют копированием. Про них и их реализацию подробнее и красочнее в [примере с лекции](https://github.com/hse-spb-2021-cpp/lectures/blob/master/09-211110/00b-special-operators.cpp). Но стоит сказать, что в примере ниже copy-constructor и copy assignment operator по умолчанию дефолтные.
    ```c++
    struct Foo{
        int x;
        int y;
    };
    void do_smth(Foo temp){} // копирование 

    int main(){
        Foo a{1,2};
        Foo b = a; // Копирование
    

    ```

* **Конструктор: синтаксис, параметры, когда вызывается, делегирующие конструкторы.** 
Конструкторы - специальные методы, которые вызываются при создании объекта. Всегда вызываются и нет способа их пропустить. Время жизни объекта начинается с того, как закончился конструктор. Конструктор по умолчанию - конструктор без аргументов. Может быть сгенерирован компилятором неявно (например, когда вообще нет конструкторов). Когда присутствует какой либо конструктор (не дефолтный), то не генерируется. [Пример с лекции](https://github.com/hse-spb-2021-cpp/lectures/blob/master/04-210923/02-ctors/04-no-default.cpp), где видно, что дефолтный конструктор не создается при наличии другого конструктора. [Примеры вызова конструктора](https://github.com/hse-spb-2021-cpp/lectures/blob/master/04-210923/02-ctors/02-args.cpp).
    ```c++
    #include <iostream>
    
    struct ratio {
        int num;
        int denom;
        ratio() {
            num = 0;
            denom = 1;
            std::cout << "Constructing!\n";
        }
    };
    
    int main() {
        ratio r;
        std::cout << r.num << "\n";
        std::cout << r.denom << "\n";
        std::cout << ratio{}.num << "\n";  // Not UB, ok even in C++03.
    }
    ```
    **Делегирующий конструктор** - конструктор, который вызывается в данном конструкторе для инициализации полей. Тонкость: после вызова делегирующего конструктора не можем изменять поля в member initialization list. Вторая тонкость: внутри конструктора нельзя вызвать делегирующий конструктор, так как это не является вызовом конструктора, это является созданием временного объекта, который быстро умирает. 
    
```c++
    #include <vector>
    #include <iostream>
    
    struct bigint {
        std::vector<int> digits;
        int var;
    
        bigint(int x) : digits{x % 10, x / 10} {
        }
    
        bigint() : bigint(0)/*, var(10)*/ {  // since C++11
            var = 10;                       // тут bigint(0) - делегирующий конструктор
            // если хотим поменять переменную, то лучше сделать переприсвоение, так как в initilization list изменять не имеем права.
        }
    };
    
    int main() {
        [[maybe_unused]] bigint b1; 
    }
```

* **Инициализация полей: когда что можно и нужно использовать, как они взаимодействуют между собой и с делегирующим конструктором:**
    * **По умолчанию (тривиальных и с конструктором по умолчанию). В конструкторе по умолчанию**
    * **Default member initializer (C++11).** Простыми словами мы можем задавать начальные значения в структуре и если мы хотим посмотреть от них значение, то не получим UB, как в случае, если они непроинициализированы (int num; int denom;)
    ```c++
    #include <iostream>
    
    struct ratio {
        int num = 0;  // C++11: member default initialization
        int denom = 1;
    };
    
    int main() {
        ratio r;
        std::cout << r.num << "\n";
        std::cout << r.denom << "\n";
        std::cout << ratio{}.num << "\n";
    }
    ```
    * Member Initilization list. У каждого поля в  {} мы говорим какой конструктор вызвать с круглыми или фигурными скобочками. Тогда у нас поле сразу инициализируется правильно и мы его не инициализируем, а потом перезаписываем, а мы сразу делаем правильно. Это точнее выражает намерения программиста.
    ```c++
    #include <cassert>
    #include <iostream>
    #include <vector>

    struct bigint {
        std::vector<int> digits;
        int sign = 1;
    
        bigint() /*: digits{}*/ {
        }
        bigint(int value) : digits{value % 10, value / 10} {
            assert(value >= 0);
            assert(value < 100);
        }
    };
    
    int main() {
        bigint value(23);
        std::cout << value.digits[0] << "\n";
        std::cout << value.digits[1] << "\n";
    }
    ```
* **Приватные/публичные поля и методы**
[Плохой пример](https://github.com/hse-spb-2021-cpp/lectures/blob/master/04-210923/04-api/01a-public.cpp), когда все в public не бывает полезно. Например пользователь может что-то случайно изменить или сломать инвариант. Для этого существует private секция. К полям и методам из private секции имеют доступ только методы структуры, через них мы можем даже изменять приватные поля. 
Вредные советы: всегда создавать getters и setters. Пример: setters в случае дроби не нужны, и getters тоже сомнительно (?), но их можно оставить. Например надо ставить assert(x != 0), когда меняется знаменатель через  setter. Да и вообще неразумно менять дробь. 
    **геттеры** — это функции, которые возвращают значения закрытых переменных-членов класса;
    **сеттеры** — это функции, которые позволяют присваивать значения закрытым переменным-членам класса.
Запомним: 
Класс должно быть нельзя использовать некорректно! Даже если очень захотеть.
Пример: нельзя просто так взять и поменять числитель/знаменатель у дроби.
    [Оригинальный пример с лекции](https://github.com/hse-spb-2021-cpp/lectures/blob/master/04-210923/04-api/01b-private.cpp)

```c++
    struct ratio {
    private:
        // denom != 0
        int num;
        int denom;
    
    public:
        
        //  куча конструкторов
    
        // getter
        int numerator() const {
            return num;
        }
        int denominator() const {
            return denom;
        }
    /*    // setter
        void numerator(int new_value) {
            num = new_value;
        }
        void denominator(int new_value) {
            assert(new_value != 0);
            denom = new_value;
        }*/
    };
    
    int main() {
        ratio r;
        // r.denominator(0); 
        r = {r.numerator(), 5}; // безумная операция, которая отрывает числитель у дроби и меняет знаменатель.
        // пример плохого применения setter
        std::cout << r.numerator() << "\n";
    }
```

Чтобы иметь доступ к приватным полям структуры вне структуры свободная функция должна быть либо friend-функцией структуры (синтаксис в примере), либо static функция - все так же является другом, все так же НЕ является методом, но она лежит внутри класса с точки зрения ее имени и имеет доступ к private полям. Friend-функция должна быть обязательно объявлена в структуре, а определена либо в структуре, либо вне ее.

```c++
    // friend: defined inside or outside; hidden friends
    // static: defined inside or outside
    struct Foo {
    private:
        int x;
    
    public:
        friend void foo(Foo &f) {
            f.x = 10;
        }
    
        static void bar(Foo &f) {  // Also a friend.
            f.x = 10;
        }
    };
    
    // Can also define outside:
    // void foo(Foo &)
    // void Foo::bar(Foo &)
    
    int main() {
        Foo f;
        foo(f);
    
        Foo::bar(f); // вызов статической функции
    }
```
* **Отличия struct/class.**

    В struct по дефолту все методы публичны, если явно не указана private секция. Наследование тоже публично, если явно не указано private. У class все ровно наоборот: наследование приватное, методы и поля приватны, если явно не указана публичная секция.

* **Вложенные классы**
```c++
    #include <iostream>
    
    struct Foo {
        void foo() {
            bar();
        }
        void bar() { // заметим, что внутри класса можно вызывать методы без 
            foo();   // предварительного declaration, чего нельзя делать вне структуры
        }
    
        struct Bar {
        };
    };
    
    int main() {
        Foo::Bar b; // вызов вложенной структуры Bar
    }
```

**Агрегатная инициализация простых классов через {}**
    Мы можем инициализировать поля простого класса таким способом с C++11. Если не все поля структуры переданы в {} будет warning, но поле просто примет дефолтное значение.
```c++
    #include <iostream>
    
    struct ratio {
        int num;
        int denom;
    };
    
    int main() {
        // aggregate initialization. Looks like an automatically generated constructor
        [[maybe_unused]] ratio r1{};
        [[maybe_unused]] ratio r2{3};  // num = 3, warning about missing 'denom' initializer
        [[maybe_unused]] ratio r3{3, 4};  // num = 3, denom = 4
    }
```



</details>

<details>
<summary>
 Статические члены класса
</summary>

Обычные члены класса относятся к конкретному объекту. Статические члены же относятся ко всему классу. 
```c++
struct Foo {
    Foo() {
        Foo::objectCount++;
    }
    static int objectCount;
};

int Foo::objectCount = 0; // exactly one definition in exactly one TU!

int main() {
    std::cout << Foo::objectCount << '\n';  // 0
    Foo a1;
    Foo a2;
    std::cout << Foo::objectCount << '\n';  // 2
}
```
### Статические поля
Обратите внимание, что в примеры выше поле `objectCount` **объявлено и определено раздельно**.

Почему так? Потому что непонятно, где нужно выделить память на это поле. Где мы определили, там и выделится.

Кроме того определение статического поля должно быть **одно и только в одной единице трансляции**. ODR.

#### Слово `inline`
Если хочется всё-таки объявить поле внутри класса, то можно добавить ключевое слово `inline`. Тогда объявление вне класса не нужно, а также добавляется классический смысл `inline`, что можно определить в нескольких единицах трансляции, но программист гарантирует, что они будут одинаковы.


```c++
struct Foo {
    static inline int x = 1;
    static inline int y;
};

int Foo::y = 1;  // also fine
```

### Обращение к статическим членам
Предполагаемое обращение к статическим члена это `Foo::member`, но для удобства можно и по-другому:
```c++
struct Foo {
    static inline int x = 1;
    static void bar() {}
    void baz() {
        Foo::x;
        Foo::bar();

        x;
        bar();

        this->x;
        this->bar();
    }
};

int main() {
    Foo::x;
    Foo::bar();
    
    Foo obj;
    obj.x;
    obj.bar();
}
```
На статические члены также ожидаемым образом влияют `public/protected/private`. Но объявить статическое поле снаружи тоже можно.
```c++
struct Foo {
private:
    static int x;
};

int Foo::x = 0;  // ok!

// int a = Foo::x  // can't access private!
``` 

### Порядок инициализации и удаления статических полей
Статические поля имеют static storage duration (см. [билет 15](https://github.com/khbminus/CppTickets/blob/master/tickets/ticket15.md)), поэтому внутри единицы трансляции гарантируется, что инициализация в том порядке, как она записана в файле (кроме некоторых `const`! так как они инициализируются через *const initialization* обычно сразу на этапе компиляции).

Порядок удаления неочевиден (под разными компиляторами даже по-разному).

Больше про это можно прочитать в [билете 33](https://github.com/khbminus/CppTickets/blob/master/tickets/ticket33.md) про static initialization fiasco.

### Статические константы
Если поле сделать `integral` (типа, которое ~почти int: `int`, `char`, `long`, etc.) поле константным, то его можно сразу инициализировать через initializer:

```c++
struct Foo
{
    const static int n = 1;
    const static int m{2};  // Since C++11
    const static int k;
};
const int Foo::k = 3;
```

#### Беды с константами
Кроме этого могут происходить беды с указателями на константы, например:

```c++
// foo.h
struct Foo {
    static const int N = 60; // объявление
}
// fst.cpp
... Foo::N ... // ОК
... &Foo::N ... // может быть undefined reference на этапе линковки
// snd.cpp
... Foo::N ... // ОК
... &Foo::N ... // может быть undefined reference на этапе линковки
```

В чем проблема? У константы должно быть и объявление, и должно быть определение ровно в одной единицы трансляции. Для решения проблемы добавляем определение констант.

```c++
// foo.h
struct Foo {
    static const int N = 60; // объявление
}
// fst.cpp
const int Foo::N; // инициализация и слово `static` не нужны
... Foo::N ... // ОК
... &Foo::N ... // ОК
// snd.cpp
... Foo::N ... // ОК
... &Foo::N ... // ОК
```
Если не писать inline, то необходимо эту константу определить ровно в одном cpp файле, иначе ошибка компиляции (пример выше). Если в двух и более файлах написали определение, то ошибка компиляции.

Если пишем inline, то больше ничего определять не нужно.

```c++
// foo.h
struct Foo {
static inline const int N = 60;
}
// fst.cpp
... Foo::N ... // ОК
... &Foo::N ... // ОК
// snd.cpp
... Foo::N ... // ОК
... &Foo::N ... // ОК
```

Ровно так следует писать константы по мнению Егора.
### Статические методы, отличия от свободных функций и друзей
В статических методах, как можно догадаться, не видно `this`. Обращаться можно только к статическим членам.

Все статические методы сразу `inline`.

* От свободных функций отличаются уровнем доступа: у `static` полный доступ.
* От друзей отличаются синтаксисом. Теоретически можно написать то же самое, но обычно хочется вложить другой смысл.

### Паттерн: статический метод как конструктор с именем
Допустим, хочется класс прямоугольник. Хочется уметь создавать его по координатам левого-нижнего и правого-верхнего концов: `x1`, `y1`, `x2`, `y2`, а также по координате левого-нижнего конца, ширине и высоте: `x1`, `y1`, `width`, `height`.

И то, и то - четыре int, значит signature одинаковый, поэтому компилятор не поймёт, какой вы хотите конструктор.

Вместо этого можно сделать два статических метода вместо конструктора:
```c++
struct Rectangle {
    Rectangle(...) {...}

    static Rectangle makeFromPoints(int x1, int y1, int x2, int y2) {
        return Rectangle(...);
    }

    static Rectangle makeFromWidthAndHeight(int x1, int y1, int width, int height) {
        return Rectangle(...);
    }
};
```

### Неочевидные источники:
* https://github.com/vladnosiv/hse-spb-conspects-2020/blob/master/C%2B%2B/all-tickets.md#%D0%B1%D0%B8%D0%BB%D0%B5%D1%82-01-%D0%B4%D0%B5%D1%82%D0%B0%D0%BB%D0%B8-%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%BE%D0%B2
* https://olympiads.ru/zaoch/2018-19/lang_docs/cppreference.com/reference/en/cpp/language/static.html
</details>

<details>
<summary>
 24. Преобразования
</summary>


Преобразование одного типа в другой.  
Бывают явные(explicit) и неявные(implicit).  
Явные — программист чётко прописывает, что хочет преобразовать тип:

```C++
double a = 123.4;
int b = static_cast<int>(a); // кастуем a к int
```

```C++
struct foo{ foo(int){} }
void bar(foo){}
int main{
    int k = 2;
    bar(foo(k)); // создаём объект foo от k и передаём в функцию
}
```

Неявные — умняш компилятор сам догадывается, что во что нужно преобразовать.

```C++
double a = 123.4;
int b = a; // компилятор сам понял, что хотим привести double к int
```

```C++
struct foo{ foo(int){} };
void bar(foo){}
int main(){
    int k = 2;
    bar(k); // компилятор догадался создать foo от int k и передать его в функцию bar
}
```

### Implicit

```C++
#include <iostream>

struct ratio {
    int num;
    int denom;
    
    // конструктор без параметров
    ratio() {
        num = 0;
        denom = 1;
        std::cout << "Default constructor\n";
    }
    
    // конструктор с параметром типа int
    ratio(int value) {
        num = value;
        denom = 1;
        std::cout << "ratio(int)\n";
    }
};

// функция ожидает на вход константную ссылку на объект типа ratio
void println(const ratio &r) {
    std::cout << r.num << " " << r.denom << "\n";
}

ratio generate_ratio() {
    return 123; // превращается в return ratio(123);
}

int main() {
    ratio r = 10; // вызывается конструктор ratio(int)
    println(r); 
    println(10); // println(ratio(10));
    println(generate_ratio());
}
```

В коде выше 3 раза происходит неявное преобразование.  
Для `ratio r = 10;` компилятор выполнил то же самое, что выполнил бы для `ratio r = ratio(10);`, то есть произошло
неявное преобразование int — 10 к ratio.  
`println(10)` здесь — это `println(ratio(10))`.  
Наконец

```C++
ratio generate_ratio() {
    return 123;
}
```

есть на самом деле

```C++
ratio generate_ratio() {
    return ratio(123);
}
```

Во всех трёх случаях компилятор пытается найти конструктор, в который может передать int и неявно его использовать.

#### Пытливые умы спросят

Что если сделать `ratio r = 1.4;`?  
В этом случае компилятор запустит цепочку преобразований double->int->ratio. Подробнее об этом в последнем параграфе.

### Почему неявные преобразования — не всегда хорошо?

```C++
void print_vector([[maybe_unused]] const std::vector<int> &vec) {
}

int main() {
    [[maybe_unused]] std::vector<int> v1(10); // Норм
    [[maybe_unused]] std::vector<int> v2 = 10; // Не норм
    print_vector(10); // Почему, а главное зачем?
}
```

Существует конструктор vector(int n), который создаёт вектор из n дефолтных значений.  
Но тогда почему бы не вызвать неявно `[[maybe_unused]] std::vector<int> v2 = 10;`?  
Потому что выглядит ~~всрато~~ не интуитивно. Вполне разумно было бы ожидать от такой конструкции получить вектор {10,
}.  
Совсем странно выглядит `print_vector(10);`
Вроде хотим вывести вектор, а аргумент — число. Непорядок.  
Благо в stl умные дяди позаботились и _предусмотрели_, поэтому эта штука не скомпилируется, но если бы вместо
стандартного vector мы бы использовали самописную структуру

```C++
struct my_vector {
    my_vector() {}
    my_vector(int) {}
};
```

всё скомпилировалось бы.

### Чтобы не напороться на такую проблему существует Explicit.

Помечаем конструктор словом explicit и запрещаем неявные преобразования.

```C++
struct my_vector {
    my_vector() {}
    explicit my_vector(int) {}
};
```

Теперь можем только явно вызвать конструктор от int.

```C++
    [[maybe_unused]] my_vector v1(10); // Компилится
    [[maybe_unused]] my_vector v2 = static_cast<my_vector>(10); // Компилится
    // [[maybe_unused]] my_vector v2 = 10; // Не компилится
    // print_vector(10); // Не компилится
```

`static_cast<T>` — явное преобразование к типу T.

#### Explicit можно использовать для конструкторов с несколькими параметрами или без параметров

Например, хотим запретить неявно создавать объект при помощи `{}`.  
Это полезно, потому что зачастую `Object{a, b, c}` интуитивно понятнее и логичнее, чем `{a, b, c}` 

```C++
struct Foo {
    explicit Foo() {}

    explicit Foo(int, std::string) {}
};

void call(const Foo &) {
}

Foo ret() {
    return Foo{}; // OK
    // return {}; // BAD

    return Foo{10, "hello"}; // OK
    // return {10, "hello"}; // BAD
}

int main() {
    [[maybe_unused]] Foo f1{10, "hello"}; // OK
    // [[maybe_unused]] Foo f2 = {10, "hello"}; // BAD

    [[maybe_unused]] Foo f3{}; // OK

    [[maybe_unused]] Foo f4 = Foo{}; // OK
//    [[maybe_unused]] Foo f4 = {}; // BAD

    call(Foo{10, "hello"}); // OK
    // call({10, "hello"}); // BAD

    call(Foo{}); // OK
    // call({}); // BAD
    ret();
}
```

#### Можно ли запретить только некоторые неявные преобразования?

> По умолчанию нельзя, но в конце 4 модуля можно будет разрешить преобразование в произвольный тип, а потом вызывать ошибку компиляции, если он не совпал с желаемым. Но там больно.
> —Егор

### Операторы преобразования

#### Проблема

```C++
struct ratio {
    int num;
    int denom;
};

int main() {
    ratio r{3, 4};
    double x = r; // Нельзя
}
```

Не можем преобразовать объект нашего класса в double, потому что в double нет конструктора от ratio. Можно было бы
дописать, будь он нашим классом, но double, во-первых, не наш, во-вторых, не класс.

#### Решение

```C++
struct ratio {
    int num;
    int denom;

    operator double() const {
        std::cout << "operator double()\n";
        return num * 1.0 / denom;
    }
};
```

Дописали `operator double() const{}` теперь наш ratio умеет конвертироваться в double.

#### Приятный побочный эффект

Начинает работать

```C++
ratio r{3, 4};
std::cout << r << "\n";
```

Потому что `std::cout` умеет работать от double, а ratio теперь умеет неявно преобразовываться в double.  
То есть на самом деле код выше отработает, как
```C++
ratio r{3, 4};
std::cout << r.operator double() << "\n"; // явное преобразование к double
std::cout << static_cast<double>(r) << "\n"; // то же самое
```

### Можно пометить оператор explicit

```C++
struct ratio {
    int num;
    int denom;

    epxlicit operator double() const {
        std::cout << "operator double()\n";
        return num * 1.0 / denom;
    }
};
```

Например, решили, что не хотим неявно преобразовывать в double, чтобы не потерять точность.

```C++
ratio r{3, 4};
double x = r; // не скомпилируется, потому что запретили неявное преобразование
double x = static_cast<double>(r); // явное преобразование к double — работает
std::cout << x << "\n";
std::cout << static_cast<double>(r) << "\n"; // тоже явное, тоже работает
```

### Ошибки из-за неоднозначности

```C++
struct Foo {
    // оператор преобразования Foo к Bar
    operator Bar() {
        return Bar{};
    }
};

struct Bar {
    Bar() {}
    // конструктор Bar от Foo
    Bar(Foo /*arg*/) {}
};

int main() {
    Foo f;
    Bar b = f;  // ambiguous
}
```

Foo умеет преобразовываться в Bar, но и Bar умеет создаваться от Foo.  
То есть имеем два способа преобразовать Foo к Bar, между которыми компилятор не может выбрать, поэтому не компилирует
вовсе.
#### Можно починить
Для этого пометим один из методов explicit
```C++
struct Bar;

struct Foo {
    operator Bar();
};

struct Bar {
    Bar() {}

    explicit Bar(Foo /*arg*/) {
        std::cout << "Bar(Foo)";
    }
};

Foo::operator Bar() {
    std::cout << "Foo::operator Bar()";
    return Bar{};
}

int main() {
    Foo f;
    Bar b = f;
}
```
Теперь неявно может вызваться только `Foo::operator Bar()`, это и произойдёт.

### Возвращаясь к неявным преобразованиям

#### Порядок преобразований

Последовательность преобразований состоит из:
<ol>
  <li>0 или 1 стандартная последовательность преобразований.</li>
  <li>0 или 1 пользовательское преобразование.</li>
  <li>0 или 1(только если было выполнено пользовательское преобразование) стандартная последовательность преобразований.</li>
</ol>

Стандартная последовательность преобразований — например, преобразование между численными типами. Подробнее про это
можно почитать [здесь](https://en.cppreference.com/w/cpp/language/implicit_conversion)

##### Пример

```C++
struct Foo {
    Foo(int) {}
};

struct Bar {
    Bar(const Foo&) {}
};

void call_with_bar(const Bar&) {
}

int main() {
    // На стандартные преобразования тип 'Bar -> const Bar' забиваем, но вообще они есть.
    call_with_bar(Bar(Foo(10)));  // все преобразования явные
    call_with_bar(Bar(Foo(10LL)));  // стандартное неявное преобразование long long -> int
    call_with_bar(Foo(10));  // пользовательское неявное преобразование Foo -> Bar
    call_with_bar(Bar(10));  // пользовательское неявное преобразование int -> Foo
    call_with_bar(Bar(10LL));  // стандартное неявное преобразование long long -> int + пользовательское неявное преобразование int -> Bar
    // call_with_bar(10);  // два неявных пользовательское преобразование: int -> Foo -> Bar
}
```

Строчка `call_with_bar(10);` не скомпилируется, потому что ей требуется два пользовательских преобразования, а
допускается только 0 или 1.

##### Зачем такие ограничения?

Потому что в момент вызова `call_with_bar(10)` совершенно неясно почему и откуда должна взяться промежуточная структура
Foo, а ведь она может быть и не одна.

```C++
struct Foo {
    Foo(int) {}
};

struct Baz {
    Baz(int) {}
};

struct Bar {
    Bar(const Foo&) {}
    Bar(const Baz&) {}
};

void call_with_bar(const Bar&) {
}
int main() {
    call_with_bar(10);
}
```

Чтобы это заработало, пришлось бы перебирать все промежуточные вершины преобразований(int -> Foo -> Bar или int -> Baz
-> Bar), а это долго, сложно, и стреляло бы по ногам, поэтому запретили.

### std::string — обычный пользовательский тип

Он определен в стандартной библиотеке, но с точки зрения языка ничем не примечателен. Отсюда следующее:

```C++
#include <string>

struct Foo {
    Foo(const std::string&) {}
};

void call_with_foo(const Foo&) {
}

int main() {
    call_with_foo(Foo(std::string("hello"))); // все преобразования явные
    call_with_foo(Foo("hello"));  // неявное пользовательское преобразование const char[6] -> std::string
    call_with_foo(std::string("hello")); // неявное пользовательское преобразование std::string -> Foo
    // call_with_foo("hello");  // требуется 2 неявных преобразования

    {
        using namespace std::literals; // используем стандартные литералы
        call_with_foo("hello"s);  // "hello"s — это std::string, 
                                  // поэтому здесь 1 неявное преобразование string -> Foo
    }
}
```

### Оператор bool

Позволяет преобразовывать объект к bool, например

```C++
while(std::cin >> x){}
whlie((std::cin >> x).operator bool()){}
```

это две одинаковых строчки.

#### Проблема

С точки зрения языка bool — это число и его легко неявно преобразовать к int. Причём такое преобразование является
стандартным, а не пользовательским.  
Из-за этого можно сделать вот так:

```C++
#include <iostream>

struct Foo {
    operator int() {
        return 10;
    }
};

struct Bar {
    operator bool() {
        return true;
    }
};

int main() {
    [[maybe_unused]] Foo f;
    [[maybe_unused]] Bar b;
    [[maybe_unused]] bool x1 = f;  
    [[maybe_unused]] bool x2 = b;  

    if (f) {}
    if (b) {}

    for (; f;) {}
    for (; b;) {}

    while (f) {}
    while (b) {}

    [[maybe_unused]] int x3 = 10 + f;
    [[maybe_unused]] int x4 = 10 + b;
}
```

Foo и Bar могут быть какими-то сложными структурами, а мы используем их как bool или int.  
Использовать Bar как bool — нормально, потому что у него для этой цели определён operator, но очевидно не ожидалось, что
кто-то будет использовать этот класс для арифметики.  
Аналогично и Foo предполагалось преобразовывать только к int, но никак не к bool.  
В C++03 с этим боролись при помощи [safe bool idiom](https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Safe_bool).

#### Начиная с C++11 решение приятное и лаконичное.

Просто дописываем к операторам explicit, чтобы запретить неявные преобразования.

```C++
#include <iostream>

struct Foo {
    explicit operator int() {
        return 10;
    }
};

struct Bar {
    explicit operator bool() {
        return true;
    }
};

int main() {
    [[maybe_unused]] Foo f;
    [[maybe_unused]] Bar b;
    // [[maybe_unused]] bool x1 = f;
    // [[maybe_unused]] bool x2 = b;

    // if (f) {}  // неявное преобразование int -> bool запрещено
    if (b) {}  // преобразовали к bool

    // for (; f;) {}
    for (; b;) {}

    // while (f) {}
    while (b) {}
    
    [[maybe_unused]] int x3 = 10 + static_cast<int>(f); // явно преобразовали к int
    // [[maybe_unused]] int x3 = 10 + f; // не срабоатет, потому что неявное
    // [[maybe_unused]] int x4 = 10 + b; 
}
```

Теперь Bar можем использовать только как bool, а Foo только как int и только при явном преобразовании.  
Важно заметить, что по стандарту языка внутри конструкций `if, for, while` преобразование к bool является **явным**.

</details>

<details>
<summary>
 Функторы и лямбды  
</summary>


Функциональный объект, иногда называемый функтор - что угодно, к чему применима семантика вызова, как у функции.

Функторами могут быть:

* функции
* указатели на функции 
* объекты с перегруженным `operator()`

### `operator()`

```c++

struct Greater {
	bool operator()(int a, int b) const {
		return a > b;
	}
	bool operator()(int a) const {                    // overloads are possible
	    return a > 0;
	}
	bool operator()() const {
	    return true;
	}
};

int main() {
	const Greater comparator;

	std::cout << comparator.operator()();              // true
	std::cout << comparator.operator()(-8);            // false
	std::cout << comparator.operator()(100, 99);       // true

	std::cout << comparator();                         // true
	std::cout << comparator(-8);                       // false
	std::cout << comparator(100, 99);                  // true

	std::cout << Greater().operator()();               // true
	std::cout << Greater()(-8);                        // false
	
	std::vector<int> vec{1, 2, 3, 4, 5, 6, 7, 8}; 
	std::sort(vec.begin(), vec.end(), comparator);     // will reverse vector
}

```

`operator()` логично помечать `const`, т.к. обычно функторам не нужно мутировать состояние


### использование функторов

В примере выше функтор передаётся в `std::sort` в качестве компаратора. Так же его моджно передать в `std::set`. Т.к.
set хочет скопировать компаратор в себя (как и почти всё в STL) и считает, 
что компаратор не может менять состояние при вызове, так что`operator()` придётся пометить `const`. 

```c++
int levenshtein_distance(std::string const& a, std::string const& b);


struct Closer {
    std::string template;

    bool operator()(std::string const& a, std::string const& b) const {  // 'const' is important
        return levenshtein_ditance(a, template) < levenshtein_ditance(b, template);
    }
};

int main() {
    using namespace std::literals;
    std::set<std::string, Closer> v1({"meow"s, "woof"s, "oink"s, "quack"s}, Closer{"meow"s});
    std::set<std::string, Closer> v2({"meow"s, "woof"s, "oink"s, "quack"s}, Closer{"woof"s});
}

```

При присвоении `std::set` компараторы тоже поменются. 

Обычно аргументы в `operator()` передают по констанной ссылке - очень странно, если компаратор хочет изменить свои аргументы, 
а копирование занимает время.  

Заметим, что из-за того, что большинство алгоритмов STL принимает функторы с семантикой копирования, при передаче 
функтора, как аргумента в алгоритм `std::all_of`, `std::any_of`, `std::for_each` и т.д. состояние функтора никак не поменяется.
`std::for_each` возвращает функтор после применения его к аргументам, так что в его состоянии всё-таки можно что-то хранить.

```c++
struct Functor {
	int val = 0;
	void operator()(int) {
		val++;
	}
};

int main() {
	Functor c;
	std::vector<int> v(100, 0);
	auto used = std::for_each(v.begin(), v.end(), c); // Если operator() менял состояние c, то этот вызов отразится на c
	std::cout << c.val << std::endl;                  // 0
	std::cout << used.val << std::endl;               // 100
}

```

Функторы можно складывать в  `std::function`, при этом он копируется в объект с dynamic storage duration
(ну если там нет small object optimization)

Для хранения ссылок на функторы есть тип `std::reference_wrapper` из библиотеки `functional`, 
который позволяет сохранять ссылки на функторы в `std::vector` или
где-нибудь ещё и прокидывает наверх `operator()`, оставляя возможность вызывать функтор, лежащий по ссылке.
При этои если у хранимого объекта нет такого оператора с подходящей сигнатурой код не скомпилируется (см. perfect forwarding
и ленивое раскрытие шаблонов)

Канонический способ создания `std::reference_wrapper` -  `auto func = std::ref(functor);`

У этого типа есть метод `get`, возвращающий обычную ссылку на объект, на который ссылается `std::reference_wrapper`.

Теперь функторы можно передавать в алгоритмы stl


```c++
struct Functor {
	int val = 0;
	void operator()(int) {
		val++;
	}
};

int main() {
	Functor c;
	std::vector<int> v(100, 0);
	std::for_each(v.begin(), v.end(), std::ref(c)); // Если operator() менял состояние c, то этот вызов отразится на c
	std::cout << c.val << std::endl;                // 100
}
```
`std::reference_wrapper` не владеет, тем на что ссылается и может быть висячим.

### лямбды

Лямбда-выражения - синтаксический сахар для создания функторов. Тип созданного функтора невозможно описать,
поэтому сохранять объекты этого типа можно только через `auto` или, если
выражение такого типа уже можно написать, то при помощи `decltype`. Синтаксис лямбда-выражения `[<capture>](<arguments>){<body>}`.
Тип возвращаемого функтором значения выводится сам (на самом деле его можно задать используя синтаксис `-> Type`).


Поля получившегося объекта функтора описываются в замыкании:

* `[=]` - все используемые в теле выражения переменнные из текущего scope копируются внутрь функтора.
* `[&]` - все используемые в теле выражения переменнные хранятся в функторе по ссылке.
* `[this]` - текущий `this` захватывается по ссылке
* `[\*this]` - текущий `this` захватывается по значению
* `[name = expression]` - создаём у функтора новое поле name, присваиваем туда `expression` (тип поля выведется сам)
* `[&name = expression]` - создаём у функтора новое поле=ссылку name на `expression` (тип поля выведется сам)
* `[name]` - копируем в функтор переменную `name`
* `[&name]` - храним в функторе ссылку на переменную `name`

Эти замыкания можно комбинировать всеми способами, более конкретные перекрывают менее конкретные.

Про `[&name = expression]` нужно отметить, что никак пометить в замыкании, что ссылку нужно брать именно константную не выйдет,
поэтому нужно сделатьт так, стобы тип `expression` сожержал категорию константности. Стандартый способ сделать это
`[&name = std::as_const(expression)]` ну или `[&name = static_cast<Type const&>(expression)]`.

По умолчанию `operator()` у получившегося функтора помечен, как `const`. Избежать этого можно, добавив слово `mutable` перед телом лямбды.

Примеры

```C++
int main() {
    int a = 0, b = 1, c = 2;
    auto first = [=, &a]() mutable {
	     std::cout << a << " " << b++ << " " << c << std::endl;
	};
    decltype(first) second = first;
    first();                             // 0 1 2            
    first();                             // 0 2 2
    second();                            // 0 1 2
    a = b = c = 100;
    first();                             // 100 3 2
    second();                            // 100 2 2
}
```


```C++
int main() {
    auto lambda = [val = 0](int) mutable { std::cout << val++ << '\n'; };
    std::vector<int> v(100, 0);
    std::for_each(v.begin(), v.end(), lambda); // numbers from 0 to 99
}
```

[раскрывается так](https://cppinsights.io/lnk?code=I2luY2x1ZGUgPGlvc3RyZWFtPgojaW5jbHVkZSA8dmVjdG9yPgojaW5jbHVkZSA8ZnVuY3Rpb25hbD4KCmludCBtYWluKCkgewogICAgYXV0byBsYW1iZGEgPSBbdmFsID0gMF0oaW50KSBtdXRhYmxlIHsgc3RkOjpjb3V0IDw8IHZhbCsrIDw8ICdcbic7IH07CiAgICBzdGQ6OnZlY3RvcjxpbnQ+IHYoMTAwLCAwKTsKICAgIHN0ZDo6Zm9yX2VhY2godi5iZWdpbigpLCB2LmVuZCgpLCBsYW1iZGEpOyAvLyBudW1iZXJzIGZyb20gMCB0byA5OQp9Cg==&insightsOptions=cpp17&std=cpp17&rev=1.0)

Поля структуры нельзя захватить по отдельно от всего объекта - приходится захватывать `[this]` или `[*this]`.

```c++

struct Foo {
  int a;
  auto copy_capture() {
  	return [*this](){
      std::cout << a << std::endl;
    };
  }
};

int main()
{
  auto lambda1 = Foo{1}.copy_capture();
  lambda1(); // no dangling reference
}

```

[раскрывается так](https://cppinsights.io/lnk?code=I2luY2x1ZGUgPGlvc3RyZWFtPgoKc3RydWN0IEZvbyB7CiAgaW50IGE7CiAgYXV0byBjb3B5X2NhcHR1cmUoKSB7CiAgCXJldHVybiBbKnRoaXNdKCl7CiAgICAgIHN0ZDo6Y291dCA8PCBhIDw8IHN0ZDo6ZW5kbDsKICAgIH07CiAgfQp9OwoKaW50IG1haW4oKQp7CiAgYXV0byBsYW1iZGExID0gRm9vezF9LmNvcHlfY2FwdHVyZSgpOwogIGxhbWJkYTEoKTsgLy8gbm8gZGFuZ2xpbmcgcmVmZXJlbmNlCn0=&insightsOptions=cpp17&std=cpp17&rev=1.0)


Довольго популярна идиома передачи в лямбды `[field = std::move(value)]` - 	это, например, единственный способ передать
в лямбду `std::unique_ptr`. Растаманского `move` тут нет, поэтому каждое такое поле придётся перемещать руками.

</details>

<details>
<summary>
</summary>


**Важно знать**: порядок инициализации переменных между единицами трансляции неопределен!

### Что делает #include, в том числе #include <iostream> и `#include <iosfwd>`:

1) `#include "header.h"/<lib>` - просто вставляет код из `header.h/lib` в текущую единицу трансляции
2) `#include <iostream>` - включает стандартную библиотеку ввода/вывода в текущую единицу трансляции (`<>` - используются для встроенных библиотек, `""` - для собственных header-файлов)
3) `#include <iosfwd>` - этот заголовок содержит forward declaration для стандартной библиотеки ввода/вывода.



### Мотивация:
1. Зачем линковка, когда есть `#include`, отличия:

	**При линковке** мы можем сначала скомпилировать все файлы отдельно друг от друга, получив объектные файлы, а затем слинковать их как захотим. Например, есть файл `main.cpp`, он вызывает `print()` функцию. Мы можем создать 2 файла `print1.cpp` и `print2.cpp`, сделать независимо компиляцию каждого (`g++ -c main.cpp print1.cpp print2.cpp`), а далее слинковать полученные `main.o` и `print1/2.o` попарно (`g++ main.o print1.o -o a.exe`, `g++ main.o print2.o -o b.exe`), так получаем 2 `exe`-файлика, которые используют разные функции.

	Также важно помнить, что функция может иметь ровно определение (по правилу `ODR - One Definition Rule`) в какой-либо единице трансляции (definition: тело функции `void foo() {...}`), но сколько угодно много объявлений (declaration: `void foo();`). Структуры могут иметь определения для своих методов в разных единицах трансляций, но эти определения должны полностью совпадать (в таких случаях делают header-файл c объявлением структуры и ее полей/методов, а в отдельной одной единице трансляции пишут определения для методов).

	`#include<something>` - просто скопирует содержимое файла `something` и вставит в файл с include'ом, при этом размер текущего файла увеличится.


### Единицы трансляции и файлы:
`.cpp`-файл - это `translation unit` (единица трансляции), код разбивается на несколько файлов, чтобы было удобнее его читать + компилировать каждый файл отдельно (`g++ -c main.cpp` - создаст объектный (бинарный) файл `main.o`).


**UB:** 
	
1. Разные параметры по умолчанию в объявлении и определении функций
	
2. Разные типы данных в объявлении и определении, возвращаемые функцией


### Как из одного файла заиспользовать глобальный класс/функцию из другого:

1. **Функции**: в 1 единице трансляции мы определяем функцию (function definition: `void foo(int x) {[body of the function foo]}`), во всех других только пишем объявление этой функции (function declaration: `void foo(int x);`)

2.1. **Классы/структуры**: если не использовать `header`-файлы, то это боль, нужно в каждой единице трансляции *заново прописывать **определения членов** структуры* и **объявления ИЛИ определения методов (при этом определения в разных единицах трансляции должны совпадать - copy-paste)**; тут легко напороться на `UB`, поменяв местами определения членов структуры (UB так как удаляет объект текущая единица трансляции, поэтому если поля имеют другое расположение, то порядок удаления полей не соответствует их расположению в памяти). Вот [пример кода с лекции](https://github.com/hse-spb-2021-cpp/lectures/tree/master/06-211006/08-struct-ub).

2.2. **Классы/структуры**: с использованием header-файлов все просто: мы 1 раз *объявляем* все поля/методы структуры в каком-нибудь `my_struct.h` файле, далее в 1 единице трансляции (`my_struct.cpp`) пишем определения для методов. Если в каком-либо файле нам понадобиться эта структура, то мы просто включаем ее в нужный файл `#include "my_struct.h"` (при этом не забываем про `guards` в header-файлах).
	


### External linkage/internal linkage:

`Internal linkage` - данный тип линковки обозначает, что сущность (переменная, функция, структура) будет видна только в данной единице трансляции (в текущем `.cpp`-файле).

`External linkage` - данный тип линковки обозначает, что сущность будет видна всем единицам трансляции, которые мы решили скомпилировать вместе. Другими словами, доступна через всю программу, которая представляет собой комбинацию всех единиц трансляции.


1. **Слово `static` и `unnamed namespace`, где применять:**

1) `static`: если мы хотим, чтобы *глобальная функция* была видна только в текущей единице трансляции, то мы может перед ее типом написать слово `static`, и данная функция не будет видна другим единицам трансляции (также `static` делаем сущность *статической*, то есть она инициализируется в программе 1 раз и не умирает до завершения самой программы). Примеры:

```cpp
// foo.cpp

static int foo() {
	return 100;
}

int bar() {
	return 100;
}
```

```cpp
// main.cpp

foo();
bar();

int main() {
	foo(); // ERROR: undefined reference
	bar(); // works fine
}
```

2) `unnamed namespace`: нужен, чтобы переменная/функция/сущность была долступна только текущей единице трансляции. Пример:

```cpp
// foo.cpp
namespace {
	int foo() {
		return 10;
	}
}

int calc() {
	int x = foo();
	return x * x;
}
```

```cpp
// main.cpp

int foo();
int calc();

int main() {
	foo(); // ERROR
	calc(); // works fine
}
```





### Формулировка `One Definition Rule`, формулировка `IFNDR` (**Ill-Formed, No Diagnostic Required**):
	
1. **Формулировка `One Definition Rule`:** у любой сущности (функции/глобальной переменной) должно быть ровно 1 определение на всю программу (программа - все translation units, что есть в проекте)

2. **Формулировка `IFNDR`:** есть сущность имеет не 1 определение, то возникнет UB сразу после запуска программы (даже до выполнения main()), компилятор не обязан сообщать о некорректности программы

	
1) Пример ошибок линковщика: `multiple definition`, `undefined reference`:
```cpp
// multiple definition example: - имеем несколько определений для сущности

// foo.cpp
void foo() {...}
```

```cpp

// main.cpp
void foo() {...}

int main() {
}

// compile both and you will get an error: 

// g++ main.cpp foo.cpp;
// ./a.exe -> ERROR: multiple definition of 'foo()'
```

```cpp
// undefined reference example: - не имеем ни одно определения для сущности, однако пользуемся ею

// foo.cpp - leave empty
```

```cpp
// main.cpp

void foo();

int main() {
	foo();
}
// complie both and error will occur: 

// g++ main.cpp foo.cpp;
// ./a.exe -> ERROR: undefined reference to 'foo()'
```

2) Что происходит с перегрузками функций: перегрузки разрешаются на уровне компилятора, а не линковщика, поэтому **иметь одну функцию с разными перегрузками нормально**:

```cpp

// foo.cpp
void foo(int x) {...}
```

```cpp
// main.cpp
void foo(int x);
void foo() {...}

int main() {
	foo(10);
	foo();
}
// works fine, no ODR violation
``` 



### Типичный заголовочный файл:

1. Конвенция именования заголовочных файлов: 

	Правильное название для `guard'a` в `header`-файле будет `[filename uppercased]_H_` (здесь `[filename uppercased]` - название текущего файла, в котором пишется `guard`, заглавными буквами).

2. `Include guards`: зачем, как правильно, осторожно с `_`:
		
	Если начать название `guard'а` с `_A`, `__A` (`A` - любая заглавная буква), то это `UB` (такие названия запрещены к использованию).


**`Note:`** 

Если не делать `include-guards`, то возможна ситуация: мы имеем структуру `Foo` в `"header1.h"` файле, далее мы написали `#include "header1.h"` в каком-нибудь `"header2.h"` файле, а затем в `main.cpp` сделали `#include "header1.h"` и `#include "header2.h"`, так мы получили ошибку `"multiple definition of struct Foo"`, чтобы такого не произошло делают следующее:

```cpp
#ifndef HEADER1_H_
#define HEADER1_H_

struct Foo {...};

#endif // HEADER1_H_

// Так при первом включении header1.h в main.cpp мы объявим HEADER1_H_ и при втором include в header2.h второго подключения не случится

```


3. Опасность неявного включения, концепция include what you use, примеры из стандартной библиотеки вашего компилятора (`exercises/01-210906/07-missing-include`):

	Опасность неявного включения: на различных компиляторах код может либо компилироваться, либо нет. (смотри [exercises/01-210906/07-missing-include](https://github.com/hse-spb-2021-cpp/exercises/blob/master/01-210906/07-missing-include.cpp)).

	Важно сделать так, чтобы порядок `#include`-ов в единице трансляции не имел значения и все .h-файлы были независмые, поэтому если в каком-то .h-файлы мы используем что-то из другого .h-файла, то мы обязаны в текущий заголовочный файл включить все header-файлы, что необходимы (принцип `include what you see`); [пример с лекции](https://github.com/hse-spb-2021-cpp/lectures/tree/master/06-211006/10-include).


4. Запрет на реализацию функций:

	Мы пишем только объявления функций в `header`-файлах (так принято делать, чтобы избежать `ODR`). Также можно использовать `inline`, но **не нужно**, так как считается **плохой практикой** 
		
	Смысл `inline`: функция может иметь несколько определений, но я, как программист, обещаю, что все эти определения равны, поэтому выбери любое.


5. Необходимость подключать заголовочный файл в файл с реализацией:

	В файл реализации мы должны подключить наш `.h`-файл, чтобы обезопасить себя от возможных `UB`, пример:

```cpp
// get.h

#ifndef GET_H_
#define GET_H_

float get(int x);

#endif
```

```cpp
// get.cpp

double get(int x) {
	...
}
```

```cpp
// main.cpp

#include "get.h"

int main() {
	get(10.0);
}

// g++ main.cpp get.cpp -o a.exe
// ./a.exe - UB!
```

Если в пример выше включить `get.h` файл в `get.cpp`, то компилятор выдаст ошибку компиляции, т.е. убережет от трудного `debugging'а`.





### Взаимная рекурсия между заголовками и `forward header`:
	
**Взаимная рекурсия:**

Проблема:

```cpp
// bar.h 

#ifndef BAR_H_
#define BAR_H_

#include "foo.h"

struct Bar {
    Foo *f;
};

void bar_do_something(Foo, Bar);

#endif  // BAR_H_

```

```cpp
// foo.h

#ifndef FOO_H_
#define FOO_H_

#include "bar.h"

struct Foo {
    Bar b{this};
};

#endif  // FOO_H_

// Здесь Bar не видит Foo, так как стоят guards, если убрать guards, то мы зациклим подключения
```

Решение:

```cpp
// Чтобы решить проблему, мы создаем foo_fwd.h файл, в котором не будет ничего кроме объявления структуры Foo: struct Foo;

// foo_fwd.h

#ifndef FOO_FWD_H_
#define FOO_FWD_H_

struct Foo;

#endif  // FOO_FWD_H_
```

#### Идея `forward header`:
Данные заголовочные файлы включают в себя только forward-declaration (то есть объявления) структур.

Если есть `foo_fwd.h` и `foo.h`, то в `foo.h` также нужно подключить `foo_fwd.h`, чтобы проверить, что у нас объявление и определения не отличаются типом данных, параметрами и тд.



1. Incomplete type: как объявить, что можно сделать с неполным типом: 

	1) Синтаксис: `struct Foo;`

	2) Неполного типа достаточно, что передавать указатели и ссылки на структуру, т.е. мы не выделяем память для новой структуры данного типа. Но ничего кроме как передать по ссылке/значению мы не умеем: не можем вызывать методы, обжащаться к полям, создавать instance данной структуры, так как мы не знаем сколько структура должна занимать памяти, а также не знаем какие поля и методы у нее определены, [код с лекции](https://github.com/hse-spb-2021-cpp/lectures/tree/master/06-211006/09-incomplete).

	3) Зачем надо: это укоряет компиляцию, так как нам не нужно парсить определение структуры.

	
2. Пример forward hearder из стандартной библиотеки (`<iosfwd>`):

	1. Если мы хотим для свой структуры реализовать оператор вывода, то нам необязательно в .h-файл подключать большую <iostream> библиотеку, мы можем просто объявить, что объект ios существует и все:

```cpp
// foo.h

#ifndef FOO_H_
#define FOO_H_

#include <iosfwd>

struct Foo {};

std::ostream& operator<<(std::ostream&, const Foo&);

#endif  // FOO_H_
```

```cpp
// foo.cpp
#include "foo.h"
#include <iostream>

std::ostream& operator<<(std::ostream& os, const Foo&) {
	return os << "hello world";
}
```




### Что обычно (не) пишут в своих заголовочных файлах (в том числе forward), `using namespace std`:

1. В заголовках **не пишут** определения функций, их выносят в соответствующие .cpp-файлы.

2. В заголовках **пишут** объявления сущностей, guards

3. В forward-заголовках пишут forward-declaration для структур (`struct Foo;`)

4. `using namespace std` - так не пишем, так как в случае, если есть какая-либо функция c совпадающим названием как в `std` в другой библиотеке, мы не сможем ее вызвать. 







## Other notes from `06-211006(I) — программы из нескольких файлов, СПб ВШЭ ПМИ, C++`:

### `namespaces`: 

1. `::` - global namespace.

2. `ns1::ns2` - nested namespace.

3. Поиск среди namespace'ов вверх по вложенности.

4. `(Un)qualified name lookup`:

```cpp
namespace ns1 {
	void foo() {...}
}

namespace ns1::ns2 {
	void bar() {
		foo(); // Unqualified name lookup for 'foo' - пытаемся найти foo() в текущем namespace'e потом на 1 уровень выше, потом на 2 выше и тд
		
		ns1::foo(); // Qualified name lookup for 'foo', Unqualified name lookup for 'ns1'
	}
}
```

5. `Argument dependent lookup`:

```cpp
namespace ns {
	struct Foo;

	void foo(Foo) {...}

	void foo() {...}
}

// compiles fine
int main() {
	ns::Foo f;
	foo(f); // найдет нужный 'foo' в 'ns', так как компилятор пытается посмотреть во все namespace'ы и найти там функцию foo с такими аргументами
	
	// это нужно, чтобы уметь писать операторы: f == f, ns::operator==(f, f) 
}

// does not compile
int main() {
	foo();
}

```

</details>

<details>
<summary>
</summary>


## ODR

ODR (One Definition Rule) - во всей программе (то есть включая все файлы) у любой сущности должно быть ровно одно определение. 
Определение с cppreference: Only one definition of any variable, function, class type, enumeration type, concept (since C++20) or template is allowed in any one translation unit (some of these may have multiple declarations, but only one definition is allowed).

### Что с перегрузкой функций
#### Напоминание про перегрузку функций: 
Есть несколько функций с одинаковым именем, но с разными типами аргументов. Тогда компилятор может выбрать наиболее подходящую перегрузку.
#### Что происходит внутри:
API (Application Programming Interface) - показывает, какой программный интерфейс у различных translation unit'ов. (Какие типы у аргументов функции, какие типы возвращаются, в каком namespace лежит и тд). Всё API запоминает компилятор и им можно пользоваться. (Подробнее - [лекция Егора](https://youtu.be/X-6unqJz_uY?list=PL8a-dtqmQc8obAqSKqGkau8qiafPRCxV7&t=1683))
```C++
void foo();
foo();
```
При компиляции все превращается в ABI (Application Binary Interface) - тоже самое, но более низкоуровневое. У компилятора есть регламенты, как и через что возвращается (через какие регистры процессора, через какие места памяти и тд). Например, поэтому нельзя компилировать разные части программы разными компиляторами, в итоге какие-то регламенты могут не совпасть.  
Затем происходит name mangling:
```C++
void foo(); -->  \_Z3foov // v - тип аргумента. 
```
Все это к тому, что перегруженные функции различаются компилятором и нарушения ODR не возникает. Пример:  
foo.cpp:
```C++
void foo(int) {
}
```
main.cpp:
```C++
void foo(int);
void foo() {
}

int main() {
    foo();
    foo(10);
}
```
### Пример ошибок линковщика
#### Multiple definition 
Функция имеет более одного определения.  
foo.cpp:
```C++
void foo() {
}
```
main.cpp:
```C++
void foo() {
}

int main() {
}
```
#### Undefined reference
Функция не имеет опрделения, но при этом где-то используется.
```C++
int main() {
    foo();
}
```
### Примеры IFNDR
IFNDR (Ill-Formed, No Diagnostic Required) - "программа некорректна, сообщать не требуется" - УБ в момент запуска, при этом компилятор об этом не сообщает. Ниже несколько примеров таких УБ (при этом все компилируется).
#### Несовпадение объявлений функций
Везде будет УБ, при этом компилятор не будет предупреждать нас об этом.
С аргументами:

С аргументами по умолчанию:  
foo.cpp:
```C++
void foo(int x = 10) {
    std::cout << x << "\n";
}
```
main.cpp:
```C++
void foo(int = 1000);

int main() {
    foo();
}
```
Возвращаемое значение:  
foo.cpp:
```C++
float foo() {
    return 1000000;
}
```
main.cpp:
```C++
#include <iostream>

double foo();

int main() {
    std::cout << foo();
}
```
#### Несовподение определений классов
Если структура определена в одной трансляции и используется в другой, то там, где она используется, нужно еще раз написать структуру, а также перечислить все ее поля и объявить все методы.
Если метод определен вне структуры:  
foo.cpp:
```C++
#include <vector>
#include <iostream>

struct Foo {
    int a = 10;
    std::vector<int> v;

    void method();
};

Foo get_foo() {
    return Foo{};
}

void Foo::method() {
    std::cout << "method() called " << a << "\n";
}
```
main.cpp:
```C++
#include <vector>
#include <iostream>

struct Foo {
    int a = 10;  // Should be exactly 10, IFNDR otherwise.
    std::vector<int> v;

    void method();
};

Foo get_foo();

int main() {
    get_foo().method();

    Foo f = get_foo();
    f.method();

    Foo f2;
    f2.method();
}
```
Метод может быть определен и в структуре. В этом случае везде нужно написать одно и тоже определение этого метода. При этом это не будет нарушением ODR (смотри inline в методах классов).  
foo.cpp:
```C++
#include <vector>
#include <iostream>

struct Foo {
    int a = 10;
    std::vector<int> v;

    void method() {
        std::cout << "method() called " << a << "\n";
    }
};

Foo get_foo() {
    return Foo{};
}
```
main.cpp:
```C++
#include <vector>
#include <iostream>

struct Foo {
    int a = 10;  // Should be exactly 10, IFNDR otherwise.
    std::vector<int> v;

    void method() {
        std::cout << "method() called " << a << "\n";
    }
};

Foo get_foo();

int main() {
    get_foo().method();

    Foo f = get_foo();
    f.method();

    Foo f2;
    f2.method();
}
```
#### Потенциальные проблемы с любыми глобальными переменными
Ниже программа с глобальной переменной write. Если ее запустить как обычно, то она успешно скомпилируется и сработает.
```C++
#include <iostream>

int write;

int main() {
    std::ios_base::sync_with_stdio(false);
    std::cout << 10;
}
```
Но если скомпилировать эту программу с ключом `-static` ("что значит возьми стандартную библиотеку и встрой ее внутрь exeшника"), то будет UB, так как в программе ODR-violation. В стандартной библиотеке есть глобальная функция с название write. Получилось, что в программе появилось два объекта с одинаковыми названиями. В данном случае процессор пытается вызвать переменную write как функцию. Мораль: используйте namespace!
### Использование inline-переменных/функций/методов для обхода ODR
Замечание: все сетоды, определенные внутри классов по умолчанию inline, но если метод определен вне класса, то inline не является (нужно указывать ручками). При этом это не расспространяется на поля классов.  
```C++
struct Foo {
    int x;
    
    /* inline */ void doSmthWithFoo() { // - inline подставляется автоматически
    }
}
```
Теперь как работает inline: раньше работало по типу макроса, возьми определение и вставь его вместо вызова. Сейчас компиляторы умнее, выбирают что сделать лучше, но точный смысл остался: функция может быть реализована в нескольких единицах трансляции, но одинаково. Вот пример кода с [лекции](https://github.com/hse-spb-2021-cpp/lectures/tree/master/08-211020/03-linkage/01-inline).
### Отличия inline от static/unnamed namespace
Static, примененный к сущностям работает как unnamed namespace. Таким образом данная сущность будет видна в данной единицы трансляции и не видна в других. Как пример: собственная библиотека с автотестами. Там могут найтись несколько функций с одинаковым названием в разных единицах трансляции. Используем static/unnamed namespace -- все хорошо.  
Ключевое отличие: если использовать static/unnamed namespace, то у сущности будет internal linkage (то есть сущность видна только в текущей единице трансляции). inline разрешает создавать определение в нескольких единицах трансляции, но при этом определения должны быть одинаковыми и все помечены inline.



















</details>

<details>
<summary>
 Static initialization order fiasco
</summary>

### О чём это
Рассмотрим программу, состоящую из нескольких единиц трансляции: `a.cpp` и `b.cpp`. Пусть в `a.cpp` и `b.cpp` создаются объекты с статическим временем жизни (см. [билет 15](https://github.com/khbminus/CppTickets/blob/master/tickets/ticket15.md#static-storage-duration)), например глобальные переменные. В таком случае порядок инициализации этих переменных зависит от порядка линковки этих единиц трансляции. Это может привести к проблемам.
<!-- TODO: make references to other tickets uniform --->
### Создание и уничтожение объектов со статическим временем жизни
В целом, объекты с static storage duration инициализируются при запуске программы (в каком-то порядке) и удаляются по завершению программы (в неочевидном порядке<sup>[1](https://www.youtube.com/watch?v=XdrSzs04HKU&list=PL8a-dtqmQc8obAqSKqGkau8qiafPRCxV7&t=4806s)</sup> <sup>[2](https://stackoverflow.com/questions/31443437/why-is-the-order-of-destruction-of-these-function-local-static-objects-not-the-i)</sup>, под разными компиляторами по-разному). Также стандарт C++ гарантирует, что все static storage duration объекты внутри одной единицы трансляции будут проинициализированы по порядку<sup>[3](https://en.cppreference.com/w/cpp/language/initialization#:~:text=initialization%20of%20these%20variables%20is%20always%20sequenced%20in%20exact%20order%20their%20definitions%20appear%20in%20the%20source%20code.)</sup>, но нет никаких гарантий про порядок между ними! 
#### У кого static storage duration
Есть деление на два типа<sup>[4](https://en.cppreference.com/w/cpp/language/storage_duration#:~:text=static%20or%20extern.-,See%20Non%2Dlocal%20variables%20and%20Static%20local%20variables%20for%20details%20on%20initialization%20of%20objects%20with%20this%20storage%20duration.,-thread%20storage%20duration)</sup>: *non-local* переменные (в сущности, глобальные или статические поля класса) и *static local* переменные (статические локальные).
##### Non-local
К примеру, обычные глобальные переменные.
```c++
int x = 1;

void foo() {
    x++;
}

int main() {
    std::cout << x << '\n';  // 1
    foo();
    std::cout << x << '\n';  // 2
    x += 2;
    std::cout << x << '\n';  // 4
}
```
Как правило, они инициализируются во время запуска программы. Однако в случае non-local переменных, если применимо *constant initialization*<sup>[5](https://en.cppreference.com/w/cpp/language/constant_initialization)</sup>, то компилятор может (но не обязан, хотя обычно так и есть) создать объект сразу на этапе компиляции! Таким образом, объект будет встроен в .exe файл, из-за чего он может раздуться.

Если же constant initialization не применимо, то сначала используется *Zero initialization*<sup>[6](https://en.cppreference.com/w/cpp/language/zero_initialization)</sup>:
```c++
struct A {
    int a,b,c;
};
 
double f[3]; // zero-initialized to three 0.0's
int* p; // zero-initialized to null pointer value (even if the value is not integral 0)
std::string s; // zero-initialized to indeterminate value
               // then default-initialized to "" by the std::string default constructor
int main(int argc, char*[])
{
    delete p; // safe to delete a null pointer
    static int n = argc; // zero-initialized to 0 then copy-initialized to argc
    std::cout << "n = " << n << '\n';
    A a = A(); // the effect is same as: A a{}; or A a = {};
    std::cout << "a = {" << a.a << ' ' << a.b << ' ' << a.c << "}\n";
}
```

После *Zero initialization* идёт *Dynamic initialization*<sup>[7](https://en.cppreference.com/w/cpp/language/initialization#Dynamic_initialization)</sup>, собственно присвоение значений.

Компилятор имеет право сделать *Early Dynamic initialization*<sup>[8](https://en.cppreference.com/w/cpp/language/initialization#Early_dynamic_initialization)</sup>, обычно на этапе компиляции, если он видит, что объект не меняет другие объекты и не зависит от других не *early dynamic initialized*.
```c++
inline double fd() { return 1.0; }
extern double d1;
double d2 = d1;   // unspecified:
                  // dynamically initialized to 0.0 if d1 is dynamically initialized, or
                  // dynamically initialized to 1.0 if d1 is statically initialized, or
                  // statically initialized to 0.0 (because that would be its value
                  // if both variables were dynamically initialized)
double d1 = fd(); // may be initialized statically or dynamically to 1.0
```
Тут вообще много всего интересного и запутанного. Если есть время, посмотрите [cppreference](https://en.cppreference.com/w/cpp/language/initialization).
##### Static local
Статические локальные переменные можно создавать внутри функций, тогда они будут доступны каждый раз, когда вызывается эта функция.
```c++
int foo(int addition) {
    static int x = 1;
    x += addition;
    return x;
}

int main() {
    std::cout << x << '\n';  // 1
    foo(1);
    std::cout << x << '\n';  // 2
    foo(2);
    std::cout << x << '\n';  // 4
}
```
Инициализируется такой объект единожды первый раз, когда он используется в функции.
### Пример static initialization order fiasco
Из-за того, что порядок инициализации зависит от порядка линковки, можно наткнуться на проблемы, если один объект при своей инициализации (обычно в конструкторе) использует другой объект, который сам ещё не создался.

Это и называется static initialization order fiasco (SIOF).
#### Пример с некорректным порядком
`a.h`
```c++
#ifndef HSE_CPP_EXAM_A_H
#define HSE_CPP_EXAM_A_H

#include <vector>

struct Counter {
    explicit Counter (int init_count) : count(init_count) {}

    int getID() {
        return count++;
    }
    int count;
};

extern Counter globalCounter;

#endif //HSE_CPP_EXAM_A_H 
```

`a.cpp`
```c++
#include <vector>
#include "a.h"

Counter globalCounter(100);
```
`main.cpp`
```c++
#include <iostream>
#include "a.h"

int someId = globalCounter.getID();

int main() {
    std::cout << someId << '\n';  // either 100 or uninitialized
}
```
Если скомпилировать файлы в порядке `g++ a.cpp main.cpp -o siof`, то всё будет хорошо. Если же `g++ main.cpp a.cpp -o siof`, то `someId` не сможет воспользоваться `globalCounter`.
#### Пример, где не существует корректного порядка
`a.h`
```c++
#ifndef HSE_CPP_EXAM_A_H
#define HSE_CPP_EXAM_A_H

#include <utility>
#include <vector>
#include <iostream>

struct Counter {
    explicit Counter (int init_count, std::string name) : count(init_count), name(std::move(name)) {}

    int getID() {
        return count++;
    }

    int count;
    std::string name;
};

extern Counter globalCounter;

#endif //HSE_CPP_EXAM_A_H
```
`a.cpp`
```c++
#include "a.h"
#include "b.h"

Counter globalCounter(100, globalNameGiver.getName());
```
`b.h`
```c++
#ifndef HSE_CPP_EXAM_B_H
#define HSE_CPP_EXAM_B_H

struct NameGiver {
    explicit NameGiver(int id) : id(id) {}

    std::string getName() {
        return "obj" + std::to_string(id);
    }

    int id;
};

extern NameGiver globalNameGiver;

#endif //HSE_CPP_EXAM_B_H
```
`b.cpp`
```c++
#include "a.h"
#include "b.h"

NameGiver globalNameGiver(globalCounter.getID());
```
`main.cpp`
```c++
#include <iostream>
#include "a.h"
#include "b.h"

static int someId = globalNameGiver.id;
static std::string someName = globalCounter.name;

int main() {
    std::cout << someId << '\n';  // ???
    std::cout << someName << '\n';  // ???
}
```
`globalCounter` нужен для создания `globalNameGiver`, а `globalNameGiver` нужен для создания `globalCounter`... Вопрос о курице и яйце без решения.
#### Пример, где возникает UB только через std::vector
Давайте в модуль положим вектор, значение которого инициализируем только в `a.cpp`.

`a.h`
```c++
#ifndef HSE_CPP_EXAM_A_H
#define HSE_CPP_EXAM_A_H

#include <vector>

struct Foo {
    static std::vector<int> a;
};
// or use extern instead of Foo

#endif //HSE_CPP_EXAM_A_H
```
`a.cpp`
```c++
#include <vector>
#include "a.h"

std::vector<int> Foo::a{1, 2, 3};
```
`main.cpp`
```c++
#include <iostream>
#include "a.h"

int first_of_a = Foo::a[0];

int main() {
    std::cout << first_of_a << '\n';  // either 1, or UB, as it's out-of-bounds
}
```
Если сначала инициализируются объекты из `main.cpp`, то `first_of_a` должно взять значение неинициализированного вектора, получая UB.
### Решение проблемы
Чтобы избежать этой проблемы, можно воспользоваться идиомой 'construct on first use': вместо `non-local` переменных, будем использовать `static local`, чтобы они гарантированно создались, когда мы ими воспользовались.

Например, для прошлого примера:

`a.h`
```c++
#ifndef HSE_CPP_EXAM_A_H
#define HSE_CPP_EXAM_A_H

#include <vector>

struct Foo {
    static std::vector<int>& getVector();
};

#endif //HSE_CPP_EXAM_A_H
```
`a.cpp`
```c++
#include <vector>
#include "a.h"

std::vector<int>& Foo::getVector() {
    static std::vector<int> a{1, 2, 3};
    return a;
}
```
`main.cpp`
```c++
#include <iostream>
#include "a.h"

int first_of_a = Foo::getVector()[0];

int main() {
    std::cout << first_of_a << '\n';  // now OK!
}
```
#### Сравнение с автоматическим временем жизни и динамическим
* В отличие от автоматического времени жизни, один и тот же объект может использоваться в разных единицах трансляции.
* В отличие от динамического времени жизни, такой способ безопаснее, потому что гарантируется, что объект живой.

### Замечания
* Циклическое SIOF починить не получится никак, так как оно циклическое...
* Такие же приколы могут быть с уничтожением объектов: может удалится объект, нужный другому в деструкторе. Такое можно решать, например, вообще никогда не удаляя объект:
```c++
Foo& getFoo() {
    static auto* ptr = new Foo();  // never destructs!
    return *ptr;
}
```
* `cin`, `cout` тоже глобальные переменные, поэтому если вы используете их в конструкторе, то теоретически могут быть такие же проблемы. Однако, начиная с C++11, гарантируется, что `cout`, `cin` и прочие создадутся раньше остальных объектов с статическим временем жизни. **Только в случае если `#include <iostream>` идёт до `#include` файла с объявлением**. Об этом можно поподробнее прочитать в [ubbook](https://github.com/Nekrolm/ubbook/blob/master/runtime/static_initialization_order_fiasco.md#initialization-order-fiasco-%D0%B8-%D0%BD%D0%B5%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D1%83%D0%B5%D0%BC%D1%8B%D0%B5-%D0%B7%D0%B0%D0%B3%D0%BE%D0%BB%D0%BE%D0%B2%D0%BA%D0%B8).

### Полезные ссылки
* https://isocpp.org/wiki/faq/ctors#static-init-order
* https://github.com/Nekrolm/ubbook/blob/master/runtime/static_initialization_order_fiasco.md
* https://en.cppreference.com/w/cpp/language/initialization
</details>

