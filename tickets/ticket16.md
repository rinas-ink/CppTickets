## Билет 16. Стандартная библиотека

<!-- 1 -->
### Что такое `namespace std`
`namespace std` - это пространство имен стандартной библиотеки. Когды мы пишем `std::something`, это означает "взять что-то из стандартной библиотеки". Namespaces используются во избежания конфликтов имен, когда в больших проектах может использоваться много разных библиотек (более подробно - в билете про `namespaces`, уверен, что такой есть. Где-то....).  


<!-- 2 -->
### Контейнеры

#### `std::vector`, `std::string`, `std::list`, `std::map`: когда что использовать 

- `std::vector` - динамически расширяемый массив. Хранение вектора происходит автоматически: дополнительная память под элементы выделяется/освобождается, когда нужно. Память выделяется с запасом на будущие элементы, таким образом вектору не нужно перевыделять память каждый раз при добавлении нового элемента.

- `std::string` - контейнер для работы со строками. В `std::string` можно присвоить сишную строчку, для нее определены многие методы, например, `size()`, также можно обратиться к конкретному символу в строке с помощью оператора `operator[]`.

- `std::list` - обычно реализован как двусвязный список, поддерживающий удаление и встаку элементов за O(1). При этом не поддерживает быстрый доступ к произвольному элементу.

- `std::map` - контейнер, хранящий пары (уникальный ключ, значение) в отсортированном порядке. Наиболее похож на `set<pair<const T1, T2>>`. При этом ключ константный (это важно помнить)!



#### Основные операции и время работы: `push_back`/`emplace_back`, `front()`/`back()`, `operator[]`, `size()`, `capacity()`, `resize()`, `reserve()`

| `vector`, `string`, `list` | push_back | emplace_back | front | back | operator[] | size | capacity | resize | reserve |
|---|---|---|---|---|---|---|---|---|---|
| Время работы | O*(1) | O*(1) | O(1) | O(1) | O(1) | O(1) | O(1) | O(n) | O(n) |
| Возвращаемое значение | - | Начиная с C++17 - ссылка на добавленный элемент | Ссылка на первый элемент | Ссылка на последний элемент | Ссылка на i-ый элемент  | Кол-во элементов в контейнере   | Кол-во элементов, под которое выделена память | - | - |
| Описание | Вставляет элемент в конец копированием или перемещением | Конструирует элемент на месте (в конце контейнера). Не определен для `string` |  |  | Не определен для `list` |  | Не определен для `list` (есть аналог `max_size`) | Изменяет размер контейнера (обрезает с конца или увеличивает, заполняя дефолтными значениями) | Выделяет доп. память (влияет на capacity). Не определен для `list` |


| `map` | insert  | emplace | operator[] | size | max_size |
|---|---|---|---|---|---|
| Время работы | O(logn) | O(logn) | O(logn) | O(1) | O(1) |
| Возвращаемое значение | Итератор на вставленный элемент (или на то, что уже был в контейнере), либо пару (итератор, `bool`), второй параметр показывает произошла ли настоящая вставка элемента   | Пару (итератор, `bool`) | Ссылка на элемент по ключу  | Кол-во элементов в контейнере   | Кол-во элементов, под которое выделена память |
| Описание | Вставляет элемент копированием или перемещением | Конструирует элемент на месте |  |  |  |



#### Особенность `operator[]` у `std::map`: элемент всегда создаётся, даже если его не было, почему
Несмотря на то, что `std::map` похож на сет пар, у него есть свои отличия. Оператор `operator[]` у `std::map` принимает значение ключа, создают элемент с таким ключом (инициализирует его дефолтным значением), если такого ключа раньше не было, и возвращает ссылку на значение.

Этот оператор работает именно таким образом, поскольку возвращает **ссылку** на значение (значение должно быть проинициалиированно, чтобы вернуть его по ссылке).


#### Инвалидация итераторов и ссылок на элементы: когда, какие последствия
Для стандарта `C++17` (для других стандартов правила могут отличаться! Подробнее [тут](https://stackoverflow.com/questions/6438086/iterator-invalidation-rules-for-c-containers)):
- `std::vector`: итераторы (ссылки на элементы тоже!) инвалидируются при удалении и при добавлении в любое место, если произошла реаллокация памяти (вектор расширился). Также инвалидируются указатели (и ссылки) на удаленные элементы (в случае `push_back`).
- `std::string`: также как у `std::vector`.
- `std::list`: при добавлении итераторы (и ссылки) не инвалидируются, при удалении инвалидируются только итератор (и ссылка) на удаленный элемент.
- `std::map`: при добавлении итераторы (и ссылки) не инвалидируются, при удалении (это про `std::map::erase()`, у `std::map::extract()` поведение схоже, но ссылки остаются валидными) инвалидируются итераторы (и ссылки) только на удаленный элемент.

Обращение к невалидному итератору - UB!

<!-- 3 -->
### Итераторы
#### Конвенции с `begin()`/`end()`
Эти два итератора представляют собой полуинтервал, включающий левую, но не правую границу. Иными словами: `[begin; end)`

<!-- 4 -->
### Алгоритмы
#### `sort`, передача своего компаратора
`std::sort` - сортирует элементы контейнера на заданом полуинтервале в соответсвии в предоставленным компаратором (или компаратором по умолчанию).

```cpp
std::vector <int> arr = {2, 4, 3, 1, 6, 5};
std::sort(arr.begin() + 2, arr.begin() + 4); // 2 4 1 3 6 5
std::sort(arr.begin(), arr.end()); // 1 2 3 4 5 6 
```

Способы передать компаратор (TODO: ссфлка на билет про **функторы**):
- Классом компаратором с определенным оператором `operator()`:
```cpp
struct comp {
	bool operator() (const T& a, const T& b) {
		return (a > b);
	}
};
...
std::sort(arr.begin(), arr.end(), comp());
```
- Функцией, возвращающей `bool`:
```cpp
bool comp(const int& a, const int& b) {
	return (a > b);
}
...
std::sort(arr.begin(), arr.end(), comp);
```
- Лямбда функцию:
```cpp
std::sort(arr.begin(), arr.end(), [](const int& a, const int& b) {
	return a > b;
});
``` 

#### `lower_bound`, `upper_bound`, точные инварианты
`lower_bound`, `upper_bound` - принимают полуинтервал (границы поиска) отсортированного контейнера, значение для сравнения, опциональный компаратор.

`lower_bound` - вернет итератор на первый элемент **не меньший**, чем переданный, если такого нет, то на end.

`upper_bound` - вернет итератор на первый элемент **больший**, чем переданный, если такого нет, то на end.

<!-- 5 -->
### Ввод-вывод
#### `cin`/`cout`/`ifstream`/`ofstream`/`istream`/`ostream`/`sstream`
- `cin`/`cout` - глобальные объекты ввода/вывода в стандартные Сишные потоки ввода/вывода. 
```cpp
#include <iostream>
...
int a;
std::cin >> a;
std::cout << a; 
```

- `ifstream`/`ofstream` - типы для файлового ввода/вывода.
```cpp
#include <fstream>
...
std::ifstream input("input.txt");
std::ofstream output("output.txt");
int num; std::string str;

input >> num >> str; // 123 Anime
output << str << ' ' << num; // Anime 123
```

- `istream`/`ostream` - типы для стандартного ввода/вывода (объекты `cin`/`cout` - преставители этих типов). 

- `sstream` - поток для чтения/записи строчек.
```cpp
#include <sstream>
...
std::stringstream ss;
ss << "Hello" << ", World!"; // Hello, World!
std::string s1, s2;
ss >> s1 >> s2;
std::cout << s1 << '\n' << s2 << std::endl;
// Hello,
// World!
```

#### Какие `#include` бывают (2 шт)
`#include` - указывает препроцессору включить содержимое указанного файла в точку, где отображается директива. Типы скобок принципиально отличаются тем, что указывают порядок поиска файлов при указании не полного пути. 

- `#include "..."`: сперва искать этот заголовочный файл следует в текущей директории нашего проекта, затем в системный директориях. 
- `#include <...>`: сперва искать этот заголовочный файл следует в системных директориях.
#### Синтаксис ввода и вывода
Примеры синтаксиса два пункта выше.

#### Перегрузка операторов ввода-вывода для своих классов: конвенции, почему так работает, когда нужны `friend`-операторы и зачем
Когда мы перегружаем операторы ввода/вывода, мы обязаны возвращать ссылки на объекты ввода/вывода, которыми пользуемся. Это позволит нам применять много операторов последовательно в одной строчке. Примеры перегрузок операторов ввода/вывода:
```cpp
std::istream& operator>>(std::istream &is, Type &obj) {
	...
	return is;
}
...
in >> obj1 >> obj2 >> obj3; // равносильно тому, что ниже
// ((in >> obj1) >> obj2) >> obj3; - так как в перегрузке возвращается ссылка на объект типа std::istream
...
std::ostream& operator<<(std::ostream &os, const Type &obj) {
	...
	return os;
}
...
out << obj1 << obj2 << obj3; // по аналогии с вводом
```
- Ввод: Принимаем вторым параметром ссылку на объект, который хотим ввести, так как мы собираемся положить введенное значение по этому адресу. Первым параметром принимаем `std::istream&` (почему именно ссылку - в комментариях в коде расписано почему), почему именно ссылку на этот тип - чтобы, мы могли перегрузить оператор ввода единожды, и он работал для всех типов потоков ввода (так как `std::istream` - базовый класс для всех остальных типов ввода). 
- Вывод: Принимаем вторым параметром константную ссылку на объект, который хотим вывети, либо же копируем по значению, но так скорее делать не стоит (особого смысла нет). Остальное по аналогии с вводом.

Если у нас есть класс, у которого имеется приватное поле, которое нам уметь выводить, можно воспользоваться `friend`:
```cpp
class T {
  public:
    friend std::ostream& operator<<(std::ostream&, const T&);
  private:
    int data;
};
...
std::ostream& operator<<(std::ostream& os, const T& obj) {
	os << obj.data;
	return os;
}
``` 

<!-- remark -->
**Замечание**: тесно связано с: функторы, лямбда-функции, базовый синтаксис (порядок вычислений).



