## Билет 31. Программы из нескольких файлов

**Важно знать**: порядок инициализации переменных между единицами трансляции неопределен!

### Что делает #include, в том числе #include <iostream> и `#include <iosfwd>`:

1) `#include "header.h"/<lib>` - просто вставляет код из `header.h/lib` в текущую единицу трансляции
2) `#include <iostream>` - включает стандартную библиотеку ввода/вывода в текущую единицу трансляции (`<>` - используются для встроенных библиотек, `""` - для собственных header-файлов)
3) `#include <iosfwd>` - этот заголовок содержит forward declaration для стандартной библиотеки ввода/вывода.



### Мотивация:
1. Зачем линковка, когда есть `#include`, отличия:

	**При линковке** мы можем сначала скомпилировать все файлы отдельно друг от друга, получив объектные файлы, а затем слинковать их как захотим. Например, есть файл `main.cpp`, он вызывает `print()` функцию. Мы можем создать 2 файла `print1.cpp` и `print2.cpp`, сделать независимо компиляцию каждого (`g++ -c main.cpp print1.cpp print2.cpp`), а далее слинковать полученные `main.o` и `print1/2.o` попарно (`g++ main.o print1.o -o a.exe`, `g++ main.o print2.o -o b.exe`), так получаем 2 `exe`-файлика, которые используют разные функции.

	Также важно помнить, что функция может иметь ровно определение (по правилу `ODR - One Definition Rule`) в какой-либо единице трансляции (definition: тело функции `void foo() {...}`), но сколько угодно много объявлений (declaration: `void foo();`). Структуры могут иметь определения для своих методов в разных единицах трансляций, но эти определения должны полностью совпадать (в таких случаях делают header-файл c объявлением структуры и ее полей/методов, а в отдельной одной единице трансляции пишут определения для методов).

	`#include<something>` - просто скопирует содержимое файла `something` и вставит в файл с include'ом, при этом размер текущего файла увеличится.


### Единицы трансляции и файлы:
`.cpp`-файл - это `translation unit` (единица трансляции), код разбивается на несколько файлов, чтобы было удобнее его читать + компилировать каждый файл отдельно (`g++ -c main.cpp` - создаст объектный (бинарный) файл `main.o`).


**UB:** 
	
1. Разные параметры по умолчанию в объявлении и определении функций
	
2. Разные типы данных в объявлении и определении, возвращаемые функцией


### Как из одного файла заиспользовать глобальный класс/функцию из другого:

1. **Функции**: в 1 единице трансляции мы определяем функцию (function definition: `void foo(int x) {[body of the function foo]}`), во всех других только пишем объявление этой функции (function declaration: `void foo(int x);`)

2.1. **Классы/структуры**: если не использовать `header`-файлы, то это боль, нужно в каждой единице трансляции *заново прописывать **определения членов** структуры* и **объявления ИЛИ определения методов (при этом определения в разных единицах трансляции должны совпадать - copy-paste)**; тут легко напороться на `UB`, поменяв местами определения членов структуры (UB так как удаляет объект текущая единица трансляции, поэтому если поля имеют другое расположение, то порядок удаления полей не соответствует их расположению в памяти). Вот [пример кода с лекции](https://github.com/hse-spb-2021-cpp/lectures/tree/master/06-211006/08-struct-ub).

2.2. **Классы/структуры**: с использованием header-файлов все просто: мы 1 раз *объявляем* все поля/методы структуры в каком-нибудь `my_struct.h` файле, далее в 1 единице трансляции (`my_struct.cpp`) пишем определения для методов. Если в каком-либо файле нам понадобиться эта структура, то мы просто включаем ее в нужный файл `#include "my_struct.h"` (при этом не забываем про `guards` в header-файлах).
	


### External linkage/internal linkage:

`Internal linkage` - данный тип линковки обозначает, что сущность (переменная, функция, структура) будет видна только в данной единице трансляции (в текущем `.cpp`-файле).

`External linkage` - данный тип линковки обозначает, что сущность будет видна всем единицам трансляции, которые мы решили скомпилировать вместе. Другими словами, доступна через всю программу, которая представляет собой комбинацию всех единиц трансляции.


1. **Слово `static` и `unnamed namespace`, где применять:**

1) `static`: если мы хотим, чтобы *глобальная функция* была видна только в текущей единице трансляции, то мы может перед ее типом написать слово `static`, и данная функция не будет видна другим единицам трансляции (также `static` делаем сущность *статической*, то есть она инициализируется в программе 1 раз и не умирает до завершения самой программы). Примеры:

```cpp
// foo.cpp

static int foo() {
	return 100;
}

int bar() {
	return 100;
}
```

```cpp
// main.cpp

foo();
bar();

int main() {
	foo(); // ERROR: undefined reference
	bar(); // works fine
}
```

2) `unnamed namespace`: нужен, чтобы переменная/функция/сущность была долступна только текущей единице трансляции. Пример:

```cpp
// foo.cpp
namespace {
	int foo() {
		return 10;
	}
}

int calc() {
	int x = foo();
	return x * x;
}
```

```cpp
// main.cpp

int foo();
int calc();

int main() {
	foo(); // ERROR
	calc(); // works fine
}
```





### Формулировка `One Definition Rule`, формулировка `IFNDR` (**Ill-Formed, No Diagnostic Required**):
	
1. **Формулировка `One Definition Rule`:** у любой сущности (функции/глобальной переменной) должно быть ровно 1 определение на всю программу (программа - все translation units, что есть в проекте)

2. **Формулировка `IFNDR`:** есть сущность имеет не 1 определение, то возникнет UB сразу после запуска программы (даже до выполнения main()), компилятор не обязан сообщать о некорректности программы

	
1) Пример ошибок линковщика: `multiple definition`, `undefined reference`:
```cpp
// multiple definition example: - имеем несколько определений для сущности

// foo.cpp
void foo() {...}
```

```cpp

// main.cpp
void foo() {...}

int main() {
}

// compile both and you will get an error: 

// g++ main.cpp foo.cpp;
// ./a.exe -> ERROR: multiple definition of 'foo()'
```

```cpp
// undefined reference example: - не имеем ни одно определения для сущности, однако пользуемся ею

// foo.cpp - leave empty
```

```cpp
// main.cpp

void foo();

int main() {
	foo();
}
// complie both and error will occur: 

// g++ main.cpp foo.cpp;
// ./a.exe -> ERROR: undefined reference to 'foo()'
```

2) Что происходит с перегрузками функций: перегрузки разрешаются на уровне компилятора, а не линковщика, поэтому **иметь одну функцию с разными перегрузками нормально**:

```cpp

// foo.cpp
void foo(int x) {...}
```

```cpp
// main.cpp
void foo(int x);
void foo() {...}

int main() {
	foo(10);
	foo();
}
// works fine, no ODR violation
``` 



### Типичный заголовочный файл:

1. Конвенция именования заголовочных файлов: 

	Правильное название для `guard'a` в `header`-файле будет `[filename uppercased]_H_` (здесь `[filename uppercased]` - название текущего файла, в котором пишется `guard`, заглавными буквами).

2. `Include guards`: зачем, как правильно, осторожно с `_`:
		
	Если начать название `guard'а` с `_A`, `__A` (`A` - любая заглавная буква), то это `UB` (такие названия запрещены к использованию).


**`Note:`** 

Если не делать `include-guards`, то возможна ситуация: мы имеем структуру `Foo` в `"header1.h"` файле, далее мы написали `#include "header1.h"` в каком-нибудь `"header2.h"` файле, а затем в `main.cpp` сделали `#include "header1.h"` и `#include "header2.h"`, так мы получили ошибку `"multiple definition of struct Foo"`, чтобы такого не произошло делают следующее:

```cpp
#ifndef HEADER1_H_
#define HEADER1_H_

struct Foo {...};

#endif // HEADER1_H_

// Так при первом включении header1.h в main.cpp мы объявим HEADER1_H_ и при втором include в header2.h второго подключения не случится

```


3. Опасность неявного включения, концепция include what you use, примеры из стандартной библиотеки вашего компилятора (`exercises/01-210906/07-missing-include`):

	Опасность неявного включения: на различных компиляторах код может либо компилироваться, либо нет. (смотри [exercises/01-210906/07-missing-include](https://github.com/hse-spb-2021-cpp/exercises/blob/master/01-210906/07-missing-include.cpp)).

	Важно сделать так, чтобы порядок `#include`-ов в единице трансляции не имел значения и все .h-файлы были независмые, поэтому если в каком-то .h-файлы мы используем что-то из другого .h-файла, то мы обязаны в текущий заголовочный файл включить все header-файлы, что необходимы (принцип `include what you see`); [пример с лекции](https://github.com/hse-spb-2021-cpp/lectures/tree/master/06-211006/10-include).


4. Запрет на реализацию функций:

	Мы пишем только объявления функций в `header`-файлах (так принято делать, чтобы избежать `ODR`). Также можно использовать `inline`, но **не нужно**, так как считается **плохой практикой** 
		
	Смысл `inline`: функция может иметь несколько определений, но я, как программист, обещаю, что все эти определения равны, поэтому выбери любое.


5. Необходимость подключать заголовочный файл в файл с реализацией:

	В файл реализации мы должны подключить наш `.h`-файл, чтобы обезопасить себя от возможных `UB`, пример:

```cpp
// get.h

#ifndef GET_H_
#define GET_H_

float get(int x);

#endif
```

```cpp
// get.cpp

double get(int x) {
	...
}
```

```cpp
// main.cpp

#include "get.h"

int main() {
	get(10.0);
}

// g++ main.cpp get.cpp -o a.exe
// ./a.exe - UB!
```

Если в пример выше включить `get.h` файл в `get.cpp`, то компилятор выдаст ошибку компиляции, т.е. убережет от трудного `debugging'а`.





### Взаимная рекурсия между заголовками и `forward header`:
	
**Взаимная рекурсия:**

Проблема:

```cpp
// bar.h 

#ifndef BAR_H_
#define BAR_H_

#include "foo.h"

struct Bar {
    Foo *f;
};

void bar_do_something(Foo, Bar);

#endif  // BAR_H_

```

```cpp
// foo.h

#ifndef FOO_H_
#define FOO_H_

#include "bar.h"

struct Foo {
    Bar b{this};
};

#endif  // FOO_H_

// Здесь Bar не видит Foo, так как стоят guards, если убрать guards, то мы зациклим подключения
```

Решение:

```cpp
// Чтобы решить проблему, мы создаем foo_fwd.h файл, в котором не будет ничего кроме объявления структуры Foo: struct Foo;

// foo_fwd.h

#ifndef FOO_FWD_H_
#define FOO_FWD_H_

struct Foo;

#endif  // FOO_FWD_H_
```

#### Идея `forward header`:
Данные заголовочные файлы включают в себя только forward-declaration (то есть объявления) структур.

Если есть `foo_fwd.h` и `foo.h`, то в `foo.h` также нужно подключить `foo_fwd.h`, чтобы проверить, что у нас объявление и определения не отличаются типом данных, параметрами и тд.



1. Incomplete type: как объявить, что можно сделать с неполным типом: 

	1) Синтаксис: `struct Foo;`

	2) Неполного типа достаточно, что передавать указатели и ссылки на структуру, т.е. мы не выделяем память для новой структуры данного типа. Но ничего кроме как передать по ссылке/значению мы не умеем: не можем вызывать методы, обжащаться к полям, создавать instance данной структуры, так как мы не знаем сколько структура должна занимать памяти, а также не знаем какие поля и методы у нее определены, [код с лекции](https://github.com/hse-spb-2021-cpp/lectures/tree/master/06-211006/09-incomplete).

	3) Зачем надо: это укоряет компиляцию, так как нам не нужно парсить определение структуры.

	
2. Пример forward hearder из стандартной библиотеки (`<iosfwd>`):

	1. Если мы хотим для свой структуры реализовать оператор вывода, то нам необязательно в .h-файл подключать большую <iostream> библиотеку, мы можем просто объявить, что объект ios существует и все:

```cpp
// foo.h

#ifndef FOO_H_
#define FOO_H_

#include <iosfwd>

struct Foo {};

std::ostream& operator<<(std::ostream&, const Foo&);

#endif  // FOO_H_
```

```cpp
// foo.cpp
#include "foo.h"
#include <iostream>

std::ostream& operator<<(std::ostream& os, const Foo&) {
	return os << "hello world";
}
```




### Что обычно (не) пишут в своих заголовочных файлах (в том числе forward), `using namespace std`:

1. В заголовках **не пишут** определения функций, их выносят в соответствующие .cpp-файлы.

2. В заголовках **пишут** объявления сущностей, guards

3. В forward-заголовках пишут forward-declaration для структур (`struct Foo;`)

4. `using namespace std` - так не пишем, так как в случае, если есть какая-либо функция c совпадающим названием как в `std` в другой библиотеке, мы не сможем ее вызвать. 







## Other notes from `06-211006(I) — программы из нескольких файлов, СПб ВШЭ ПМИ, C++`:

### `namespaces`: 

1. `::` - global namespace.

2. `ns1::ns2` - nested namespace.

3. Поиск среди namespace'ов вверх по вложенности.

4. `(Un)qualified name lookup`:

```cpp
namespace ns1 {
	void foo() {...}
}

namespace ns1::ns2 {
	void bar() {
		foo(); // Unqualified name lookup for 'foo' - пытаемся найти foo() в текущем namespace'e потом на 1 уровень выше, потом на 2 выше и тд
		
		ns1::foo(); // Qualified name lookup for 'foo', Unqualified name lookup for 'ns1'
	}
}
```

5. `Argument dependent lookup`:

```cpp
namespace ns {
	struct Foo;

	void foo(Foo) {...}

	void foo() {...}
}

// compiles fine
int main() {
	ns::Foo f;
	foo(f); // найдет нужный 'foo' в 'ns', так как компилятор пытается посмотреть во все namespace'ы и найти там функцию foo с такими аргументами
	
	// это нужно, чтобы уметь писать операторы: f == f, ns::operator==(f, f) 
}

// does not compile
int main() {
	foo();
}

```
