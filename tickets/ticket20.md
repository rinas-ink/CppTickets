## Билет 20. Классы
* **Cинтаксис**

```c++
struct Example{
    int x;
    
    Example(){}; // конструктор
    ~Example(){}; // деструктор
    void do_something(){
        std::cout << "hello";
    }
}; // не забываем ставить всегда точку с запятой в конце
```

* **Поля: обычные, константные, ссылки, порядок создание и уничтожения и когда он важен.**
    * **Поле класса/атрибут** - переменная, описание которой создает программист
при создании класса. Все данные объекта хранятся в его полях. Доступ к полям
осуществляется по их имени.
    * **Константные поля** 
Поля, инициализируемые при помощи синтаксиса списка инициализации получают свое значение еще до входа в тело конструктора. Присваивание константе значения в теле конструктора уже является именно присваиванием, что по определению невозможно для константы.

    ```c++
        struct Foo {
            const int x = 10;
            Foo(int x_) : x(x_) { }
        };
    ```
    * **Ссылки** обязательно надо проинициализировать, чтобы они к чему-то были при-
        вязаны. Если же объект, чья ссылка была передана для инициализации переменной-ссылки внутри структуры, умер, то ссылка невалидна и обращение по ней будет вызывать UB.
    ```c++
        class DateClass{
            int a = 1;
            int &c = a;
        };
    ```
    * Разработчики классов могут гарантировать инициализацию каждого объекта пу-
тем определения особой функции, которая называется конструктор. Если в классе определен конструктор, компилятор автоматически вызывает его в момент создания объекта, до того как отдать его в руки программисту. Программисты не праве даже решать, вызывать конструктор или нет, конструктор вызывается всегда компилятором в момент создания объекта.
    ```c++
        class Example {
            int i;
        public:
            Example(){} // конструктор дефолтный
            Example(int a){} // тоже конструктор, но от int
        };
        
        int main(){
            Example cur;  // создание объекта
        }
    ```
    Как и у любого метода, у конструктора могут быть аргументы, чтобы можно было иметь возможность указать как создавать объект, передать какие-то значения и т.д. В C++, очистка поставлена на одну планку по важности с инициализацией и гарантируется, что она будет осуществлена путем вызова деструктора. Синтаксис деструктора и конструктора схожи. И там, и там, в качестве имени метода используется имя класса. Однако, чтобы отличить деструктор от конструктора, перед именем деструктора добавляется символ тильда ( ). Кроме того, деструктор не может иметь какие-либо аргументы, так как для процесса уничтожения не требуется дополнительных параметров. Вот пример объявления деструктора:
    ```c++
    struct Example{
      ~Example(){
        std::cout << "DELETE object\n";
     }
    };
    ```
    Деструктор вызывается автоматически компилятором, когда объект выходит из своей области существования.
* **Семантика копирования, особенности полей-констант/ссылок при копировании и инициализации.**
Если у нас есть объект и мы его передаем по значению (в функции например) или делаем **=**, то копируются все поля. Существует еще copy-constructor и copy assignment operator, которые и управляют копированием. Про них и их реализацию подробнее и красочнее в [примере с лекции](https://github.com/hse-spb-2021-cpp/lectures/blob/master/09-211110/00b-special-operators.cpp). Но стоит сказать, что в примере ниже copy-constructor и copy assignment operator по умолчанию дефолтные.
    ```c++
    struct Foo{
        int x;
        int y;
    };
    void do_smth(Foo temp){} // копирование 

    int main(){
        Foo a{1,2};
        Foo b = a; // Копирование
    

    ```

* **Конструктор: синтаксис, параметры, когда вызывается, делегирующие конструкторы.** 
Конструкторы - специальные методы, которые вызываются при создании объекта. Всегда вызываются и нет способа их пропустить. Время жизни объекта начинается с того, как закончился конструктор. Конструктор по умолчанию - конструктор без аргументов. Может быть сгенерирован компилятором неявно (например, когда вообще нет конструкторов). Когда присутствует какой либо конструктор (не дефолтный), то не генерируется. [Пример с лекции](https://github.com/hse-spb-2021-cpp/lectures/blob/master/04-210923/02-ctors/04-no-default.cpp), где видно, что дефолтный конструктор не создается при наличии другого конструктора. [Примеры вызова конструктора](https://github.com/hse-spb-2021-cpp/lectures/blob/master/04-210923/02-ctors/02-args.cpp).
    ```c++
    #include <iostream>
    
    struct ratio {
        int num;
        int denom;
        ratio() {
            num = 0;
            denom = 1;
            std::cout << "Constructing!\n";
        }
    };
    
    int main() {
        ratio r;
        std::cout << r.num << "\n";
        std::cout << r.denom << "\n";
        std::cout << ratio{}.num << "\n";  // Not UB, ok even in C++03.
    }
    ```
    **Делегирующий конструктор** - конструктор, который вызывается в данном конструкторе для инициализации полей. Тонкость: после вызова делегирующего конструктора не можем изменять поля в member initialization list. Вторая тонкость: внутри конструктора нельзя вызвать делегирующий конструктор, так как это не является вызовом конструктора, это является созданием временного объекта, который быстро умирает. 
    
```c++
    #include <vector>
    #include <iostream>
    
    struct bigint {
        std::vector<int> digits;
        int var;
    
        bigint(int x) : digits{x % 10, x / 10} {
        }
    
        bigint() : bigint(0)/*, var(10)*/ {  // since C++11
            var = 10;                       // тут bigint(0) - делегирующий конструктор
            // если хотим поменять переменную, то лучше сделать переприсвоение, так как в initilization list изменять не имеем права.
        }
    };
    
    int main() {
        [[maybe_unused]] bigint b1; 
    }
```

* **Инициализация полей: когда что можно и нужно использовать, как они взаимодействуют между собой и с делегирующим конструктором:**
    * **По умолчанию (тривиальных и с конструктором по умолчанию). В конструкторе по умолчанию**
    * **Default member initializer (C++11).** Простыми словами мы можем задавать начальные значения в структуре и если мы хотим посмотреть от них значение, то не получим UB, как в случае, если они непроинициализированы (int num; int denom;)
    ```c++
    #include <iostream>
    
    struct ratio {
        int num = 0;  // C++11: member default initialization
        int denom = 1;
    };
    
    int main() {
        ratio r;
        std::cout << r.num << "\n";
        std::cout << r.denom << "\n";
        std::cout << ratio{}.num << "\n";
    }
    ```
    * Member Initilization list. У каждого поля в  {} мы говорим какой конструктор вызвать с круглыми или фигурными скобочками. Тогда у нас поле сразу инициализируется правильно и мы его не инициализируем, а потом перезаписываем, а мы сразу делаем правильно. Это точнее выражает намерения программиста.
    ```c++
    #include <cassert>
    #include <iostream>
    #include <vector>

    struct bigint {
        std::vector<int> digits;
        int sign = 1;
    
        bigint() /*: digits{}*/ {
        }
        bigint(int value) : digits{value % 10, value / 10} {
            assert(value >= 0);
            assert(value < 100);
        }
    };
    
    int main() {
        bigint value(23);
        std::cout << value.digits[0] << "\n";
        std::cout << value.digits[1] << "\n";
    }
    ```
* **Приватные/публичные поля и методы**
[Плохой пример](https://github.com/hse-spb-2021-cpp/lectures/blob/master/04-210923/04-api/01a-public.cpp), когда все в public не бывает полезно. Например пользователь может что-то случайно изменить или сломать инвариант. Для этого существует private секция. К полям и методам из private секции имеют доступ только методы структуры, через них мы можем даже изменять приватные поля. 
Вредные советы: всегда создавать getters и setters. Пример: setters в случае дроби не нужны, и getters тоже сомнительно (?), но их можно оставить. Например надо ставить assert(x != 0), когда меняется знаменатель через  setter. Да и вообще неразумно менять дробь. 
    **геттеры** — это функции, которые возвращают значения закрытых переменных-членов класса;
    **сеттеры** — это функции, которые позволяют присваивать значения закрытым переменным-членам класса.
Запомним: 
Класс должно быть нельзя использовать некорректно! Даже если очень захотеть.
Пример: нельзя просто так взять и поменять числитель/знаменатель у дроби.
    [Оригинальный пример с лекции](https://github.com/hse-spb-2021-cpp/lectures/blob/master/04-210923/04-api/01b-private.cpp)

```c++
    struct ratio {
    private:
        // denom != 0
        int num;
        int denom;
    
    public:
        
        //  куча конструкторов
    
        // getter
        int numerator() const {
            return num;
        }
        int denominator() const {
            return denom;
        }
    /*    // setter
        void numerator(int new_value) {
            num = new_value;
        }
        void denominator(int new_value) {
            assert(new_value != 0);
            denom = new_value;
        }*/
    };
    
    int main() {
        ratio r;
        // r.denominator(0); 
        r = {r.numerator(), 5}; // безумная операция, которая отрывает числитель у дроби и меняет знаменатель.
        // пример плохого применения setter
        std::cout << r.numerator() << "\n";
    }
```

Чтобы иметь доступ к приватным полям структуры вне структуры свободная функция должна быть либо friend-функцией структуры (синтаксис в примере), либо static функция - все так же является другом, все так же НЕ является методом, но она лежит внутри класса с точки зрения ее имени и имеет доступ к private полям. Friend-функция должна быть обязательно объявлена в структуре, а определена либо в структуре, либо вне ее.

```c++
    // friend: defined inside or outside; hidden friends
    // static: defined inside or outside
    struct Foo {
    private:
        int x;
    
    public:
        friend void foo(Foo &f) {
            f.x = 10;
        }
    
        static void bar(Foo &f) {  // Also a friend.
            f.x = 10;
        }
    };
    
    // Can also define outside:
    // void foo(Foo &)
    // void Foo::bar(Foo &)
    
    int main() {
        Foo f;
        foo(f);
    
        Foo::bar(f); // вызов статической функции
    }
```
* **Отличия struct/class.**

    В struct по дефолту все методы публичны, если явно не указана private секция. Наследование тоже публично, если явно не указано private. У class все ровно наоборот: наследование приватное, методы и поля приватны, если явно не указана публичная секция.

* **Вложенные классы**
```c++
    #include <iostream>
    
    struct Foo {
        void foo() {
            bar();
        }
        void bar() { // заметим, что внутри класса можно вызывать методы без 
            foo();   // предварительного declaration, чего нельзя делать вне структуры
        }
    
        struct Bar {
        };
    };
    
    int main() {
        Foo::Bar b; // вызов вложенной структуры Bar
    }
```

**Агрегатная инициализация простых классов через {}**
    Мы можем инициализировать поля простого класса таким способом с C++11. Если не все поля структуры переданы в {} будет warning, но поле просто примет дефолтное значение.
```c++
    #include <iostream>
    
    struct ratio {
        int num;
        int denom;
    };
    
    int main() {
        // aggregate initialization. Looks like an automatically generated constructor
        [[maybe_unused]] ratio r1{};
        [[maybe_unused]] ratio r2{3};  // num = 3, warning about missing 'denom' initializer
        [[maybe_unused]] ratio r3{3, 4};  // num = 3, denom = 4
    }
```


