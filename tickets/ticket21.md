## Билет 21. Функции-члены (методы)

* ## Синтаксис объявления и вызова через `.` или `->`.

[Данный момент в лекции](https://youtu.be/Ff1pBiDkPOA?t=2021)
[Соответствующий файл](https://github.com/hse-spb-2021-cpp/lectures/blob/master/03-210916/02-struct/01-struct.cpp)

**Функция-член** (англ. _member function_, жарг. _метод_) - функция, которая позволяет работать с объектом и всеми его полями класса, в котором объявлена (но при этом `friend` и `static` методами не являются, смотри ниже)

Синтаксис объявления - написали обычную функцию, но внутри структуры

```c++
struct Point {
    // members
    int x, y;

    // member function
    int dist2() {
        return x * x + y * y;
    }
}
```

(А ещё можно объявить в структуре, а определить потом вообще в другом месте, смотри последний пункт билета)

К функции добавляется аргумент, который не видно (_неявный аргумент_) `this`, смотри ниже. 

Синтаксис вызова через `.`:

```c++
...
Point p;
p.x = 10;
p.y = 20;
std::cout << p.dist2() << "\n";
...
```

По сути это просто вызов метода от объекта.

Синтаксис вызова через `->`, как и при работе с обычными указателями:

```c++
...
Point *p2 = &p;
std::cout << p2->dist2() << "\n";
```

По сути `p2->dist2()` это просто обёртка над `(*p2).dist2()`

* ## Ключевое слово `this`

[Данный момент в лекции](https://youtu.be/Ff1pBiDkPOA?t=2054)

К функции добавляется аргумент, который не видно (_неявный аргумент_) `this` - объект (==указатель на объект!==), на которой этот метод был вызван.

В отличие от питона (в котором аргумент `self` явный), к полям можно обращаться просто по именам (вместо `self.x` в том же питоне)

[Более подробно про `this`](https://youtu.be/ZStm-I4K0so?t=4529)

`this` - в любом методе (именно методе, `friend` и `static` не методы) объект, на котором мы вызываем метод, **указатель** на структуру, в которой работаем.

  * ### Где его можно не писать, зачем писать хоть где-то.
  
  Можно не писать при обращении к полям объекта, в методе от которого мы работаем. 
  
  ==ИСТОЧНИК ОТСУТСТВУЕТ==
  Писать нужно, когда мы в методе хотим, например, закинуть куда-нибудь ссылку на себя, например при реализации двусвязного списка:
  
```c++
struct node {
	int value;
	node *prev; 
    node *next;
    
    void append_right(node *child) {
        next = child;
        child->prev = this;
    }

    void append_left(node *child) {
        prev = child;
        child->next = this;
    }
};
```
  
  * ### Чем метод отличается от свободной функции.
  
  [Данный момент в лекции](https://youtu.be/ZStm-I4K0so?t=4395)
  
  Методы объявляются в структуре, могут рекурсивно вызываться друг из друга без необходимости предварительного объявления (т.к. внутри структур совместимости с `C` уже нет, можно жить в два прохода):
  
```c++
struct Foo{
  void foo() {
    bar();
  }
    
  void bar() {
    foo();
  }
};
```
  
  Метод - функция-член, находится в структуре, ей же и принадлежит. Сразу же имеет доступ к приватным полям (да и вообще к `this`)
  
  Свободная функция - функция, не находящаяся в какой-либо структуре, не имеет доступа к приватным полям
  
  А ещё есть `friend` функции, которые могут быть определены снаружи, но при этом иметь доступ к приватным полям. Методами не являются, по сути -- свободные функции
  
  А ещё есть `static` функции, которые всё ещё `friend`, которые всё ещё не методы, но она лежит внутри класса (с точки зрения имени)
  
  * ### Захват `this` в лямбды: `[]`, `[=]`, `[&]`, `[this]`, `[*this]`
  
[Соответствующий момент в лекции](https://youtu.be/XdrSzs04HKU?t=3195)
[Соответствующий файл](https://github.com/hse-spb-2021-cpp/lectures/blob/master/13b-211215/02-lambdas/01-lambda-captures.cpp)

С данной темой связан билет: Функторы и лямбды
  
  Будем рассматривать следующую ситуацию:
  
```c++
struct Foo {
    int member_var = 10;
    static inline int static_member_var = 20;
    int arr[10'000];

    void method() {
        int local_var = 30;
        static int static_local_var = 40;
        [[maybe_unused]] long long local_big[100]{};
        ...
    }
};
```

Если мы далее в `method` объявим лямбду через `[]`, то у неё будет доступ к объектам со `static`-storage duration, к `this` (и, как следствие, к `member_var`, `arr`) доступа нет

Если же мы объявим через `[=]`, т.е. всё по значению, то указатель `this` захватится по значению! И у лябмды будет прямой доступ к `member_var` и `arr`, без копирований. (А остальные локальные захватятся по значению, если будут использоваться)
Подводя итог по `[=]` - имеем прямой доступ к полям структуры, из которой вызвались, можем их редактировать и радоваться жизни (т.к. указатель не константный)

При лямбде через `[&]` захват идёт не по значениям, а по ссылкам, в том числе у нас будет ссылка на `this`, а не копия указателя.
Всё ещё легально редактировать поля, т.к. прямой доступ есть, хоть и по ссылке на указатель.

Можно захватить `[this]` - просто захват указателя на себя по ссылке

А можно явно захватить прям объет `this` - `[*this]`, теперь будет целиком скопирован весь объект, всё будет скопировано внутрь, в лямбду.


  
* ## Const correctness: ограничение доступа к полям (в том числе ссылочным и указателям) при константном `this`.

  * ### Когда возникает константный `this`.
  
  [Данный момент в лекции](https://youtu.be/Ff1pBiDkPOA?t=2372)
  [Соответствующий файл](https://github.com/hse-spb-2021-cpp/lectures/blob/master/03-210916/02-struct/02-const.cpp)
  
  Пусть у нас есть функция, которая принимает объект по константной ссылке (чтобы не менять и не копировать объект):
  
```c++
  void print(const Point &p) {
      std::cout << p.x << " " << p.y << "\n";
      std::cout << p.dist2() << "\n";
  }
```
  
  Если `dist2` реализован так, как мы его описывали ранее:
  
```c++
  struct Point {
      ... 
      int dist2() {
          return x * x + y * y;
      }
  }
```
  
  То данный код не скомпилируется с ошибкой вида `error: passing 'const Point' as 'this' argument discards qualifiers`
  
  `p` - `const Point`, `this` - объект, на котором работаем. Компилятор по умолчанию считает, что любой метод меняет объект.
  Как итог: компилятор видит, что метод `dist2` меняет объект, значит его нельзя вызывать на константном `this`.

  
  * ### Const qualifier и ограничения внутри такого метода.
  
  Сам компилятор посмотреть на тело метода и понять, что ничего не меняется, не может (реализация может быть вообще в другом месте, например).
  
  В таком случае мы сами должны указать компилятору, что метод не меняет объект - добавить `const` qualifier:
  
```c++
int dist2() const {
    return x * x + y * y;
}
```

   Теперь компилятор разрешает вызывать этот метод на константных объектах, и при компиляции данного метода компилятор проверит, что метод не изменяет ни одно из полей.
   
   Общее правило: если вы можете сделать какой-то метод константным - сделайте. 
  
  * ### Когда будет UB при отбрасывании const qualifier внутри метода.
  
  Пусть у меня `dist2` не константный, но я очень хочу вызвать его на константном объекте. Можно попробовать взять неконстантную ссылку на объект и вызвать метод от неё.
  
  Если брать ссылку тупым образом `Point &p2 = p`, то произойдёт падение на этапе компиляции: `error: binding reference of type 'Point&' to 'const Point' discards qualifiers`
  
  Но мы знаем про приведение типов и C-style cast.
  
```c++
void print(const Point &p) {
    std::cout << p.x << " " << p.y << "\n";

    Point &p2 = (Point&)p;
    std::cout << p2.dist2() << "\n";
}
```

  Вообще C-style cast-ом пользоваться не нужно, он творит хрень. Он и сейчас сотворит хрень, но прямо сейчас это **не UB**, потому что наш метод **действительно ничего не меняет** и исходная точка `p`, которую мы передали в функцию, была не константной.
  
  А вот если, например, сделать так (объявить точку `p` константной):
  
```c++
int main() {
...
    const Point const_p{30, 40};
    print(const_p);
}
```

  И вот теперь начинается **UB**
  
  Запрещается вызывать неконстантные методы на исходно константных объектах.
  
  Объяснение: константные объекты могут храниться в памяти, в которую ничего нельзя записывать, это может быть другое адресное пространство и неконстантному методу будет плохо.
  
  А `static_cast` просто не скомпилируется, используйте `static_cast`. А ещё существует `const_cast`, который позволяет отбрасывать константность. Но он заметный и почти не возникает в реальности.
  
  Итог: при отбрасывании `const`-квалификатора произойдёт **UB** если

  1) Исходный объект был сам по себе константным (тут точно произойдёт)
  2) Метод как-то изменяет поля объекта (а вот тут уже не факт, Егор сам не уверен)
  
* ## Ref qualifier `&`

[Данный момент в лекции](https://youtu.be/DXABuiEBx-8?t=1100)
[Соответствующий файл](https://github.com/hse-spb-2021-cpp/lectures/blob/master/07-211013/02-classes/02-ref-qualifier.cpp)

Пусть есть что-то такое:

```c++
class stack {
    std::vector<int> data;

public:
    void push(int x) {
        data.push_back(x);
    }

    ...
};

stack foo() {
    stack s;
    s.push(1);
    s.push(2);
    return s;
}

int main() {
    foo().push(10);
}
```

Что произойдёт в `main`? `foo()` вернёт временный объект, у которого мы ещё вызвали `push`. Всё легально, но звучит как чушь, без особого смысла поменяли временный объект.

Как запретить? Добавить _ref qualifier_ (один амперсанд в то же место, где был `const` квалификатор):

```c++
...
void push(int x) & { // ref qualifier
    data.push_back(x);
}
```

Теперь этот метод нельзя вызывать на временных объектах, при попытке компиляции нам сообщат, что мы пытаемся отбросить квалификатор, вызывая этот метод от временного объекта.

Кстати, если совместить `const` и `ref` квалификаторы, то получим константную ссылку, но всё и так передаётся по константной ссылке, так что `const&` окажет 0 эффекта.

_ref qualifier_ - 

* ## Определение методов внутри и снаружи класса, неявный `inline` и зачем.

[Немного про определения методов внутри и снаружи класса](https://youtu.be/ZStm-I4K0so?t=4604)

Мы можем объявить метод внутри структуры:

```c++
struct Foo {
    void foo(int n);    // Declaration
};
```

А определить уже снаружи, но тогда нам потребуется "полное имя" функции:

```c++
void Foo::foo(int n) {
    std::cout << "called foo(" << n << ")\n";
}
```

Бывает полезно, поскольку иногда у нас функции объявляются в одном файле, а определяться могут в другом, и вообще в другой единице трансляции

[Файл про `inline`](https://github.com/hse-spb-2021-cpp/lectures/tree/master/08-211020/03-linkage/01-inline)
[Про `inline` на лекции](https://youtu.be/XdrSzs04HKU?t=4074)

`inline` по сути относится к `linkage` сообщает о том, что можно забить на ODR и выбирать любое определение функции, т.к. они одинаковые. Исторически - функцию нужно скопировать вместо вызова, но сейчас это уже не всегда выполняется компилятором.
Проблема - везде нужно видеть её тело. И так далее, смотри `inline` в другом билете.
 
 Но нас сейчас интересует неявный `inline`.
 
 `inline` необходим для методов класса, если вы их реализуете снаружи (в header-е, но вне тела структуры), но при реализации метода внутри структуры `inline` добавляется автоматически. Логика: если вы пишете структуру, то пишете её в хэдере, если реализовали метод в структуре, то это тоже в хэдере, значит метод реализуют в нескольких единицах трансляции, значит нужен `inline`.
 