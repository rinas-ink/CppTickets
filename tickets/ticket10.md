## Билет 10. Базовый синтаксис

### Встроенные типы

[типы](https://en.cppreference.com/w/cpp/language/types)
int - целые числа, в стандарте - минимум 2 байта, обычно 4. Диапазон значений от -2^31 до 2^31 (от −2 · 10^9 до 2 ·
10^9).

double - вещественные, обычно 8 байт, диапазон приблизительно 18 единиц. Двоичные числа хранятся приблизительно +
двоичной системе счисления, поэтому стоит быть аккуратными, например 0.1 + 0.2 != 0.3

long long - обычно 8 байт, от -2^63 до 2^63  (−9 · 10^18 до 9 · 10^18)

bool - обычно 1 байт, true(1) / false(0), по историческим причинам причисляется к
целочисленным   [примеры](https://github.com/hse-spb-2021-cpp/lectures/blob/master/02-210909/01-trivial-types/01-bool.cpp)

char - обычно 1 байт и знаковый, диапазон от -128 до 127, в арифметике ведет себя как
целочисленный: [примеры](https://github.com/hse-spb-2021-cpp/lectures/blob/master/02-210909/01-trivial-types/03-char.cpp)

signed - знаковый, обычно не надо дополнительно это указывать

unsigned - беззнаковый, значения из отрицательного диапазона перекидываются в положительный (unsigned int от 0 до 2^32),
переполнение - берется по модулю (переполнение знакового - UB!).

### Литералы

Литералы - это значения, которые вставляются непосредственно в код.
[примеры](https://github.com/hse-spb-2021-cpp/lectures/blob/master/02-210909/01-trivial-types/04-literals.cpp)

#### Целочисленные

* префикс - основание (СС). Есть 0b, 0 (просто 0), 0x.
    * 0b -- двоичная система счисления,
    * 0 -- восьмеричная система счисления,
    * 0x -- шестнадцатеричная система счисления.
* суффикс: U -- unsigned, L -- long, LL -- long long

К примеру: `0xdeadbeefU` -- беззнаковый инт 3735928559.

#### Вещественный

По умолчанию вещественные числа имеют тип `double`, можно добавить суффикс `f` для `float` и `L` для `long double`.

#### Символьный

Символьная константа в ' ' или обратный слеш + символ (
например [escape-последовательности](https://en.cppreference.com/w/cpp/language/escape)), применяются коды из ASCII или
Unicode.

### Строковые литералы

[строковые и символьные литералы](https://docs.microsoft.com/ru-ru/cpp/cpp/string-and-character-literals-cpp?view=msvc-170)
Строковый литерал – последовательность символов в " " с завершающим нулем. raw string literal - необработанные строковые
литералы [пример](https://www.geeksforgeeks.org/raw-string-literal-c/)

### Склейка подряд написанных строковых литералов на этапе компиляции

```c++
    std::string s1 = "hello" "world"; //препроцессор склеит в один строковый литерал
    std::string s2 = "he\n\t\xFF" R"foo(Hello World)foo"; //и обработает все эти штуки 
    "AB" + "CD"; //не скомпилируется
```

### static_cast<>

Приведения типов, есть еще вариант в стиле C - (int), но со сложными типами static_cast<> безопаснее Пример избавления
от переполнения при умножении int'ов.

```c++
int x = 1e9; 
long long y = x * x; 
```

Будет UB, тк выполнится вначале правая часть int * int = int, а тут переполнение типа. Решение:

```c++
int x = 1e9; 
long long y = static_cast<long long> (x) * x; 
```

### Разница между i++ и ++i.

i++ - возвращает значение, увеличивает  
++i - наоборот

```c++
a = b++; // a = b; b++;
a = ++b; // b++; a = b;
```

### Составные операторы присваивания

сокращенные операторы присваивания типа *=, /=, %= Возвращают ссылку на объект
` y = x += 10; // x+= 10; y = x;`

### Expression и statement

expression - выражение, что-то вычисляющее значение: выражения, вызовы функций, обращения к
переменной [примеры](https://en.cppreference.com/w/cpp/language/expressions)
statement - инструкция, команда. Что-то типа if, while, for, объявления
переменных [примеры](https://en.cppreference.com/w/cpp/language/statements)
[пример с лекции](https://github.com/hse-spb-2021-cpp/lectures/blob/master/05-210930/00-before/00-comma.cpp)
[типы expression](https://docs.microsoft.com/en-us/cpp/cpp/types-of-expressions?view=msvc-170)

### Оператор ,

[этот же пример с лекции](https://github.com/hse-spb-2021-cpp/lectures/blob/master/05-210930/00-before/00-comma.cpp)
Объединяет выражения, вычисляет их, возвращает результат правого. Циклы через запятую не записать, тк это statement. Еще
используется, когда несколько параметров в цикле. Еще пример (у запятой низкий приоритет):

```c++
a = b, c; // a = b
a = (b,c); // a = c
```

### Синтаксис: for, while, if.

E - expression, S - statement

```c++
for(E,E,E)
    S
```

[цикл](https://en.cppreference.com/w/cpp/language/for)
например:

```c++
for (int i = 0; //происходит перед циклом 
i < n; //проверяется перед каждой итерацией 
i++) { //выполняется в конце каждой итерации 
} 
```

break - выход из цикла continue - следующая итерация

```c++
while(E)
    S
```

```c++
if(E) // еще может быть if(<создание переменной>; E)
    S1
else 
    S2
```

### Тернарный оператор

<проверяемое условие> ? <оператор выбора 1> : <оператор выбора 2>
Может возникнуть проблема,когда ветки разных типов, тогда непонятно, какой тип возвращать:
[пример с лекции](https://github.com/hse-spb-2021-cpp/lectures/blob/master/04-210923/01-functions/02-lcm.cpp)
[таймкод](https://youtu.be/f2aiF6dQQ7c?t=217)

### Range-based for

[cppreference](https://en.cppreference.com/w/cpp/language/range-for)
Вместо for (int i = 0; i < n; ++i) - for (int x : vec) - инициализируется новая переменная x на каждой итерации, в
которую копируется элемент вектора. Если взять по ссылке:
for (int &x : vec)
то можно изменить значение переменной в векторе, копирования не происходит. Константная ссылка - нельзя изменить
значение переменной, копирования не происходит.

auto - в некоторых контейнерах удобнее писать auto it, чем typename std::set<int>::iterator it; Каким типом будет auto
определяется во время компиляции Можно использовать auto, когда храним пары или некоторые структуры, итерируемся по map.
[примеры](https://github.com/hse-spb-2021-cpp/lectures/blob/master/03-210916/01-extra-stl/03-map.cpp)
`auto a; // не скомпилируется`

### Порядок вычислений

[ссылка](https://notes.algoprog.ru/cpp/additional.html#id4)
Если вкратце:
порядок вычислений аргументов функций происходит на усмотрение компилятора, когда он хочет что-то соптимизировать в
логических операторах  `if(i < v.size() && v[i] == 0)` - порядок слева направо инициализация переменных в порядке
объявления
`f(), b() // через запятую тоже все в порядке`
при инициализации при помощи {} (обычно у вектора) порядок тоже слева направо в стандарте C++17 в некоторых выражениях
зафиксирован порядок вычислений: слева-направо вычисляются выражения при вводе через >> и выводе через << . При
присваивании через =, += и похожие операторы: сначала вычисляется часть справа, а потом часть слева. Пример:

```c++
int a,b;
a = b = 5; // b = 5; a = b;
```

если бы порядок был другой, получили бы UB

