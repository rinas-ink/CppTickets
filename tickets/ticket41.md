## Билет 41. Использование наследования для неполиморфных классов

### Совместимость по ссылкам и указателям

#### Устройство

В C++ совершенно бесплатно можно получить делать `basecast` (`upcast`): кастовать объект типа `Derived&` (здесь и далее
считаем, что `Derived` наследуется от `Base`) к типу `Base&`, то есть получать ссылку на базу от Derived.

Причем делать это можно неявно, потому что мы считаем, что внутри памяти базовый класс лежит суперхорошо и приятно.

Заметим, что так делать можно и с указателями, все правила те же, преобразование такое неявное.

```c++
struct Base {
    int x = 10;
    void foo() const {
        std::cout << "x = " << x << std::endl;
    }
};

struct Derived : Base {
    int y = 20;
    void bar() const {
        std::cout << "x = " << x << " y = " << y << std::endl;
    }
};

int main() {
    Derived d;
    Base& b = d; // произошел basecast
    b.x++; // так можно
    b.y++; // так нельзя
    Derived* d_ptr = d;
    Base* b_ptr = d_ptr; 
    b_ptr->foo(); // OK
    b_ptr->bar(); // CE
```

#### Усиляем x2 (slicing)

Пусть теперь у нас `foo` принимает не ссылку, а значение, то есть просто `Base`. После этого мы никогда не сможем делать
derivedcast, это всегда UB, UB ровно такое же, что и выше. Но! `foo` от `Derived` все еще можно вызвать. Это как раз и
называется `Slicing`, то есть "урезание".

Как это работает: когда мы делаем вызов `foo(d)`, то мы вызываем копирующий конструктор `Base(const Base &other)`, где
происходит basecast. После этого мы больше никак не можем вернуть тип `Derived`, поэтому и обратиться к полям `Derived`
больше нельзя. Соответственно, если попытаться сделать `derivedcast`, то можно получить ~~по лицу~~ UB.

Методика избежания слайсинга похожа на знаменитый метод "Насильник, не насилуй". То есть, просто будьте аккуратнее,
следите за типами, передавайте по ссылке и не пишите плохой код.

### Конструкторы и наследование: отличие от наследования обычных методов

Конструкторы не наследуется по умолчанию (специальные
методы ([смотри подробней](https://github.com/hse-spb-2021-cpp/lectures/blob/master/09-211110/00b-special-operators.cpp))
тоже, но они стараются сгенирироваться самостоятельно). Причем в конструкторе `Derived` мы всегда обязаны
сконструировать базовый класс, поэтому, если у `Base` нет конструктора по умолчанию, то мы должны явно его вызвать. В
отличие от других языков программирования, в C++ всего один способ вызвать конструктор родительского класса:
использовать member initialization list (когда задаем конструкторы через запятую после двоеточия). Пример:

```c++
struct Base {
    int x;
    Base(int x_) : x(x_) {}
};

struct Derived : Base {
    int y = 20;

    Derived() : Base(10) {} // Здесь нельзя вызывать без Base(10)
//    Derived(int y_) : y(y_), Base(0) {}  // -Wreorder, могут быть проблемы, потому что БАЗовый класс должен инициализироваться первым, 
//                                            -Wreorder как раз про это
//    Derived(int y_) : Base(y_), y(y_) {} // ok
    Derived(int y_) : Base(y_), y(y_) {}  // OK
};

struct SubDerived : Derived {
    SubDerived(int) {}  // : Derived() is implied. All right, no UB
};
```

Второй важный момент: родительские классы всегда инициализируются раньше, чем производные. Это очень важный принцип,
который используется дальше.

### final

Пока говорим о `final` для структур, а здесь все просто. После имени класса пишем `final` и запрещаем наследование от
нас:

```c++
struct Base {};
struct Derived1 final : Base {
    int value = 123;
};
struct SubDerived : Derived1 {}; // ban. Будет ошибка компиляции
```

### Пример неполиморфного наследование при реализации двусвязного списка с фиктивным элементом

Второй пример уже от Егора. Пусть мы хотим реализовать двусвязный список с фиктивной вершиной (то есть с вершиной, в
которой не лежит никаких данных). Для этого можно реализовать базовый класс `node`, который будет содержать только
**указатели** на соседей и сделать от него наследника `node_with_data`, в которого дополнительно положить данные.

После этого добавление и удаление из списка ни коем образом не завязано на том какого типа у нас вершины. При этом, если
у нас фиктивная вершина только стартовая, то можно удобно итерироваться и получать данные при помощи derivedcast. Полный
код:

```c++
#include <iostream>

struct node {
    node *prev = nullptr;
    node *next = nullptr;
};

struct node_with_data : node {
    int data;

    node_with_data(int data_) : data(data_) {}
};

void link(node &x, node &y) {
    x.next = &y;
    y.prev = &x;
}

int main() {
    node l;
    node_with_data a(10), b(20), c(30);

    link(l, a);
    link(a, b);
    link(b, c);
    link(c, l);

    for (node *it = l.next; it != &l; it = it->next) {
        auto it_data = static_cast<node_with_data*>(it);
        std::cout << it_data->data << "\n";
    }
    std::cout << "=====\n";

    node_with_data d(40);
    link(a, d);
    link(d, b);

    for (node *it = l.next; it != &l; it = it->next) {
        auto it_data = static_cast<node_with_data*>(it);
        std::cout << it_data->data << "\n";
    }
}
```

### Вызов невиртуальной функции

Тут важный момент, что если сделать `basecast`, то всегда будет вызываться функция из `Base`, даже если в `Derived` было
какое-то новое определение. Например, такое может происходить с деструкторами и поэтому все может ломаться в такой
ситуации:

```c++
struct Base {};
struct Derived : Base{ int x };

...

Base* b = new Derived(10); // законно, произошел basecast

delete b; // Утечка памяти, не почистили поле x
```