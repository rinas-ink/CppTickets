## Билет 41 (Базовое наследование)

### Совместимость по ссылкам и указателям

#### Устройство

В C++ совершенно бесплатно можно получить делать `basecast` (`upcast`): кастовать объект типа `Derived` (здесь и далее
считаем, что `Derived` наследуется от `Base`) к типу `Base&`, то есть получать ссылку на базу от Derived.

Причем делать это можно неявно, потому что мы считаем, что внутри памяти базовый класс лежит суперхорошо и приятно.

Заметим, что так делать можно и с указателями, все правила те же, преобразование такое неявное.

```c++
struct Base {
    int x = 10;
    void foo() const {
        std::cout << "x = " << x << std::endl;
    }
};

struct Derived : Base {
    int y = 20;
    void bar() const {
        std::cout << "x = " << x << " y = " << y << std::endl;
    }
};

int main() {
    Derived d;
    Base& b = d; // произошел basecast
    b.x++; // так можно
    b.y++; // так нельзя
    Derived* d_ptr = d;
    Base* b_ptr = d_ptr; 
    b_ptr->foo(); // OK
    b_ptr->bar(); // CE
```

#### Мотивация

Если у нас есть функция, которая должна работать на всех методах, отнаследованных от `Base`, то в целом upcast --
единственный способ сделать такое:

```c++
void foo(Base& b) {
    std:cout << "foo(" << b.x << ")" << std::endl;
}
```

Например, в STL такое используется при создании `operator>>` или `operator<<` для вывода. Подробнее: есть два как бы
базовых класса `istream` и `ostream`, от которых мы как раз делаем операторы, а потом `cin/cout` делают `upcast` к ним.

Второй пример уже от Егора. Пусть мы хотим реализовать двусвязный список с фиктивной вершиной (то есть с вершиной, в
которой не лежит никаких данных). Для этого можно реализовать базовый класс `node`, который будет содержать только
**указатели** на соседей и сделать от него наследника `node_with_data`, в которого дополнительно положить данные.

После этого добавление и удаление из списка ни коем образом не завязано на том какого типа у нас вершины. При этом, если
у нас фиктивная вершина только стартовая, то можно удобно итерироваться и получать данные при помощи derivedcast. Полный
код:

```c++
#include <iostream>

struct node {
    node *prev = nullptr;
    node *next = nullptr;
};

struct node_with_data : node {
    int data;

    node_with_data(int data_) : data(data_) {}
};

void link(node &x, node &y) {
    x.next = &y;
    y.prev = &x;
}

int main() {
    node l;
    node_with_data a(10), b(20), c(30);

    link(l, a);
    link(a, b);
    link(b, c);
    link(c, l);

    for (node *it = l.next; it != &l; it = it->next) {
        auto it_data = static_cast<node_with_data*>(it);
        std::cout << it_data->data << "\n";
    }
    std::cout << "=====\n";

    node_with_data d(40);
    link(a, d);
    link(d, b);

    for (node *it = l.next; it != &l; it = it->next) {
        auto it_data = static_cast<node_with_data*>(it);
        std::cout << it_data->data << "\n";
    }
}
```

#### Усиляем! (derived-cast)

Если в `foo` мы точно знаем, что переданная нам ссылка на `Base` пришла от `Derived`, то можно вернуться к `Derived`:

```c++
void foo(Base& b) {
    std:cout << "foo(" << b.x << ")" << std::endl;
    const Derived& d = static_cast<const Derived&>(b); // you need to use static_cast
}
```

Данный прием называется derivedcast или downcast. Прием очень опасный: его можно применять только в том случае, если мы
точно на 100% безошибочно знаем, что `b` -- на самом деле `Derived`. А иначе у нас будет UB, причем UB случится сразу в
момент каста, то есть даже если дальше мы не используем поля `Derived`.

Важный момент, что мы здесь используем `static_cast`. Вот, если хоть на секунду предположить, что мы его не используем,
то могут происходить различные страшные вещи. Например:

```c++
int main() {
    string s = "LOL!";
    int &x = (int&)(s); // UB
    cout << x << '\n'; // на моем компиляторе каждый запуск генерируется случайное число
}
```

Компилятор и слова не скажет о том, что вы не правы и так делать нельзя. А вот `static_cast` запретит вам компиляцию и
скажет, что вы не правы.

#### Усиляем x2 (slicing)

Пусть теперь у нас `foo` принимает не ссылку, а значение, то есть просто `Base`. После этого мы никогда не сможем делать
derivedcast, это всегда UB, UB ровно такое же, что и выше. Но! `foo` от `Derived` все еще можно вызвать. Это как раз и
называется `Slicing`, то есть "урезание".

Как это работает: когда мы делаем вызов `foo(d)`, то мы вызываем копирующий конструктор `Base(const Base &other)`, где
происходит basecast. После этого мы больше никак не можем вернуть тип `Derived`, поэтому и обратиться к полям `Derived`
больше нельзя. Соответственно, если попытаться сделать `derivedcast`, то можно получить ~~по лицу~~ UB.

Методика избежания слайсинга похожа на знаменитый метод "Насильник, не насилуй". То есть, просто будьте аккуратнее,
следите за типами, передавайте по ссылке и не пишите плохой код.

### Расположение подобъектов в памяти и padding (пустое место для выравнивания).

Сейчас рассматриваем базовое наследование, если будет множественное, то там может быть несовпадение адресов, конечно же.

Заметим, что если вывести `b_ptr` и `d_ptr`, то они неожиданным образом совпадут. Это ни разу не совпадение, стандарт
гарантирует, что базовый класс всегда лежит в начале производного класса.

Следующий момент: выравнивание. Каждый тип имеет свое выравнивание --- его адрес должен делиться на какое-то хорошее
число (например, адрес `int` должен делиться на 4, а адрес `char` на 1). Это пошло из некоторых особенностей архитектуры
процессоров, так как они не могут работать с плохими адресами.

Поэтому иногда получается так, что структура имеет размер больший, чем суммарный размер всех её полей. Например:

```c++
struct Bar{ // address = x
    char c; // alignof(char) == 1, address = x
    int i; // alignof(int) == 4, address = x + 1 is bad -> address = x + 4
}; // sizeof(Bar) == 8
```

Другой интересный пример:

```c++
struct Buzz{
    char c; // address = x
    int i; // address = x + 4
    char c2; // address = x + 8
}; // sizeof(Buzz) == 12, WTF?!

struct Foo{
    int i; // address = x
    char c; // address = x + 4
    char c2; // address = x + 5
}; // sizeof(Buzz) == 8, WTF?!
```

А ответ в данном случае такой: размер структуры должен делить на её `padding` = `max align` её полей. Это важно,
например, в тот момент, когда мы кладем структуры в массив. Выравниванием, как видно, можно легко управлять при помощи
порядка полей. Компилятор не сделает это за вас, потому что что-нибудь может быть на этом завязано (например, порядок
аргументов в конструкторе). При этом все переменные одного уровня доступа лежат подряд.

### Конструкторы и наследование: отличие от наследования обычных методов

Конструкторы не наследуется по умолчанию (специальные
методы ([смотри подробней](https://github.com/hse-spb-2021-cpp/lectures/blob/master/09-211110/00b-special-operators.cpp))
тоже, но они стараются сгенирироваться самостоятельно). Причем в конструкторе `Derived` мы всегда обязаны
сконструировать базовый класс, поэтому, если у `Base` нет конструктора по умолчанию, то мы должны явно его вызвать. В
отличие от других языков программирования, в C++ всего один способ вызвать конструктор родительского класса:
использовать member initialization list (когда задаем конструкторы через запятую после двоеточия). Пример:

```c++
struct Base {
    int x;
    Base(int x_) : x(x_) {}
};

struct Derived : Base {
    int y = 20;

    Derived() : Base(10) {} // Здесь нельзя вызывать без Base(10)
//    Derived(int y_) : y(y_), Base(0) {}  // -Wreorder, могут быть проблемы, потому что БАЗовый класс должен инициализироваться первым, 
//                                            -Wreorder как раз про это
//    Derived(int y_) : Base(y_), y(y_) {} // ok
    Derived(int y_) : Base(y_), y(y_) {}  // OK
};

struct SubDerived : Derived {
    SubDerived(int) {}  // : Derived() is implied. All right, no UB
};
```

Второй важный момент: родительские классы всегда инициализируются раньше, чем производные. Это очень важный принцип,
который используется дальше.

### Права доступа

В этот момент надо тупо открыть и показывать `12-211201/03-access-specifiers` тут по-другому никак.

#### 10-public.cpp

Публичные имена можно вызывать и получать где угодно и когда угодно. Все просто.

Друзья (как функции, так и классы) здесь не имеют значения, так как все публичное.

#### 11-private.cpp

Усложняем! Теперь можно вызывать методы только у себя. У друзей доступ только к другу, но не к отцу/сыну друга. Но при
этом у отца/сына друга никакого доступа к нам.

При этом важный момент, что дружба не наследуется ни каким образом: сын друга не является другом.

#### 12-protected.cpp

Методы получают доступ к методам отцов (дедов, ...)/своим. Но Base&.base_method (**basecast**) нельзя вызывать, ибо по
ссылке лежит что-угодно.

Строгое правило: мы имеем доступ к методам родителей, если мы уверены, что вызываем от родителя. Поэтому ссылочные типы
или указатели отправляются домой.

А что друзья? Друг Derived имеет доступ к методам Derived, но не к SubDerived. А что с методами Base? А кто его знает)
Там открытый issue на гитхабе: зависит от стандарта, компилятора, фазы луны, номера лабы, ...

### final

Пока говорим о `final` для структур, а здесь все просто. После имени класса пишем `final` и запрещаем наследование от
нас:

```c++
struct Base {};
struct Derived1 final : Base {
    int value = 123;
};
struct SubDerived : Derived1 {}; // ban. Будет ошибка компиляции
```

### Hiding

Пусть у нас есть такой набор структур:

```c++
struct Base {
    void foo() {
        std::cout << "no args\n";
    }
    void foo(int) {
        std::cout << "int\n";
    }
};
struct Derived : Base {};

struct SubDerived : Derived {
    void foo(double) {
        std::cout << "double\n";
    }
    
    // void foo(int x) { std::cout << "SubDerived int\n"; Derived::foo(x); }
    // void foo() { std::cout << "SubDerived no args\n"; Derived::foo(); }
};
```

Разберемся с `Base`: у него можно вызывать `foo()`, `foo(int)`, `foo(double)`. Все просто, простые перегрузки.

С `Derived` все то же самое. Ничего не поменялось.

А теперь начинаются мемы. Вот мы в `SubDerived` решили добавить новую перегрузку от `double`. Но теперь нельзя
вызывать `foo()`. Произошол _Hiding_.

Теперь более формально, что произошло. Рассмотрим механизм вызова невиртуальных функций:

1. Name resolution (разрешение имени) Output: "overload set".
2. Overload resolution. Output: a single overload. Определяем перегрузку, результат: какая-то одна функция.
3. Access check. Определяем можно ли трогать.
4. Call, can be virtual or non-virtual. Вызываемся, смотря на виртуальность.

То есть в `SubDerived` перегрузка ломается на первом шаге: она видит только `foo(double)`, а в родительских классах
перестает искать. Для того чтобы вернуть перегрузки есть два способа:

1. Вернуть все руками,
2. Воспользоваться `using <BaseClass>::<functionName>`. Это сделать unhiding функции, причем ровно до следующего
   hiding'а.

А теперь разберемся что еще умеет `using`. Во-первых, он умеет изменять права доступа:

```c++
struct Base {
protected:
    void magic() {
    }  // Similarly for fields.
};

struct Derived : Base {
    using Base::magic; // теперь метод magic публичный
};

struct SubDerived : Derived {
    void magic2() {
        magic();
        Base::magic();
        Derived::magic();
    }

private:
    using Derived::magic; // а теперь снова приватный
};

 [[maybe_unused]] Base b;
// b.magic(); <- protected

 Derived d; 
 d.magic(); // <- public
 // d.Base::magic(); <- protected

 SubDerived sd;
 // sd.magic(); <- private
 // sd.Base::magic(); <- protected
 sd.Derived::magic(); // <- public
 sd.magic2();
```

Во-вторых, он умеет перегружать ВСЕ конструкторы базового класса при помощи синтаксиса `using <BaseName>::<BaseName>;`.
После этого у нас все в `Derived` будут все конструкторы из `Base` (но создавать они будут уже `Derived`), причем если
мы создать новый конструктор с совпадающей сигнатурой, то он скроет базовый конструктор.

