## Билет 12. Объявление переменных
Скраденно подчистую
* ###Объявление нескольких переменных, указателей, ссылок, в том числе константных.
Скомунизжено у нынешнего 2го курса
```c++
int a = 10, b = 11;
int lol = 5, kek = lol; 
const int c = 12;
int &x = a;
const int &y = b; //нельзя менять значение по ссылке
int *z = &a;
const int *w = &a; //нельзя менять значение по указателю
int * const q = &a; //нельзя перекинуть указатель на другой объект
const int * const e = &c; //нельзя два пункта выше
int * const r = &c;
//не компилируется, так как нет запрета на изменение значения
int &g = c;
//не компилируется, так как нет запрета на изменение значения
```
* ###Создание временного объекта.
Хз че тут рассказать, вот [статья](https://docs.microsoft.com/en-us/cpp/cpp/temporary-objects?view=msvc-160)
Ну а по факту - мы когда что-то вычисляем(a + b + c) или возвращаем из фукнций по значению, создаются временные объекты, куда эта радасть складывается, чтобы доделать вычисления и сдохнуть, как оно больше не нужно.

* ###Инициализация
[тут вроде нормас(нужно читать до The most vexing parse, он в некст билете)](https://github.com/vladnosiv/hse-spb-conspects-2020/blob/master/C%2B%2B/ticket32.md#%D0%B1%D0%B8%D0%BB%D0%B5%D1%82-32-%D0%B2%D0%B8%D0%B4%D1%8B-%D0%B8%D0%BD%D0%B8%D1%86%D0%B8%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8)
* ###Неинициализированные переменные/поля.
Кароче стандарт не гарантирует, что если вы не проинициализировали свои буковки, то там не будет мусора, полезете туда - UB. Хотя в случае глобального простравнста имен это кажется правда, что там стандартное значение
* ###Инициализация при помощи {}:
    * Для тривиальных типов. (заполняет стандартным занчением)
    * Для нетривиальных типов. (вызывает соответствующий конструктор)
    * Для массивов/векторов, в том числе вложенных. 
    * Временных объектов: с указанием типа (T{}, T()) и без указания типа ({}).
 
Опять воруем:
```c++
struct foo() {
int x, y, z;
}
int a{}; // a = 0(дефолтное значение инта)
int a{12}; //a == 12
vector<int> b = {3, 2}; //b[0] = 3, b[1] = 2
vector<int> b{3, 2}; //b[0] = 3, b[1] = 2
vector<vector<int>> mas{{1, 2}, {3, 4}};
vector<vector<int>> mas = {{1, 2}, {3, 4}};
foo f{1, 2} //f.x = 1, f.y = 2, f.z непроинициализированно
foo g{1, 2, 3}; //g.x = 1, g.y = 2, g.z = 3
vector<pair<int, int>> c;
c.push_back({2, 3});
//создали временный объект, компилятор сам понял, какой тип
c.push_back(std::pair<int, int>(2, 4));
c.push_back(std::pair<int, int>{2, 4});
```
* ###Пример, где инициализация через {} и () компилируются и ведут себя по-разному.
```c++
vector<int> a(3, 2); - вектор из трех двоек
vector<int> a{3, 2}; - вектор из тройки и двойки.
```
* ###Ссылки.
  * Можно ли отличить ссылку от объекта, на который она указывает.
    
    Ссылки обычно ведут себя идентично значениям, на которые они ссылаются. В этом смысле ссылка работает как псевдоним объекта, на который она ссылается. Еще можно воспользоваться `std::is_reference(T)` ([ссылка](https://en.cppreference.com/w/cpp/types/is_reference))
  * Использование константных ссылок.
    
    Они же ссылки на константные значения
    ```c++
        const int value = 7;
        const int &ref = value; // ref - это ссылка на константную переменную value
    ``` 
    
  * Константная ссылка не обещает, что объект не меняется (если ссылка на мутабельный объект).

    Как и в случае с указателями, константные ссылки также могут ссылаться и на неконстантные переменные. При доступе к значению через константную ссылку, это значение автоматически считается const, даже если исходная переменная таковой не является:
    ```c++
    int value = 7;
    const int &ref = value; // создаем константную ссылку на переменную value

    value = 8; // ок: value - это не константа
    ref = 9; // нельзя: ref - это константа
    ```
* ###auto и его модификации, как выводится тип(Вывод приватного типа или типа лямбды)
Авто откидывает всю константость и ссылки(если это хотим надо явно прописать).
Есть исключения.
```c++
int val = 10;
int &foo() {
    return val;
}
const int &bar() {
    return val;
}

int main() {
    {
        [[maybe_unused]] auto x = foo();  // int
        [[maybe_unused]] auto &y = foo();  // int&
        [[maybe_unused]] const auto &z = foo();  // const int&
    }
    {
        [[maybe_unused]] auto x = bar();  // int
        [[maybe_unused]] auto &y = bar();  // const int&
        [[maybe_unused]] const auto &z = bar();  // const int&
    }
}
```
Про тип лямбды:

У лямбды просто так нельзя выписать тип, так как лямбда -- синтаксический сахар над функторами, поэтому каждая лямбда имеет свой тип.

Поэтому можно либо пользоваться `std::function`, либо `decltype` (который, кстати, работает во время компиляции): 
```c++
int main() {
    auto l1 = [](int a, int b) { return a > b; };
    auto l2 = [](int a, int b) { return a > b; };
    std::set<int, decltype(l1)> s1(l1);
    // std::set<int, decltype(l1)> s2(l2); - сдохнет, тк типы разные, хоть лямбды и одинаковы
}
```
