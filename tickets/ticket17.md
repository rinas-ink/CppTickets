## Билет 17. Указатели

## Содержание

Каждый указатель относится к одному из 4 видов:
1. Указатель на объект или функцию.
2. Указатель на память следующую за последним элементом объекта.
3. Нулевой указатель - `nullptr`.
4. Invalid указатель - указывает куда угодно (мы не знаем, что в той памяти лежит).

* ## Базовый синтаксис
  * ### Объявление
    В общем случае выгладит так: `T *P`, где `T` - 
    это тип того, на что указатель указывает, `P` - это имя указателя.
    
    Примеры объявления (и инициализации в одном месте, а на самом месте в двух):
    ```c++
    const int ci = 10;       // просто cosnt int (не указатель)
    const int *pc = &ci;     // pс - указатель на переменную ci
    int i;                   // i - просто int (не указатель)
    int *p;                  // p - указатель (не инициализировали)
    
    struct node {
        int value;
        node *next, *prev;   // со структурками/классами синтаксис ровно такой же синтаксис
    };
    
    int main() {
    }
    ```
    
    >_Замечание:_ звездочка пишется именно перед указателем 
    (то есть для каждого указателя нужна отдельная звездочка)
    `node *next, *prev;`
    
    Приколы ([zero initialization](https://en.cppreference.com/w/cpp/language/zero_initialization)):
    ```c++
    int *ptr; // по-умолчанию ставится в nullptr (zero initialization)
              // кратко: nullptr ставится всем неинициализированным указателям со static storage duration
    
    int main() {
        int *another_ptr; // указывает на рандомное место в памяти (Invalid указатель)
    }
    ```

  * ### Разыменование
    
    Чтобы получить объект, на который ссылается указатель `ptr`, надо написать `*ptr`.

    >При разыменовании указателей вида 2,3,4 получаем UB.      

    Собственно, пример:
    ```c++
    #include <iostream>
      
    int *p;        			// просто указатель (nullptr по умолчанию)
    int x = 10;      		// просто int
    int *xp = &x; 			// xp с этого момента - указатель на x
      
    int main() {
      int y = *xp;          // в y копируем значение x
      int *nxp = xp;    	// nxp теперь тоже указатель на x
      
      std::cout << (*nxp) << " " << x << "\n";  // 10 10
      if (*nxp == x) {
          std::cout << "true\n";                // prints true
      }
    
      // int z = *p;      	// UB при разыминовании nullptr
      // int *p;         	// указатель p (invalid указатель)
      // *p;             	// тоже UB, потому что указатель - invalid
    }    
    ```
    >_Замечание:_ При выводе скобочки потерять нельзя из-за [приоритетов операторов](https://en.cppreference.com/w/cpp/language/operator_precedence).
  * ### Взятие адреса
        
    Собственно, чтобы получить адрес, на который указывает указатель `ptr`, 
    нужно написать `ptr` (то есть адрес, куда указывает указатель - это просто его значение).
  
    Пример:
    ```c++
    #include <iostream>
    
    int x = 10;        // просто int 
    int *px1 = &x;     // указатель на x
    int *px2 = &x;     // еще указатель на x
   
    int main() {
      std::cout << px1 << " " << px2 << "\n";    // выводим адреса переменной,
                                                 // на которую указывают px1 и px2
                                                 // (они совпадут)
      
      std::cout << &px1 << " " << &px2 << "\n";   // выводим адреса самих указателей
                                                  // (они разные) 
    }
    ```
    >_Замечание 1:_ `&ptr` - память, где лежит указатель. 
    `ptr` - память, где лежит переменная, на которую указывает указатель.   

  * ### Стрелочка `->`
    
    `->` - это просто синтаксический сахар для того, чтобы работать со структурками/классами
    было удобней.
  
    Написать стрелочку - то же самое, что и разыменовать указатель и применить к результату `operator.`.
    
    Пример:
    ```c++
    #include<iostream>
    
    struct node {            // структурка для двусвязного списка
      int data;              // значение node  
      node *next, *prev;     // указатели на предыдущий и следующий элементы списка
    }
    
    int main() {
      node a{10}, b{20}, c{30};  // создаем три элемента (пока что раздельных)
      a.prev = nullptr;          // говорим, что a - это начало списка, проинициализировав 
                                 // его предыдущий элемент nullptr (такой у нас инвариант)
      
      a.next = &b;               // связали элементы в список
      b.next = &c;               
      
      // теперь хотим вывести значение следующего элемента после a
      // давайте сделаем, как умеем
    
      std::cout << (*a.next).data << "\n";        // фуу
      
      // чтобы писать было на два символа короче, директор c++ придумал стрелочку:
    
      std::cout << a->data << "\n";               // теперь красиво 
    }              
    ```
  
* ## Реализация двусвязного списка
  Ну вот она:
  ```c++
  #include <iostream>
  
  struct node {
      int data;
      node *prev = nullptr, *next = nullptr;
  };
  
  void add_after(node& a, node&  b) {          // добавление элемента между a и a->next
      b.next = a.next;                         // говорим, что следующий за b элемент - это следующий за a в прошлом элемент
      if (b.next != nullptr) {                 // разыменование nullptr - UB
          b.next->prev = &b;                   // обновляем указатель на элемент идущий перед следующим за b
      }                                                                               
      a.next = &b;                             // все понятно: следующий за a теперь b
      b.prev = &a;                             // тоже понятно: предыдущий от b - это a
  }
  
  void add_before(node& a, node& b) {          // добавление элемента b между a->prev и a
      b.prev = a.prev;                         // элемент перед b теперь - это элемент перед a в прошлом
      if (b.prev != nullptr) {                 // разыменование nullptr - UB
          b.prev->next = &b;                   // обновляем указатель на идущий после элемента перед b
      }
      b.next = &a;                             // все понятно: следующий за b - теперь a
      a.prev = &b;                             // тоже понятно: следующий за a - теперь b
  }
  
  void remove(node& a) {                       // удаление элемента a 
      if (a.prev != nullptr) {                 // если есть элемент перед a, то обновим его
          a.prev->next = a.next;               // обновляем указатель на следующего за предыдущим элементом
      }
      if (a.next != nullptr) {                 // если есть элемент после a, то обновим его
          a.next->prev = a.prev;               // обновляем указатель на идущего пред слудющим за a
      }		
  }
  
  void print_list(node& head) {                // печть списка: не интеллектуально
      node *cur = &head;
      while (cur != nullptr) {                 // собственно, пока текущий выводмимый - не конец списка
          std::cout << cur->data << " ";       // выводим значение предыдущего head
          cur = cur->next;                     // теперь head - это следующий за head элемент
      }
      std::cout << "\n";                       // вывод пустой строчки, потому что почему бы и нет
  }
  
  int main() {
      node a{10}, b{20}, c{30}, d{40}, e{15};  // создание элементов и их связывание спомощью add-функций
      add_after(a, b);
      add_after(b, c);
      add_before(b, e);
      add_after(c, d);      
  
      print_list(a);  // 10 15 20 30 40
      print_list(b);  // 20 30 40
      print_list(c);  // 30 40
  
      remove(e);
  
      print_list(a);  // 10 20 30 40
  }
  ```
  >_Замечание:_ в конструкции типа `a.next->prev` мы сначала пишем точку, потому что `a` 
    был у нас не указателем, но, `a.next` - это указатель, поэтому, чтобы обратится к 
    его полям надо использовать стрелочку.
* ## Нулевой указатель
  Иногда хочется пометить, что указатель никуда не указывает. Это можно сделать с 
  помощью присвоения `nullptr` указателю. Такой указатель называется нулевым.
  > Разыменование нулевого указателя - это UB.
  
  Пример: 
  ```c++
  int main() {
    int *ptr = nullptr;
    if (ptr) {             // если ptr - это nullptr, то при конвертации к bool
                           // получим false. Иначе - true.
      // do something                  
    }
    if (ptr != nullptr) {  // так тоже делать никто не запрещает
      // do something
    }
    *ptr;                  // разыменование nullptr - UB
  }
  ```
  >_Замечание:_ Единственный случай, когда указатель при конвертации к `bool`
    вернет `false` - это случай, когда указатель нулевой.  
  
  До `C++11` стандартным нулевым указателем был макросовая константа `NULL`, которая определен нулем. 
  Ее лучше не использовать из-за вот таких приколов:
  ```c++
  #include <cstddef>
  #include <iostream>
   
  void foo(int*) {
    std::cout << "foo(int*);\n";
  }
   
  void foo(long) {
    std::cout << "foo(long);\n";
  }
   
  int main() {
    foo(nullptr);        // calls foo(int*)
    foo(NULL);           // compilation error (call is ambigous)
    foo(0);              // compilation error (call is ambigous)  
  }
  ```
  >_Замечание1:_ `NULL` и `0` могут быть сконвертированы и в `int`, и в указатель,
    а `nullptr` - это чисто про указатели.
  
  >_Замечание2:_ На cppreference [написано](https://en.cppreference.com/book/pointers#:~:text=Special%20null%20pointer),
    что `foo(NULL)` будет вызывать `foo(long)`, но у меня под всеми компиляторами и всеми разумными стандартами была ошибка компиляции.
  
  > _Замечаание3 (от ХБ):_ лично у меня при компиляции руками `g++ -std=c++17/03/11` g++ выкидывал предупреждение, что `NULL` кастуется к лонгу, при этом `clang++` вообще ничего не выкидывал. 
  
  Тем не менее, когда вы пишете `foo(NULL)`, вы ожидаете, что вызовется перегрузка `foo(int*)`, чего не происходит.
* ## Отличие ссылок от указателей
  * ### Изменяемость
    
    >Ссылка после создания всегда указывает на один элемент, в то время как указатель 
    можно перепривязывать.
    
    Пример:
    ```c++
    #include <iostream>
    
    int main() {
      int x = 10;
      int y = 20;
      int *ptr = &x;                             // указатель на x
      int &x_ref = x;                            // ссылка на x 
      std::cout << ptr << " " << &x_ref << "\n"; // указывают на одну и ту же память
      ptr = &y;                                  // перепривязали указатель к y
      x_ref = y;                                 // это уже присвоение y в x_ref, т.е. в x
      std::cout << ptr << " " << &x_ref << "\n"; // у ptr адрес поменялся на адрес y, а у x_ref остался тем же
    }
    ```
  * ### Обнуляемость
    
    >Указатели имеют нулевое состояние `nullptr`, в то время как ссылки таким не обладают. 
    Т.е. ссылка всегда должна указывать на объект, а указатель - нет.
    
    Пример:
    ```c++
    #include <iostream>
    
    int *g_ptr;                 // просто указатель (по умолчанию nullptr)
    
    int main() {
      int *ptr = nullptr;       // просто нулевой указатель
      int &ref;                 // compilation error: ref объявлена, как ссылка, но не инициализирована  
    }
    ```
  * ### Хранение в контейнерах
    Указатели спокойно кладутся в контейнеры, а вот ссылки туда класть нельзя. 
    (можно, если использовать `std::reference_wrapper`, который превращает ссылку в 
     копируемый и присваиваемый объект, но это не просто ссылки)
    
    >Ссылки нельзя копировать и присваивать. (Вообще ссылка - это не объект, 
     а в контейнерах должны объекты лежать)
  
    Пример:
    ```c++
    #include <vector>
    
    int main() {
      std::vector<int*> v_ptr(10);       // создается вектор из 10 нулевых указателей
      std::vector<int&> v_ref(10);       // compilation error: с длинной ошибкой
    }
    ```
    
    Пример с `std::reference_wrapper`:
    
* ## Арифметика указателей
  * ### `array-to-pointer decay`
    Ссылка на массив - это ссылка на его первый элемент. Значит можно сделать вот так:
    
    Пример:
    ```c++
    #include <cassert>
    #include <cstddef>
  
    int main() {
      int data[]{10, 20, 30, 40};
      
      int *p1 = &data[0];        // берем адрес первого элемента
      assert(*p1 == 10);
  
      int *p2 = data;            // array-to-pointer decay. Только массивы, не вектора.
      assert(p2 == p1);
      assert(*p2 == 10);
      *p2 = 12;                  // можно менять
      assert(*p2 == 12);
      assert(data[0] == 12);
      *p2 = 10;
    }
    ```
    >_Замечание:_ Только для C-шных массивов (не для векторов).
    
  * ### Операции `+`, `++`, `-`, `--` указателей с `int`
    Указатели в массиве можно смещать (главное, надо остаться либо в массиве,
    в котором мы находились, либо в следующей ячейке после конца массива). Отдельные объекты
    трактуются, как массивы из одного элемента, то есть можно получать указатель следующий за последним.
    
    `+`, `++` - смещение вперед.
    
    `-`, `--` - смещение назад.
  
    >Работает ровно как у итераторов.
    
    > Происходит UB при выходе за границы массива (кроме элемента следующего за последним, но про это следующий пункт).
      Причем UB даже без разыменования указателя, то есть UB - сам факт его существования.

    Пример:
    ```c++
    #include <cassert>
    #include <cstddef>
  
    int main() {
      int data[]{10, 20, 30, 40};
      
      int *p1 = &data[0];               // взяли указатель на первый элемент
      int *p2 = data;                   // array-to-pointer decay
  
      // Арифметика такая же, как и у итераторов.
    
      int *q = p1 + 2;                  // указатель на data[2]
      assert(q == &data[2]);
      assert(data + 2 == &data[2]);
      assert(*q == 30);
      
      int *ub1 = data - 1;              // UB: вышли за границу массива
      int *ub2 = data - 1 + 1;          // UB: в промежуточных вычислениях у нас произошло UB (посчитали data - 1)
      int *ub3 = data + 5;              // UB: вышли слишком далеко 
      int *not_ub = data + 4;           // НЕ UB: - one-past-the-last (про него в следующем пункте)
      
    
      int *r = q;                       // указатель на q, то есть на data[2]
      r--;                              // теперь это указатель на data[1]
      assert(r == &data[1]);
      assert(*r == 20);
  
      int x = *r--;                   
      
      // Эквивалентно вот этой штуке:
      // int *old_r = r;
      // r--;
      // int x = *old_r;
      
      assert(x == 20);
      assert(data[1] == 20);
      assert(data[0] == 10);
      assert(r == &data[0]);
      assert(*r == 10);
  
      // То же самое, только с префиксным оператором
    
      r = &data[1];
      int y = *--r;
      assert(y == data[0]);
      assert(y == 10);
      assert(r == &data[0]);
  
      std::ptrdiff_t diff = r - q;      // std::ptrdiff_t - тип, в который влазит вся память на компе
      assert(diff == -2);
      assert(&data[0] - &data[2] == -2);
  
      assert(data[1] == *(data + 1));  // По определению, синтаксический сахар для массивов (not vectors).
      assert(data[1] == *(1 + data));
      assert(1[data] == *(1 + data));
      int *data_ptr = data;
      assert(data_ptr[1] == *(data_ptr + 1));
      assert(data_ptr[1] == data[1]);
    }
    ```
    >_Замечание:_ `data[1]` - это на самом деле `*(data + 1)`.
  * ### `one-past-the-last`
    > Указатель на память, следующую за последним элементом массива - корректный, но его нельзя разыменовывать.
    
    Пример:
    ```c++
    #include <cassert>
    #include <cstddef>
    #include <iostream>
  
    struct Foo {
      int x = 0;
      int y = 1;
    };
    
    int main() {
      int data[]{40, 20, 10, 30};
  
      int *one_past_end = data + 4;
      assert(one_past_end - data == 4);
      // int var = *one_past_end;                     // разыменование - UB.
        
      Foo a;
      int *val = &a.x;
      val++;                                          // корректно (ope-past-the-last)
      // *val;                                        // разыменование - UB
    }
    ```
  * ### Сравнение указателей
    >`=`,`!=` - можно сравнивать любый указатели. Возвращает, равен ли один другому.
    
    > `>`,`>=`,`<`,`<=` - можно сравнивать указатели из одного массива или из одной структурки. 
      В случае сравнения разных объектов - `unspecified behaviour`.
    
    > `-`: Вычитать два указателя можно только из одного массива
  
    >В контейнерах используется `std::less`, который на всех указателях строит _какой-то_ полный порядок,
      поэтому можно пихать указатели, например, в `std::set`.
    
    Пример:
    ```c++
    #include <cassert>
    #include <functional>
    #include <iostream>
    #include <set>
  
    struct Foo {
      int a = 10;
      int b = 20;
      int c = 30;
    };
  
    int main() {
      {
          int data[4];
          int end;
          std::cout << (&end - data) << "\n";  // UB
          std::cout << (data < &end) << "\n";  // unspecified, может быть неконсистентным!
          std::cout << (data > &end) << "\n";  // unspecified, может быть неконсистентным!
          assert(data != &end);  // ok
      }
      {
        Foo f;
        std::cout << &f.b - &f.a << "\n";  // UB: не массив
        assert(&f.a < &f.b);  // ok: члены с одним уровнем доступа (private/protected/public) упорядочены
        assert(&f.a != &f.b);  // ok: разные int
      }
      {
        std::set<int*> s;
        int a = 10, b = 20;
        s.insert(&a);  // ok
        s.insert(&b);  // ok
  
        std::less<int*> comparator;
        std::cout << comparator(&a, &b) << "\n";  // implementation-defined
      }
    }
    ```

* ## C-style-strings/ASCIIZ-строки/строки в стиле Си
  * ### Определение
    `C-style-strings` - это не тип, а конвенция. 
     > "Если у нас есть массив, где сначала идут символы, символы, символы, а потом символ `\0`,
        то это сишная строка", — Егор Суворов.
  * ### Сохранение строкового литерала в `char *`
    С помощью `array-to-pointer decay` можно сконвертировать массив (сишную строку) в указатель.
    
    Пример:
    ```c++
    int main() {
      char str[] = "hello";                              // сишная строка
      // char str[] = {'h', 'e', 'l', 'l', 'o', 0};      // то же самое
      
      char *str_ptr = str;                               // array-to-pointer decay
    }
    ```
  * ### Сравнение и получение длины
      
    >_Опасно:_ если есть две си-шные строки `s` и `t`, то если написать `s < t`, то будут сравниваться указатели, 
      что приведет к `unspecified behaviour`. 
      
    >_Опасно:_ казалось бы на равенство указатели сравниваются без `unspecified behaviour`,
      почему бы тогда не сравнить `s == t`. Нельзя так как не гарантируется, что у 
      одинаковых строковых литералов один и тот же адрес. Ну и вообще разные строковые
      литералы могут обозначать одну и ту же сишную строку (например `"hello"` и `"hello\0"`). 
      То есть придется тоже цикликом.
      
    Но если написать `*s < *t`, то сравнятся лишь первые символы, а значит придется писать цикл `:(`.
      
    Сравнение на меньше (остальные аналогично):
    ```c++
    bool is_less(char* a, char* b) {
      for (int i = 0; a[i] || b[i]; i++) {           // (a[i] || b[i]) - нулевой символ кастуется к false, остальные - к true
        if (a[i] != b[i]) {
          return a[i] < b[i];
        }
      }
      return false;
    }
    ```
      
    Получить длину сишной строки можно так:
    ```c++
    int get_length(char* s) {
      int res = 0;
      while (s[res] != '\0') {    // идем до последнего символа, ответ - сколько элементов прошли
        res++;
      }
      return res;
    }
    ```
      
    >_Опасно:_ длина сишной строки считается за линию. Даже `std::strlen()`.
      
  * ### Выделение памяти, аллокация, конкатенация
      
    Мы хотим сконкатенировать две сишные строки. Беда в том, что сишные строки - 
    это не отдельные объекты, это указатели.
      
    То есть если мы хотим сконкатенировать две строки и получить новую, то нам надо 
    где-то выделить под нее память.
      
    Функция для конкатенации: 
    ```c++
    char* strcat(cosnt char* a, const char* b) {
      char* res = new char[std::strlen(a) + std::strlen(b) + 1]; // +1 для '\0'.
      int res_len = 0;
      for (int i = 0; a[i]; i++) {
        res[res_len++] = a[i];
      }
      for (int i = 0; b[i]; i++) {
        res[res_len++] = b[i];
      }
      res[res_len] = '\0';
      return res;
    }
    ```
      
    >_Опасно:_ теперь про каждую сишную строчку мы обязаны помнить, как мы ее получили.
      В зависимости от способа получения вызывать или не вызывать нужный `delete`.
      
    Пример (реализацию `strcat` возьмем из прошлого примера):
    ```c++
    #include <cstring>
    #include <iostream>
    #include "прошлый_пример.h"
      
    int main() {
      char* x = "xyz";
      char* y = strcat("xy", "z") + 1;
      
      // миллион строк кода
      
      delete[] (y - 1); // тут надо не забыть, что мы выделили именно массив и y взят со съездом на 1
      
      // еще надо не забыть, что вызывать delete от x не надо, потому что
      // у x automatic storage duration
    }
    ```
    
  * ### Небезопасность функции чтения

    Рассмотрим реализацию `readWord` из известного среди всей прогрессивной общественности 
    файлика `optimization.h`.
  
    Напоминание реализации readWord:
    ```c++
    void readWord(char *s) {
      int c = readChar();         // readChar просто смотрит на текущий символ из буфера
      while (c > 32)
        *s++ = c, c = getChar();  // c++ выпендреж от Cерёжи. Просто считали очередной символ.
      return с != -1;             // видимо, возвращает, считалось ли что-то?
    }
    ```
    
    >_Опасно:_ что произойдет, если мы считаем больше символов, чем выделено в `s`? 
      UB конечно же.
  
  * ### Кто владеет результатом `c_str`
    
    Что вообще такое `c_str`? Это метод у `std::string`, который возвращает сишную строчки.
    
    >_Собственно ответ:_ результатом `c_str` владеет `std::string`, который его вызвал.
    
    Пример:
    ```c++
    #include <iostream>
    #include <string>
    
    int main() {
      const char *s_ptr;
      {
        std::string s = "hello";
        s_ptr = s.c_str();
        std::cout << s_ptr << " (1)\n";    // корректно вывели сишную строчку
      }                                    // конец зоны видимости s (тут она умирает)
      std::cout << s_ptr << " (2)\n";      // UB: строчка, владеющая той памятью уже не существует
    }
    ```
 
