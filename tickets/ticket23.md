## Билет 23. Друзья и перегрузка операторов
Друзья - это те, кто имеют доступ к приватным полям, не являясь членами класса.
**ВАЖНО**: дружба не наследуется(если базовый класс друг, то дочерний не является по умолчанию другом); дружба не транзитивна(друг моего друга не является моим другом)
- ### Друзья-классы
Внутри нашей структуры говорим, что у нас есть структура-друг(друг получает доступ ко всем приватным полям).
```c++
struct Foo {
private:
	int x = 0;
	friend struct Bar; // Подразумевает, что Bar лежит в этом же namespace
};
struct Bar {
	void foo(Foo &f) {
		f.x++;
	}
	static void sfoo(Foo &f) {
		f.x++;
	}
};
int main() {
Foo f;
// f.x++; //Обращение к приватному полю, выдаст ошибку
Bar b;
b.foo(f); //Изменяет приватное поле Foo, ошибки нет
b.sfoo(f); //Изменяет приватное поле Foo, ошибки нет
Bar::sfoo(f); //Изменяет приватное поле Foo, ошибки нет
}
```
Отмечу, что если реализовать Bar сразу в Foo тогда не нудно слово friend, так как тогда Bar станет так называемым вложенным классом(nested class), а они автоматически считаются друзьями. Пример использования в реальной жизни вложенных классов: итераторы(хеш-таблица, вектор, map и т.д.).  Пример кода:
```c++
struct Foo {
private:
	int field = 10;
	struct NestedClass { // E.g.: hash_table::iterator
		void foo(Foo *b) {
			b->field++;
		}
// Если мы хотим запретить создавать такие объекты вне Foo, говорим, что
// конструктор по умолчанию приватный, а чтобы метод get_nc работал, 
// говорим, что Foo друг(чтобы можно было вызвать конструктор по умолчанию)

/*  private: 
 		NestedClass() {}
 		friend struct Foo;
*/
};
public:
	using get_result = NestedClass; //Публичный псевдоним, чтобы можно было не использовать auto для определения типа
	NestedClass get_nc() {
		NestedClass obj;
		return obj;
	}
};
int main() {
Foo f;
// Foo::NestedClass nc1 = f.get_nc(); // Нельзя, так как NestedClass - приватное имя
auto nc2 = f.get_nc(); // с C++11 можно так
nc2.foo(&f);
Foo::get_result nc3 = f.get_nc();
nc3.foo(&f);
[[maybe_unused]] Foo::get_result nc4;
[[maybe_unused]] decltype(f.get_nc()) nc5; // C++11 (аналог auto, разница будет изучаться в 4 модуле, однако из базового: decltype сохраняет ссылку, если объект ей является, а auto отбрасывает)
}
```
- ### Друзья-функции
Друзья, как уже было отмечено, не являются членами класса. Если у некоторого класса есть функция-друг, то внутри класса нужно обязательно указать, что она друг:
```c++
struct Foo {
	...
	friend void friend_func();
}
```
Определение этой функции может быть как внутри класса:
```c++
struct Foo {
	...
	friend void friend_func() {
		return;
	}
}
```
Так и вне класса:
```c++
struct Foo {
	...
	friend void friend_func();
}
void friend_func() {
	return;
}
```
Ключевая разница заключается в видимости этих друзей. Пример:
```c++
#include <memory>  
// https://www.justsoftwaresolutions.co.uk/cplusplus/hidden-friends.html  
namespace ns {  
struct Foo {  
private:  
    int field = 10;  

	// private/protected/public никак не влияют на друзей, так как они не члены класса
	friend void doit1(Foo *f); // объявили, что функция - наш друг  
	friend void doit2a(Foo *f) { // объявили и определили друга(это скрытый друг)  
		f->field++;  
	}  

    friend void doit2b(Foo *f) { // объявили и определили друга(это НЕ скрытый друг)  
		f->field++;  
	}  

    friend void doit3() { // Объявили и определили друга(его вообще нельзя вызвать ни изнутри класса, ни из вне)  
	// doit3();  
	}  
};  

void doit([[maybe_unused]] Foo *f) {  
    // f->field++;  
}  

void doit1(Foo *f) {  
    f->field++;  
}  

void doit2b(Foo *f);  
} // namespace ns  
int main() {  
    ns::Foo f;  
    //ADL(argument dependent lookup) - если не указан namespace в котором лежит функция, смотрим на аргументы, на их namespace и в нем ищем нужную функцию
    doit(&f); // ADL, сработает
    doit1(&f); // ADL, сработает  
    doit2a(&f); // ADL, сработает
    doit2b(&f); // ADL, сработает  
    ns::doit(&f); // полный вызов, так как указали конкретный namespace, где должжна лежать функция, сработает, так как определение void doit есть внутри namespace ns  
    ns::doit1(&f); // абсолютно аналогично  
    // ns::doit2a(&f); // полный вызов, но внтури namespace ns, нет функции 'ns::doit2a', значит такой вызов не сработает(отсюда и название, друг является скрытым, так как его нельзя вызвать через полный вызов, только через ADL)    
    ns::doit2b(&f); // сработает, так как в namespace ns есть объфвление: "void doit2b(Foo *f);"

	// Что касается doit3: это скрытый друг, так как объявление и определение только внутри структуры, а не namespace, значит его можно вызвать только через ADL, но у него нет аргументов, а значит ни на что ADL посмотреть не может, значит вызвать нельзя.
}
```
Объявление друга до класса, внутри класса - нет разницы.
- ### Друг из другого namespace
  Вернемся к friend struct. Если же мы хотим, чтобы у нас был друг не из нашего namespace, а из другого, то:
```c++
namespace ns2 {
	struct Bar;
}
namespace ns1{
struct Foo {
private:
	friend /*struct*/ ns2::Bar; // слово struct необязательно, потому что компилятор и так зенает, что это структура
};
}
namespace ns2 {
struct Bar {
	...
};
}
```
Функции из других namespace тоже могут быть друзьями(в частности из std):
```c++
struct Foo {
private:
    Foo() {}

    friend std::unique_ptr<Foo> std::make_unique<Foo>(); // Без этой строчки нельзя сделать unique_ptr<Foo>, так как конструктор по умолчанию приватен
};
```
Теперь `Foo` можно сделать только при помощи `unique_ptr`.  Однако, проблема в том, что мы сделали только make_unique другом. Если он не сам вызывает конструктор, а кому-то делегирует это, то все сломается, так как этот кто-то другом не является.  Поэтому лучше так не делать. Лучше делать публичную функцию вместо дружбы с make_unique:
```c++
struct Foo {
	static std::unique_ptr<Foo> make() {
	    // return std::make_unique<Foo>();  // не сработает, так как мы больше не друзья, а конструктор все еще приватный
	    return std::unique_ptr<Foo>(new Foo());  // сработает
	}
private:
    Foo() {}
};
```
- ### Перегрузка операторов
#### Унарные операторы
Операторы, которые работают с одним операндом(оператор унарного минуса или плюса(к примеру, знак у числа), ++, --), бинарные - с двумя(операторы сравнения, арифметические действия, логические операторы).
#### Постфиксные и префиксные операторы(a++ и ++a)
Казалось бы, один и тот же оператор, как тогда перегружать? Решение: постфиксный оператор принимает один параметр типа int(по стандарту гарантируется, что это 0, однако, никто не мешает сделать a.operator++(1234)). Код:
```c++
struct X
{
    // prefix increment
    X& operator++()
    {
        // сделали то, что хотели с this
        return *this; // возвращаем значение по ссылке
    }
 
    // postfix increment
    X operator++(int)
    {
	    X old = *this;
	    this++;
        // сделали то, что хотели с this
        return old; // возвращаем по значению, так как this изменился, а поскольку оператор постфиксный, нам не нужно учитывать это изменение
    }
}
```
#### operator()
Позволяет вызывать объекты нашего класса как функции. Пример:
```c++
#include <algorithm>
#include <cassert>
#include <functional>
#include <iostream>
#include <vector>
struct Greater { // Функтор
	bool operator()(int a, int b) const {
		return a > b;
	}
	int operator()(int a, int b, int c) const { // overloads are possible
		return a + b + c;
	}
};
int main() {
	std::vector<int> v{1, 2, 3, 4, 5, 6, 7, 8};
	const Grater g; // 'const' is optional, just to demonstrate const-qualifier
	assert(g.operator()(5, 4));
	assert(!g.operator()(4, 5));
	assert(g(5, 4));
	assert(!g(4, 5));
	assert(Greater().operator()(4, 5));
	assert(Greater()(4, 5));
	sort(v.begin(), v.end(), g /* Greater() */);
	for (int x : v) {
	std::cout << x << "\n";
	}
}
```
Для функторов еще есть следующее:
```c++
Greater c;
std::reference_wrapper<Greater> cwrap = c; // копируемая ссылка на с
```
Эта штука позволяет вызывать только оператор круглые скобки, удобно тем, что это ссылка, а не большой объект. Второе назначение: если мы передаем функтор, который меняется при вызове операторы круглые скобки в функцию, которая вызывает наш функтор(например, sort или for_each), тогда нам может быть интересно финальное состояние функтора. Для этого передаем ссылку, а не просто по значению.
#### operator&&, operator|| и operator,
Если эти операторы не перегружены, то гарантируется, что выражения будут выполняться по порядку(порядок - тот, в котором выражения написаны). Если же их перегрузить, то автоматически отключаются все гарантии на порядок выполнения, за этим нужно отдельно внимательно следить.
#### Минимизация лишних копирований и кода
Принято реализовывать операторы +, -, *, / через +=, -=, *=, /=, так как  в этом случае мы минимизируем количество копирований(рассмотрим на примере + и +=): += принимает две ссылки и меняет первую(0 копирований), а + принимает первый параметр по значению, второй по ссылке, к первому добавляет(через += ) второй и возвращает первый(1 копирование). Если же делать наоборот, то придется при вызове += сделать копирование, так как оператор + вернет значение. А могло быть 0 сравнений.
Для операторов сравнения принято реализовывать оператор меньше, так как через него можно выразить все остальное и при этом обычно в stl принимают оператор меньше(в sort, set) :
```c++
bool operator< (const X& lhs, const X& rhs){ /* do actual comparison */ }
bool operator> (const X& lhs, const X& rhs){ return rhs < lhs; }
bool operator<=(const X& lhs, const X& rhs){ return !(lhs > rhs); }
bool operator>=(const X& lhs, const X& rhs){ return !(lhs < rhs); }
bool operator==(const X& lhs, const X& rhs){ return (lhs <= rhs) && (lhs >= rhs); }
bool operator!=(const X& lhs, const X& rhs){ return !(lhs == rhs); }
```
#### Конвенция для типов параметров, типа возвращаемого значения
Операторы составного присваивания принимает константную ссылку(потому что меняем this, а значение того, что мы добавляем обычно не меняется, а копировать бессмысленно), а возвращает ссылку, так как мы хотим поддерживать конструкции вида a += b += c. Для арифметических действий наоборот принимать один аргумент по значению, а второй по константной ссылке(так как он не меняется, а первый элемент должен быть по значению, так как его менять не надо), а возвращают такие операторы по значению, чтобы работали конструкции вида a + b + c. Операторы сравнения возвращают bool(результат сравнения), а принимают две константные ссылки, так как при сравнении значения обычно не меняются, лишний раз копировать нет смысла.
#### Делать оператор свободной функцией или членом, последствия для преобразований (conversions)
Обычно операторы сравнения делают свободными, чтобы могли работать неявные преобразования. Если сделать его членом класса, тогда неявное преобразование будет выполняться только для правого аргумента, а если свободной функцией - то сразу для двух аргументов. Из этой же логики обычно +, -, *, / обычно делаются свободными, а составные присваивания наоборот. Является ли оператор другом - определять надо из логики, что мы хотим минимизировать количество функций имеющих доступ к приватным полям.
-   ### Отличия  a + b,  a.operator+(b),  a.operator+()
    a.operator+(b) - вызов оператора +, реализованного для объектов того же типа, что и a, то есть если неявное преобразование и произойдет, то только у b.
    a + b - вызов оператора +, который может быть реализован через свободную функцию, то есть неявное приведение можнт сработать как для a, так и для b.
    Пример, когда это существенно:
```c++
#include <iostream>

struct bigint {
    bigint(int) {}
    friend bigint operator+(const bigint&, const bigint&) {return 1;}
};

int main() {
    int lhs = 3;
    bigint a = lhs + bigint(3);  // ok, так как есть функция, которая может преобразовать int в bigint, и тогда вызовется наша перегрузка оператора
    bigint b = lhs.operator+(bigint(3));  // CE, так как у int нет оператора сложения с bigint
}
```
    a.operator+() - вызов унарного плюса(это другой оператор). Пример его использования:
```c++
char c = '0';
+c // имеет тип int(оператор унарного плюса для целочисленных типов преобразует к типу большего размера)
```
- ### Проблемы с самоприсваиванием и самомодификацией
  Пусть у нас есть класс Ratio - рациональная сокращенная дробь. Предположим, что мы хотим выполнить следующее:
```c++
#include <iostream>

struct Ratio {
	int num, denom;
	Ratio &operator/=(const Ratio &other) {
		num *= other.denom;
		denom *= other.num;
		return *this;
	}
};

int main() {
	Ratio r{2, 3};
	r /= r;
	std::cout << r.num << " " << r.denom << std::endl;
}
```
Логично предположить, что ответ должен быть "6 6", однако ответ получается "6 18".  Дело в том, что мы принимаем ссылку. Она константная, это значит, что через нее значение не поменять, однако значение, на которое она указывает может меняться. И поскольку эта ссылка указывает на this, мы получаем, что к моменту выполнения строчки `denom *= other.num;` числитель успевает поменяться на 6 и из-за этого denom считается некорректно. Как исправить: принимать по значению либо заифать случай, когда other и this одно и то же(в данном случае возвращать дробь 1/1).