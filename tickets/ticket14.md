## Билет 14. Функции
* ## Параметры
  * ### Синтаксис (пропущенное имя, значение по умолчанию в объявлении/определении)  
  У функции есть объявление и определение, хотя обычно они пишутся сразу вместе. У функции есть тип, название, в круглых скобках передаются параметры, в фигурных само тело функции.  
  ```C++
  void foo(int a, int b){}
  void foo(vector v = {1, 2, 3}){} // параметр по умолчанию
  ```
  Вот так будет выглядеть, если хотим разделить объявление и определение.  
  ```C++
  void foo(int a, int b);
  void foo(int a, int b){
     return a + b;
  }
  ```
  Это может быть полезно, например когда мы хотим использовать две функции друг в друге. При этом одна из них будет определена всегда равньше другой, поэтому приходится придегать к `Forward decloration`. То есть мы говорим, что такая функция есть, и мы можем её вызывать, но вот её определение мы попозже напишем.
  ```C++
  int bar(int x);
  int foo(int y){
      return bar(y - 1) + 1; // OK
  }
  int bar(int x){
      if(x <= 0) return 1;
      return foo(x - 1);
  }
  ```
  Ещё один случай, когда у нас есть несколько единиц трансяции. В этом случае там так же иногда приходится использовать функцию в единице трансляции отличной от той, где мы собственно эту функцию определяем. Поэтому приходится в каждой отдельной единице трасляции писать объявление, если мы хотим использовать функию.  
  Можно в качестве параметра использовать агрумент без имени, указав только его тип. Это, например, используется, чтобы различять префиксный и постфиксный декриметны и инкременты. Обратиться к переданному таким образом аргументу внутри функции не получится. При этом распалагать их можно в перемешку с обычными аргументами, но до агрументов со значениями по умолчанию.  
  ```C++
  void foo1(int a, int, int b, int, int, int c = 100){} // OK
  void foo2(int a, int, int b, int, int, int c = 100, int){} // Compilation error
  void foo3(int a, int, int b, int, int, int c = 100, int = 1){} // OK
  ```
  Аргументы со значениями по умолчанию всегда идут после всех остальных. Можно передавать им новые значения при вызове функции. Задать значение по умолчанию можно как в объявлении, так и в определении функции, но только либо там, либо там.
  ```C++
  void foo1(int c = 100);
  void foo1(int c){
    std::cout << c; // Выводит 100
  }
  ```  
    
  * ### Передача параметров по: значению, `&`, `const&`. Что выбрать и почему.  
  Аргументы в функцию можно передавать по значению, по ссылке, по константной ссылке. Если передавать по значению, то в функцию копируется переданный аргумент. Если по ссылке, то берётся ссылка на переданный агрумент (то есть если теперь его поменять внутри функции, то он поменяется и в том месте, где была вызвана функция). Передача аргумента по константной ссылке не даёт нам изменять его внутри функции.  
  Передача по ссылке нужна, если мы хотим как-то модифицировать переданный аргумент в функцию.  
  Передача по константной ссылке нужна, если мы не хотим менять наш объект внутри функции. При этом, копировать его лишний раз слишком дорого (например копировать матрицу 1000 на 1000 элементов, по которой мы хотим лишь разок пробежаться, не редактируя её, тупо, потратим на это кучу лишнего времени), поэтому лучше передать его по ссылке и запретить редактирование.  
  Отдельный разговор про верменные объекты. Если передать врементый объект в функцию как параметр, то либо по значению, либо по константной ссылке. По ссылке не получится (обычно не скомпилируется, но можно это как-то обойти и получить UB). При передаче временного объекта по константной ссылке, время его жизни продлевается.  
  ```C++
  size_t foo(const std::vector<int> &a){
      return a.size(); // 3
  }
  int main() {
      std::cout << foo({1, 2, 3});
  }
  ``` 
  Из-за этой фичи легальными являются и такие конструкции, где время жизни опять же продлевается.  
  ```C++
  int main() {
      const std::vector<int> &a = std::vector<int>{1, 2, 3};
      std::cout << a.size(); // 3
  }
  ``` 
  * ### Передача `{}` в параметры.  
  Компилятор умная штука. Можно передавать что-то в фигурных скобках, он по контексту догадается, чем это должно быть. Например тут он преобразует это в вектор интов. Это так называемое `List-initialization`. (см. соответствующий билет)
  ```C++
  void foo1(std::vector<int> arr){}
  int main() {
      foo1({1, 2, 3});
  }
  ```  
  * ### Неименованый параметр и `[[maybe_unused]]`  
  Неименованный параметр подробно описан выше. Вместо него можно использовать аргумент с каким-то фиктивным названием и пометить его `[[maybe_unused]]`  
  Приведу ещё один пример, где это используется: теги в аргументах функции. Мы заводим две фиктивные структуры с говорящими именами, делаем перегрузку функции. В одном месте передаём фиктивный параметр типа первой структуры, во второй функции фиктивный параметр второй структуры.  
  ```C++
  struct multi_five{};
  struct multi_ten{};
  int foo(int a, multi_five){
      return a * 5;
  }
  int foo(int a, multi_ten){
      return a * 10;
  }
  int main() {
      foo(1, multi_five{}); // 5
      foo(1, multi_ten{}); // 10
  }
  ```  
  
* ## Возвращаемое значение
  * ### Возврат по значению, ссылке, константной ссылке.  
  При возврате по значению, возвращаемый объект будет копироваться в переменную, куда вы его запишите.  
  При возврате по ссылке, функция возвращается ссылку на объект. Поэтому стоит быть аккуратным. В следующем примере пытаемся вернуть ссылку на локальную переменную, которая уберётся со стека после окончания выполнения функции, поэтому получаем UB.  
  ```C++
  int& foo1(int a){
      int b = a + 1;
      return b; // UB
  }
  int main() {
      int c = foo1(4);
      std:: cout << c;
  }
  ```  
  Применять возращение значения по ссылке можно например, если нам в параметрах передали какой-то аргумент по ссылке. То есть после окончания функции, он не будет уничтожен, поэтому позвращать на него ссылку совершенно легально.  
  ```C++
  int& foo1(int &a){
      a++;
      return a; // OK
  }
  int main() {
      int c = 5;
      int &b = foo1(c); // 6
      b++; // 7
      std::cout << c; // 7
  }
  ```
  Или например, можно возвращать ссылку на статический объект, объявленный внутри функции.
  ```C++
  int& foo1(){
      static int a = 100;
      a++;
      return a; // OK
  }
  int main() {
      int &c = foo1();
      std::cout << c << "\n"; // 101
      foo1();
      std::cout << c << "\n"; // 102
  }
  ```  
  Ну и можно возвращать константные ссылки. Всё работает интуитивно.  
  ```C++
  const int& foo1(int &a){
      a++;
      return a; // OK
  }
  int main() {
      int c = 5;
      const int &b = foo1(c); // 6
      b++; // Compilation error
  }
  ```
  * ### Возврат `{}`.  
  Возвращение из функции `{}` возможно только если возвращать что-то по значению (ну очевидно, не понятно что бы означало вернуть ссылку на пустые скобки. Это просто не скомпилится). В этом случае, вызововется Default initialization у элемента возвращаемого типа. То есть если функция от инта, то вернётся 0.  
   ```C++
  int foo1(){
      return {};
  }
  int main() {
      std::cout << foo1(); // 0
  }
  ```
  * ### `[[nodiscard]]`, возможные стратегии применения: когда не имеет смысла игнорировать возвращаемое значение, когда игнорировать опасно  
  Например, опасно игнорировать возвращаемый объект какой-то структуры. Если мы использовали внутри функции Dynamic storage duration, и возвращаем какой-то объект, в предположении что его после нужно пудет удалить. Если же мы его никуда не сохраним, произойдёт утечка памяти. Имеет смысл запрещать игнорировать возвращаемое значение, например если мы переопределяем какой-то арифметический оператор, как `+` в `bigint`. (Речь идёт о `C-style pointer`, с `unique_ptr` всё нормально будет, он почистится).  
  Так же если функция ничего не меняет вне себя, то ситуация, когда мы никуда не сохранили её значение означает, что мы попросту впустую потратили время на её выполнение, и это не дело.  
  Или если функция связана с обработкой ошибки, то идейно мы обязаны как-то исползользовать возвращаемое ей значение.  
* ## Перегрузка функций:
  * ### Что входит в сигнатуру, что не входит (например, значение по умолчанию).  
  Сигнатура функции включает имя функции, а также количество, порядок и тип ее формальных параметров.  
  Две перегруженные функции не должны иметь одинаковую сигнатуру.  
  Возвращаемое значение не является частью сигнатуры функции.  
  Две эти функции имеют одинаковую сигнатуру:  
  ```C++
  int Divide (int n, int m) ; 
  double Divide (int n, int m) ;
  ```
  * Типы-тэги для пояснений к перегрузкам (04-210923/01-functions/04-tags)
  Пояснил за тэги в пункте про безымянные и `[[maybe_unused]]`аргументы.  
  * ### Синтаксис `= delete` с C++11.  
  Если мы хотим запретить, например копирующий конструктор, можем воспользоваться конструкцией = delete: чтобы пометить их как удаленные функции.  
  ```C++
  unique_ptr(const unique_ptr&) = delete;
  unique_ptr& operator=(const unique_ptr&) = delete;
  ```
  Отличие удаления этих функций от их объявления как private.Удаленные функции не могут использоваться никоим образом, так что даже код функциичлена или функций, объявленных как friend, не будет компилироваться, если попытается.  
  Так же можно запрещать перегружать метод:  
  ```C++
  void foo(int x) {
      std::cout << "foo(" << x << ")\n";
  }

  void foo(double) = delete;  // Last step: if chosen by overload resolution, fail compilation.
  ```
  * ### Проблемы с разделением `nullptr`, `NULL`, `0`.  
  nullptr: это отдельный тип, а вот 0/NULL — это инты. Поэтому с перегрузками беда. Различие между NULL и 0 чаще всего практически никакого - (идеологически NULL показывает, что там пусто.  
  `#define NULL 0` //чаще все это именно так и есть  
  `nullptr` - значит что ни на что не указывает - необходимо использовать для указателей
  ```C++
  int *a=nullptr;
  *a; //UB!!!
  ```
  После 11 плюсов с взаимнозаменяемостью этих трёх штук полная лажа, так что `NULL` не стоит использовать вообще никогда.
  * ### Не было: `noexcept`.
  * ### Не было: правил выбора перегрузки точнее "выбирается перегрузка наиболее точная или ambiguous".
* ## Указатели на функции: синтаксис, использование.
Стыбжено у 2 курса  
[большая статья про указатели на функции](https://ravesli.com/urok-104-ukazateli-na-funktsii/#toc-0)  

```C++
// fcnPtr - это указатель на функцию, которая не принимает никаких аргументов и возвращает целочисленное значение
int (*fcnPtr)();
```
В примере, приведенном выше, fcnPtr — это указатель на функцию, которая не имеет параметров и возвращает целочисленное значение. fcnPtr может указывать на любую другую функцию, соответствующую этому типу.

Скобки вокруг *fcnPtr необходимы для соблюдения приоритета операций, в противном случае int *fcnPtr() будет интерпретироваться как предварительное объявление функции fcnPtr, которая не имеет параметров и возвращает указатель на целочисленное значение. Собственно синтаксис `*` интуитивно понятен, хотим получить `указатель` на функцию.  

Указатель на функцию может быть инициализирован функцией (и неконстантному указателю на функцию тоже можно присвоить функцию):  

```C++
int boo()
{
    return 7;
}
 
int doo()
{
    return 8;
}
 
int main()
{
    int (*fcnPtr)() = boo; // fcnPtr указывает на функцию boo()
    fcnPtr = doo; // fcnPtr теперь указывает на функцию doo()
 
    return 0
```

Можно передавать свой компаратор в сортировочку. Или в тестирующей системе tic-tac-toe извращаться(прикольно). Или в другую функцию передавать, чтобы в каком-то конкретном случае она делала именно то, что вы хотите(некоторое обобщение передачи в сортировочку).  
Далее примерчики  
```C++
#include <iostream>

void apply(void (*operation)(int)) { // cdecl.org
    std::cout << "calling with 10\n";
    operation(10);
}

using ApplyArgument = void(*)(int);
void apply2(ApplyArgument operation) { // cdecl.org
    std::cout << "calling with 10 twice\n";
    operation(10);
}
void print(int x) {
    std::cout << x << "\n";
}

void print_twice(int x) {
    std::cout << x << ", " << x << "\n";
}

int main() {
    apply(print);
    apply(print_twice);
    apply2(print);
    apply2(print_twice);
}
```

```C++
#include "iostream"
void lol(int a) {
    std::cout << "функция вызвана с параметром " << a << '\n';
}
void kek(void(*lol)(int), int a, int b) {
    for (int i = 0; i < a; i++) lol(b);
}

int main() {
    kek(lol, 2, 4);
    void(*pek)(int) = lol; //создали указатель pek на функцию lol
//(просто показываю, что так можно)
    return 0;
}
```

В функцию kek передали указатель на функцию возвращающую void и принимающую один параметр int. Так же можно создать константный указатель на функцию void(* const lol)(int).  
Так же уместен такой синтаксис:  
```C++
#include "iostream"
void lol(int a) {
    std::cout << "функция вызвана с параметром " << a << '\n';
}
using func = void(*)(int);
void kek(func lol, int a, int b) {
    for (int i = 0; i < a; i++) lol(b);
}

int main() {
    kek(lol, 2, 4);
    func pek = lol; //создали указатель pek на функцию lol
//(просто показываю, что так можно)
    pek(1);
    return 0;
}
```  

  * ### Не было: конверсии между указателями, что происходит с перегрузками.

Тесно связано с: методы.
