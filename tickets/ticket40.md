## Билет 40. Базовое наследование.

### Совместимость по ссылкам и указателям

#### Устройство

В C++ совершенно бесплатно можно получить делать `basecast` (`upcast`): кастовать объект типа `Derived` (здесь и далее
считаем, что `Derived` наследуется от `Base`) к типу `Base&`, то есть получать ссылку на базу от Derived.

Причем делать это можно неявно, потому что мы считаем, что внутри памяти базовый класс лежит суперхорошо и приятно.

Заметим, что так делать можно и с указателями, все правила те же, преобразование такое неявное.

```c++
struct Base {
    int x = 10;
    void foo() const {
        std::cout << "x = " << x << std::endl;
    }
};

struct Derived : Base {
    int y = 20;
    void bar() const {
        std::cout << "x = " << x << " y = " << y << std::endl;
    }
};

int main() {
    Derived d;
    Base& b = d; // произошел basecast
    b.x++; // так можно
    b.y++; // так нельзя
    Derived* d_ptr = d;
    Base* b_ptr = d_ptr; 
    b_ptr->foo(); // OK
    b_ptr->bar(); // CE
```

#### Мотивация

Если у нас есть функция, которая должна работать на всех методах, отнаследованных от `Base`, то в целом upcast --
единственный способ сделать такое:

```c++
void foo(Base& b) {
    std:cout << "foo(" << b.x << ")" << std::endl;
}
```

Например, в STL такое используется при создании `operator>>` или `operator<<` для вывода. Подробнее: есть два как бы
базовых класса `istream` и `ostream`, от которых мы как раз делаем операторы, а потом `cin/cout` делают `upcast` к ним.

#### Усиляем! (derived-cast)

Если в `foo` мы точно знаем, что переданная нам ссылка на `Base` пришла от `Derived`, то можно вернуться к `Derived`:

```c++
void foo(Base& b) {
    std:cout << "foo(" << b.x << ")" << std::endl;
    const Derived& d = static_cast<const Derived&>(b); // you need to use static_cast
}
```

Данный прием называется derivedcast или downcast. Прием очень опасный: его можно применять только в том случае, если мы
точно на 100% безошибочно знаем, что `b` -- на самом деле `Derived`. А иначе у нас будет UB, причем UB случится сразу в
момент каста, то есть даже если дальше мы не используем поля `Derived`.

Важный момент, что мы здесь используем `static_cast`. Вот, если хоть на секунду предположить, что мы его не используем,
то могут происходить различные страшные вещи. Например:

```c++
int main() {
    string s = "LOL!";
    int &x = (int&)(s); // UB
    cout << x << '\n'; // на моем компиляторе каждый запуск генерируется случайное число
}
```

Компилятор и слова не скажет о том, что вы не правы и так делать нельзя. А вот `static_cast` запретит вам компиляцию и
скажет, что вы не правы.

### Расположение подобъектов в памяти и padding (пустое место для выравнивания).

Сейчас рассматриваем базовое наследование, если будет множественное, то там может быть несовпадение адресов, конечно же.

Заметим, что если вывести `b_ptr` и `d_ptr`, то они неожиданным образом совпадут. Это ни разу не совпадение, стандарт
гарантирует, что базовый класс всегда лежит в начале производного класса.

Следующий момент: выравнивание. Каждый тип имеет свое выравнивание --- его адрес должен делиться на какое-то хорошее
число (например, адрес `int` должен делиться на 4, а адрес `char` на 1). Это пошло из некоторых особенностей архитектуры
процессоров, так как они не могут работать с плохими адресами.

Поэтому иногда получается так, что структура имеет размер больший, чем суммарный размер всех её полей. Например:

```c++
struct Bar{ // address = x
    char c; // alignof(char) == 1, address = x
    int i; // alignof(int) == 4, address = x + 1 is bad -> address = x + 4
}; // sizeof(Bar) == 8
```

Другой интересный пример:

```c++
struct Buzz{
    char c; // address = x
    int i; // address = x + 4
    char c2; // address = x + 8
}; // sizeof(Buzz) == 12, WTF?!

struct Foo{
    int i; // address = x
    char c; // address = x + 4
    char c2; // address = x + 5
}; // sizeof(Buzz) == 8, WTF?!
```

А ответ в данном случае такой: размер структуры должен делить на её `padding` = `max align` её полей. Это важно,
например, в тот момент, когда мы кладем структуры в массив. Выравниванием, как видно, можно легко управлять при помощи
порядка полей. Компилятор не сделает это за вас, потому что что-нибудь может быть на этом завязано (например, порядок
аргументов в конструкторе). При этом все переменные одного уровня доступа лежат подряд.

### Права доступа

В этот момент надо тупо открыть и показывать `12-211201/03-access-specifiers` тут по-другому никак.

#### 10-public.cpp

Публичные имена можно вызывать и получать где угодно и когда угодно. Все просто.

Друзья (как функции, так и классы) здесь не имеют значения, так как все публичное.

#### 11-private.cpp

Усложняем! Теперь можно вызывать методы только у себя. У друзей доступ только к другу, но не к отцу/сыну друга. Но при
этом у отца/сына друга никакого доступа к нам.

При этом важный момент, что дружба не наследуется ни каким образом: сын друга не является другом.

#### 12-protected.cpp

Методы получают доступ к методам отцов (дедов, ...)/своим. Но Base&.base_method (**basecast**) нельзя вызывать, ибо по
ссылке лежит что-угодно.

Строгое правило: мы имеем доступ к методам родителей, если мы уверены, что вызываем от родителя. Поэтому ссылочные типы
или указатели отправляются домой.

```c++
void Derived::derived_method(SubDerived &sd) {
    sd.base_method(sd);
    sd.derived_method(sd);
    // sd.subderived_method(sd);

    Base::base_static(sd);
    Derived::base_static(sd);
    SubDerived::base_static(sd);
    Derived::derived_static(sd);
    SubDerived::derived_static(sd);
    // SubDerived::subderived_static(sd);

    // WARNING: can only see protected through 'Derived' or 'SubDerived', not 'Base'.
    [[maybe_unused]] Base &b = sd;
    // b.base_method(sd);

    // Reason:
    [[maybe_unused]] OtherDerived od;
    // od.base_method(sd);
    // static_cast<Base&>(od).base_method(sd);

    [[maybe_unused]] Derived &d = sd;
    d.base_method(sd);
    d.derived_method(sd);
}
```

А что друзья? Друг Derived имеет доступ к методам Derived, но не к SubDerived. А что с методами Base? А кто его знает)
Там открытый issue на гитхабе: зависит от стандарта, компилятора, фазы луны, номера лабы, ...

### Hiding

Пусть у нас есть такой набор структур:

```c++
struct Base {
    void foo() {
        std::cout << "no args\n";
    }
    void foo(int) {
        std::cout << "int\n";
    }
};
struct Derived : Base {};

struct SubDerived : Derived {
    void foo(double) {
        std::cout << "double\n";
    }
    
    // void foo(int x) { std::cout << "SubDerived int\n"; Derived::foo(x); }
    // void foo() { std::cout << "SubDerived no args\n"; Derived::foo(); }
};
```

Разберемся с `Base`: у него можно вызывать `foo()`, `foo(int)`, `foo(double)` (преобразование `double` -> `int`). Все просто, простые перегрузки.

С `Derived` все то же самое. Ничего не поменялось.

А теперь начинаются мемы. Вот мы в `SubDerived` решили добавить новую перегрузку от `double`. Но теперь нельзя
вызывать `foo()`. Произошол _Hiding_.

Теперь более формально, что произошло. Рассмотрим механизм вызова невиртуальных функций:

1. Name resolution (разрешение имени) Output: "overload set".
2. Overload resolution. Output: a single overload. Определяем перегрузку, результат: какая-то одна функция.
3. Access check. Определяем можно ли трогать.
4. Call, can be virtual or non-virtual. Вызываемся, смотря на виртуальность.

То есть в `SubDerived` перегрузка ломается на первом шаге: она видит только `foo(double)`, а в родительских классах
перестает искать. Для того чтобы вернуть перегрузки есть два способа:

1. Вернуть все руками,
2. Воспользоваться `using <BaseClass>::<functionName>`. Это сделать unhiding функции, причем ровно до следующего
   hiding'а.

А теперь разберемся что еще умеет `using`. Во-первых, он умеет изменять права доступа:

```c++
struct Base {
protected:
    void magic() {
    }  // Similarly for fields.
};

struct Derived : Base {
    using Base::magic; // теперь метод magic публичный
};

struct SubDerived : Derived {
    void magic2() {
        magic();
        Base::magic();
        Derived::magic();
    }

private:
    using Derived::magic; // а теперь снова приватный
};

 [[maybe_unused]] Base b;
// b.magic(); <- protected

 Derived d; 
 d.magic(); // <- public
 // d.Base::magic(); <- protected

 SubDerived sd;
 // sd.magic(); <- private
 // sd.Base::magic(); <- protected
 sd.Derived::magic(); // <- public
 sd.magic2();
```

Во-вторых, он умеет перегружать ВСЕ конструкторы базового класса при помощи синтаксиса `using <BaseName>::<BaseName>;`.
После этого у нас все в `Derived` будут все конструкторы из `Base` (но создавать они будут уже `Derived`), причем если
мы создать новый конструктор с совпадающей сигнатурой, то он скроет базовый конструктор.

