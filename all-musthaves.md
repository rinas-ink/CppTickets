Здесь будут все мастхевы (я надеюсь).
# Основные конструкции языка C++ и C

**Объявления переменных**

* Говорим тип, потом имя переменной - всё, переменная объявлена. Переменная может быть
  константой (`const`), указателем (`*`), ссылкой (`&`).
* Каждая переменная может быть объявлена только один раз в пределах своей области видимости (ODR -
  One Definition Rule). Пример:
```c++
int main () {
    int a;
    int a; // bad
    {
        int b;
    }
    {
        int b; // ok
    }
    for (int i = 0; false;);
    for (int i = 0; false;); // ok
}
```
* При объявлении сложных типов важен порядок, например: `long long int` (в с++ нельзя
  написать `long int long`, а в си можно)

**Выражения и операторы**

* Арифметические:
    * `+`, `-`, `*`, `/`, `%` (и аналоги с `=`) - бинарные операторы (принимают левый и правый
      операнд, возвращают результат). `/` - целочисленное деление, `%` - деление по модулю,
      возвращает остаток. `++` и `--` - инкремент/декремент, унарные операторы, которые изменяют
      значение операнда на 1 (`+= 1`/`-= 1`).
    * `%` - остаток от деления отрицательного числа на положительное - отрицательное число. Можно
      костыльно обойти: `(a % b + b) % b`.
    * `/` - чтобы получить вещественное деление, нужно, чтобы хотя бы один из операндов был
      вещественным.
* Булевы:
    * `<`, `<=`, `>`, `>=`, `==`, `!=` - бинарные операторы сравнения, возвращают `true`
      или `false`.
    * `&&`, `||`, `!` - логические операторы И, ИЛИ и НЕ. `&&`, `||` - бинарные, `!` - унарный, все
      возвращают `true` или `false`.
    * Отличие между префиксными и постфиксными `--`, `++`:
        * Интуитивно: `--a` - сначала уменьшить `a`, потом сделать что-то с ним (т.е. фактически
          используем `a - 1`). `a--` - сначала что-то сделать с `a`, потом уменьшить (т.е.
          используем `a`).
        * Формально: `--a` делает `a -= 1` и возвращает `&a`, а `a--` запоминает предыдущее
          состояние объекта, делает `a -= 1` и возвращает запомненное значение.

**Условный оператор `if`**

* `if (expression) { statement } else { statement }`. Expression в скобках должен явно/неявно
  кастится к `bool` (`if` сам это умеет делать). Если нужен только один `statement`, можно писать
  без фигурных скобок, но это некрасиво.
* `else` тоже можно писать без фигурных скобок, отсюда
  конструкция `else if ()`: `if (...) { statement } else if ()`.
* В с++17 появилась такая конструкция: `if (init-statement; condition)`, где `condition` может
  быть `expression`, которе кастится к `bool`, либо присваиванием, но это мы не проходили.

**Циклы `for`/`while`**

* `for (init-statement or null; expression; interation-expression) { statement }`. Сначала
  инициализируем переменную, по которой итерируемся (опционально), потом условие выхода (должно
  кастится к `bool`), потом выражение итерации, которое меняет переменную итерации. Каждую из этих
  частей можно оставлять пустой (`for (;;;)` - корректно). `init-statement` выполняется до входа в
  цикл, `expression` проверяется перед каждой итерацией, `iteration-expression`
  выполняется после каждой итерации.
* `while (expression) { statement }`. Аналогично `for`, но без инициализации
  и `iteration-expression`.
* Ещё можно брякаться (`break`) - завершать цикл, когда выполнение программы доходит до этой
  строчки, и переходить на следующую итерацию без выполнения последующего кода (`continue`).

# Основные конструкции С++

**Синтаксис `static_cast`**

* `static_cast <new_type> (expression)`

**Синтаксис пространств имён**

* Объявление пространства имён:

```c++
namespace name {
    // smth
} // namespace name
```

* Обращение к элементу внутри: `name::element;`
* Может работать для любой вложенности, хоть `ns1::ns2::ns3::ns4::element`

**`auto` для объявления переменных**

* `auto` **нельзя** использовать без инициализации.
* Для переменных: означает, что тип переменной будет автоматически получен из её инициализации
* Для функций: означает, что тип функции будет автоматически получен из её `return`
* Если в функции встретились два `return` с разными типами - ошибка компиляции (истинным считается
  тот, что встретился первым)

**Range-based for**

* Можно итерироваться по итерируемым объектам напрямую, не используя индексы
* `for (range-declaration : range-expression) { statement }`, где `range-declaration` - объявление
  именованной переменной, чей тип совпадает с типом объекта, по которому итерируемся,
  а `range-expression` - итерируемый объект (массив или объект с определенными `begin` и `end`).
* Чаще всего используется `auto`, например:

```c++
vector<int> vec(10, 0);
for (auto a : vec) std::cout << a; // prints 10 zeroes, type(a) - int
```

* Нередко имеет смысл использовать `auto &` (берем элементы по ссылке, без копирования, что быстрее)
  или `const auto&` (константная ссылка - берем по ссылке + не можем менять элементы)
# C (си) ((не плюсплюс))

**Использование строк в стиле
Си** [Пример](https://github.com/hse-spb-2021-cpp/lectures/blob/master/08-211020/01-c-str/01-c-str.cpp)

* `const char *str_ptr` - каноническая сишная строка, указатель на произвольный кусок в памяти, в
  котором сначала идут символы, а в конце ноль.

* `const char str[] = "hello"` - старый сишный массив, который можно трактовать как строку, если в
  нем идут символы-символы-символы, а потом ноль.

* `const char *str_ptr = str` - array-to-pointer decay, массив-сишная строка распадается на
  указатель, который тоже сишная строка.

* различия `char s[10]` и `const char *s`: "Ну, например, указатель может на любую память указывать
  и надо думать, а не надо ли её освободить. А у массива не надо" (с) Егор

* Преобразование в две стороны для `std::string`:
    * `std::string -> c_str`: с помощью метода `c_str()`. Возвращает указатель на данные, которые
      лежат в `std::string`, причём этот указатель живет только пока живет сам `std::string`.
    * `c_str -> std::string`: у `std::string` есть конструктор от сишной строки. Важно следить за
      памятью и учитывать, что если `c_str = nullptr`, то `std::string` от неё не будет пустой
      строчкой (а бросит ошибку)
      . [Source](https://stackoverflow.com/questions/4764897/converting-a-c-style-string-to-a-c-stdstring)

**Операции со строками в стиле Си**

* Конкатенация: [Пример](https://github.com/hse-spb-2021-cpp/lectures/blob/master/08-211020/01-c-str/05-allocator.cpp)
    * За `2n`: идём сначала по первой строчке, вписываем её, потом по второй строчке и вписываем её.
      Предварительно нужно зарезервировать память в размере `first.size() + second.size() + 1`, +1
      очень важен, иначе UB, которое не всегда стреляет.

* Длина строки:
    * Подсчёт ручками или с помощью `std::strlen()`, работает за линию в любом случае.
* Альтернатива `gets`: (есть у Егора в файлах с консультации)
    * Если есть функция, которая читает символы пока читается - это какая-то лажа, может быть
      опасно. [Source](https://ru.wikipedia.org/wiki/Gets#%D0%90%D0%BB%D1%8C%D1%82%D0%B5%D1%80%D0%BD%D0%B0%D1%82%D0%B8%D0%B2%D1%8B)
      ```c++
      char buf[size];
      gets(buf); // potentially unsafe: UB if try to read more that sizeof(buf)
      fgets(buf, sizeof(buf) /* size */, stdin); // ok, knows exactly how long buf is
      ```
# Классы

**Определение класса, конструктор, методы**

* Определение: сказали слово `struct` (или `class`), завели какое-то количество полей/членов (
  members)
  . [Пример](https://github.com/hse-spb-2021-cpp/lectures/blob/master/03-210916/02-struct/01-struct.cpp)
* Для классов работает объявление, в таком случае внутри объявляем функции и переменные, но потом
  определяем их через `Point::smth`.
* Конструктор создаёт объект класса и инициализирует его поля. Конструкторы можно объявлять от
  разных типов и от разного количества переменных, это всё перегрузки. Синтаксис:

```c++
struct Point {
    int x, y;
    
    Point(int x_, int y_) { // конструктор от двух интов
        x = x_;
        y = y_;
    }
};
```

* Методы (member functions, функции-члены) - это функции, определенные в классе. Они имеют доступ к
  его полям и особый синтаксис: `p.dist()` - вызвали метод `dist` у объекта `p` класса `Point` из
  примера. У методов есть неявный аргумент - объект класса, на котором мы его вызываем.
* `class` и `struct` отличаются друг от друга только уровнем защиты: все мемберы `class` - `private`
  по-умолчанию, все мемберы `struct` - `public` по-умолчанию.

**Приватные, публичные и защищенные поля/методы**

* `public:` такие поля и методы видны всем и отовсюду, для них работает обращение
  через `class_object.smth`. Проблема: кто угодно может залезть внутрь класса и, например, случайно
  попортить важный инвариант.
* `private:` видны только самому объекту класса, его методам, функциям-друзьям и
  классам-друзьям(`friend`), но не детям.
* `protected:` видны только самому классу и его наследникам (а что там с друзьями происходит, никто
  не знает (даже Егор)).
* Друзья: внутри класса объявляется функция (или класс; как обычное объявление, только начинается со
  специального слова `friend`), теперь она имеет доступ ко всем его приватным полям.

**Наследование**

* Синтаксис: `struct Derived : Base {};`. У `Derived` есть свои поля/методы и дополнительно всё то,
  что было у `Base` (по модулю уровня доступа)
  . [Пример](https://github.com/hse-spb-2021-cpp/lectures/blob/master/09-211110/01-basic.cpp)
* Конструкторы не наследуются. Если хотим для `Derived` добавить конструктор, то в нём обязаны
  сконструировать базовый класс. Синтаксис: `Derived(params) : Base(base_params), other_members {}`
  . [Пример](https://github.com/hse-spb-2021-cpp/lectures/blob/master/09-211110/05-ctors.cpp)
* Если ничего не конструировать в явном виде, в конструкторе `Derived` вызовется конструктор `Base` по-умолчанию.
* Типы
  наследования: [Пример](https://github.com/hse-spb-2021-cpp/lectures/blob/master/10-211117/02-extra/20-inheritance-visibility.cpp)
    * `public`: по-умолчанию для структур, наследнику видны все поля и методы.
    * `protected`: делает тот факт, что мы унаследовались, защищенным. Внутри наследников
      пользоваться полями и методами предков можно (если они не приватные), а снаружи - нет. Также
      снаружи нет совместимости по ссылкам: наследник не кастится к базовому классу (нормальными
      плюсовыми кастами, сишным кастом получится).
    * `private`: по-умолчанию для класса. Факт, что мы унаследовались, известен только самому
      наследнику и никому больше (даже его наследникам). Внутри можно пользоваться полями и методами
      базового класса (не приватными), снаружи - нет. Апкасты к `Base` тоже недоступны снаружи.
# Const correctness

**Синтаксис константных ссылок**

* `const type& a_ref = a` - создаёт константную ссылку на переменную `a_ref` типа `type`. `a` может
  не быть `const`, но менять его в любом случае нельзя. Убрать константность у ссылки тоже
  невозможно.

**Невозможность менять константные объекты и поля**

* Константный объект нельзя менять. Точка. Две точки.
* Константные поля у объекта можно инициализировать только через member initialization list, иначе
  получим ошибку компиляции. Менять их, конечно, тоже нельзя. Пример:

```c++
struct X {
    X (int i) : b(i) {}; // ok
    X (int i) { // bad
          b = i;
    }
    const int b;
};
```

**Const-qualifier у методов**

* Методы могут быть константными, тогда они гарантируют, что не будут изменять состояние объекта. В
  таком случае их можно вызывать на константном объекте. 
* Если `const-qualified` метод класса пытается поменять объект - ошибка компиляции (не UB).
* Пример:

```c++
struct X {
    void foo() const {}; // member-function promises NEVER to change *this
    
    void bar() {}; // member-function might change *this
};

X a;
const X& x = a; // const reference to X class
x.foo(); // OK
x.bar(); // won't compile, bar() is not const

```
# Функции

**Объявление и определение**

* `Type func(args);` - объявление/declaration. Может быть сколько угодно на программу,
  обычно используют в `*.h`.
* Если функция `foo()` была объявлена как `Type`, её нельзя объявить/определить под другим
  типом (но можно перегрузить под другим типом с другим набором аргументов).
* `inline`: исторический смысл: сказать компилятору "не вызывай эту функцию, а просто скопипасти
  код". Если функция помечена `inline` программист гарантирует, что все определения этой функции во
  всех единицах трансляции одинаковые. Если разные - UB (IFNDR).
* `Type func(args) { body }` - определение. Может быть только одно на программу (единицу
  трансляции, если помечено `static`), иначе нарушение ODR.

**Вызов функции**

* `func(args);` - вызов функции. Всегда сопровождается круглыми скобочками, в которых указываются
  аргументы (если есть).
* При вызове функции может происходить перегрузка (в зависимости от типа/аргументов), тогда
  выбирается **наиболее близкая** сигнатура.

**Возвращаемое значение**

* Каждая функция, как и переменная, должна иметь тип, только в контексте функций тип означает тип
  возвращаемого значения. Если объявили тип `type`, внутри функции обязан быть `return`, который
  возвращает объект типа `type`.
* Любая функция, кроме `void`, всегда должна что-то возвращать, иначе UB. В `void`-функциях и
  конструкторах-деструкторах в конце всегда выполняется `return;`. Если в `main()`
  отсутствует `return int;`, по-умолчанию выполняется `return 0;`.
* `void` - ничего не возвращает, внутри функции можно использовать только пустой `return;`

**Рекурсивный вызов**

* Функции могут вызывать сами себя, в этом нет ничего (почти) страшного.
* Бесконечная рекурсия упадёт с ошибкой `stackoverflow`.
* Пример рекурсии:

```c++
int fib(int a) {
    if (a <= 2) return 1;
    return fib(a - 1) + fib(a - 2);
}
```
# Использование move-семантики

**Эффективная инициализация полей класса из аргументов по
значению** [Егор](https://github.com/hse-spb-2021-cpp/lectures/blob/master/13-211208/02-move-objects/03-move-to-field.cpp)

* Принимаем в конструкторе аргумент по значению, а затем муваем его в поле. Таким образом мы
  разделяем процесс: аргумент разрешаем инициализировать как угодно (самым быстрым образом), а потом
  бесплатно муваем его в поле и удаляем пустой объект. Итого получили одну потенциально долгую
  инициализацию и две бесплатных штуки (если, конечно, мув и удаление для такого объекта работают
  быстро)
  . [Пример](https://github.com/hse-spb-2021-cpp/lectures/blob/master/13-211208/02-move-objects/03-move-to-field.cpp)
* Вызов такого конструктора от:
    * переменной - 1 копирование + 1 мув + 1 удаление (+- норм)
    * временного объекта - 1 инициализация + 1 мув + 1 удаление (быстро)
    * функции, которая возвращает объект - 1 инициализация в функции, 1-3 мува, 1-2 удаления (
      быстро)

**Moved-from
состояние** [Егор](https://github.com/hse-spb-2021-cpp/lectures/blob/master/13-211208/02-move-objects/04-moved-from-state.cpp)

* Перемещение происходит только из объекта куда-то. Простой `std::move(smth)` ничего не делает.
* Мув из `unique-ptr` в `unique-ptr` гарантирует, что первый станет `nullptr`.
* Для всего остального такой гарантии нет, они входят в `moved-from` состояние. Содержание таких
  объектов не гарантируется (могут быть пустыми, половинчатыми, полными и вообще какими угодно), но
  гарантируется их корректность.

**Отсутствие необходимости `move` из результата функции, возвращенного по значению**

* Если мы возвращаем локальную переменную из функции, компилятор видит это и мувает автоматически,
  т.к. локальная переменная в любом случае умрёт после `return`.

**Необходимость `move` для передачи владения `unique_ptr`**

* Копировать `unique_prt` нельзя, потому что он `unique`, очев же (это сделано, чтобы случайно не
  скопировать значение и не вызвать конфликты). `std::move(foo)` говорит, что из переменной `foo`
  можно забрать значение (передать владение), тогда `foo` занулится.
# Полиморфные классы

Класс называется полиморфным (в терминах с++), если у него есть хотя бы одна виртуальная функция.

**Виртуальные методы и их отличия от невиртуальных**

* Виртуальные методы создаются с помощью ключевого слова `virtual` и могут перезаписываться
  наследниками с помощью слова `override` (`virtual` наследнику добавлять необязательно). Всегда
  вызывается виртуальная функция, принадлежащая тому классу, от которого мы вызвались.
* На самом деле, даже `override` писать не обязательно, т.к. если функция по сигнатуре в точности
  совпадает с виртуальной функцией сверху, то она становится виртуальной. `override` лишь проверяет,
  точно ли есть у родителя такой виртуальный метод.

**Виртуальный деструктор**

* Пример:

```c++
Base *b = new Derived; // Derived has its own destructor
delete b; // but ~Base != ~Derived
```

* Здесь мы пытаемся вызвать деструктор от `Base`, но он уберет за собой только то, что относится
  к `Base`, оставив поля `Derived` не очищенными. Поэтому нужно объявить виртуальный деструктор,
  чтобы компилятор понял, кого именно нужно удалить.
* `virtual ~Base() = default` - теперь, когда понадобиться удалить наследник `Base`, вызовется
  правильный деструктор от соответствующего наследника.
* У наследников все генерируемые деструкторы автоматически становятся виртуальными и перезаписывают
  базовый.

**Чисто виртуальные функции**

* Используются для абстрактных классов: например, есть какие-то виджеты `button`, `ball_icon`, `box`
  , у которых есть ширина и высота, но для всех они вычисляются по-разному. Хотим, чтобы их можно
  было единообразно обрабатывать, тогда делаем общий базовый класс `Widget`, от которого они
  наследуются.
* `virtual type func() const = 0` - чисто виртуальная функция.
* Класс, имеющий хотя бы одну чисто виртуальную функцию, называется абстрактным. Нельзя создать
  экземпляр абстрактного класса, от него можно только наследоваться (`Widget` в примере сверху -
  абстрактный).
* Если в наследнике не переопределена какая-то (чисто) виртуальная функция, он получает копию этой функции от родителя (если чисто-виртуальная, наследник тоже станет абстрактным).


**Slicing**

* У полиморфных классов есть совместимость по ссылкам, но не по значению.
* Например, имеем функцию `bar(Base b)`, которая принимает именно значение `b`. В таком случае, при
  попытке передать туда наследника `Base`, он "урежется" (произойдёт slicing), наследник лишится
  всех своих полей и превратится в `Base`. В этой функции теперь никак не получить оригинальный
  объект. [Пример](https://github.com/hse-spb-2021-cpp/lectures/blob/master/09-211110/03-casts.cpp)
* Как защититься: не передавать по значению, а вместо этого хранить ссылки/умные указатели.

**Хранение полиморфных объектов в контейнерах**

* Можем хранить фактически разные объекты, наследующиеся от одного класса, в одном контейнере. Все
  элементы контейнера должны быть одного типа, но у нас есть совместимость по ссылкам! Будем хранить
  в контейнере (умные, чтобы чистилась память) указатели на базовый класс, тогда можем сложить туда
  любого
  наследника. [Пример](https://github.com/hse-spb-2021-cpp/lectures/blob/master/09-211110/15-ptrs-good.cpp)
* Суть примера:

```c++
vector<std::unique_prt<Base>> vec;
vec.emplace_back(std::make_unique<Derived1>());
vec.emplace_back(std::make_unique<Derived2>()); // works fine! Don't forget about virtual destructor
```

**`dynamic_cast` для полиморфных классов**

* Хотим понять по ссылке на базовый класс, кем он на самом деле является.
* `dynamic_cast` пытается задаункаститься к типу, который мы указали (
  например, `dynamic_cast<Derived1 *>`). Если у него получается это сделать, он возвращает указатель
  на `Derived1`, иначе - `nullptr`.
* Синтаксис: `Derived1 *d1 = dynamic_cast<Derived1 *>(&b)`, `b` - это ссылка на `Base`
  . [Пример](https://github.com/hse-spb-2021-cpp/lectures/blob/master/10-211117/01-rtti/03-dynamic-cast.cpp)
* Если в `Base` нет виртуальных функций, `dynamic_cast` не сможет получить информацию о наследниках
  и просто не скомпилируется.
* Ещё `dynamic_cast` умеет аналогично кастовать ссылку к ссылке (в таком случае вместо `nullptr`
  происходит ошибка, которую можно обработать ручками)
# STL

**Использование `vector` как динамического массива фиксированной длины, `push_back`
, `emplace_back`**

* Обычные сишные массивы не могут быть динамическими (есть расширение `VLA - variable-length array`,
  но оно не входит в стандарт и может входить не во все компиляторы)
  .
* Вектор умеет удалять (`pop_back()`) и добавлять (`push_back()`) элементы, ему можно заранее
  зарезервировать память `vec.reserve()`, поэтому его можно использовать как динамический массив,
  чей размер не превышает заданный (а удаление/добавление в конец работает за единичку).
* `push_back(val)` - сначала создаёт временный объект, затем создает его копию в памяти контейнера и
  пытается мувнуть (скопировать) туда значение объекта, в конце вызывает деструктор.
* `emplace_back(args)` - вызывает конструктор типа, который лежит в векторе, передавая ему
  аргументы `args`. Конструктор может быть любым, работает в целом быстрее, т.к. не создает
  временного объекта (в случае, если передавать именно аргументы для конструктора, а не сам объект;
  в иных случаях проще `std::move(object)`, для которого `push_back()` потребуется сделать меньше
  работы).

Пример: [source](https://ru.stackoverflow.com/questions/570042/%D0%A0%D0%B0%D0%B7%D0%BD%D0%B8%D1%86%D0%B0-%D0%BC%D0%B5%D0%B6%D0%B4%D1%83-push-back-%D0%B8-emplace-back/570080)

```c++
struct Item {
    int a, b, c;
    Item(int a, int b, int c) : a(a), b(b), c(c) {}
}; 

int main() {
    std::vector<Item> x;
    // x.push_back(1, 2, 3); // won't compile
    x.emplace_back(1, 2, 3); // ok
}
```

**Использование `map` со стандартным компаратором, особенность `operator[]`**

* `map` умеет сортировать элементы в соответствии с функциональным объектом `compare`, который
  передаётся как третий аргумент в шаблоне типа. Стандартный компаратор -- `std::less` - пытается
  сравнивать ключи на `<`, результат сортировки - ключи упорядочены по возрастанию.
* `operator[key]` обращается по ключу `key` к `map`. Если ключа не существует, создаётся ключ, по
  нему кладётся значение по-умолчанию для того типа, который лежит в `map` (вызывается конструктор
  по-умолчанию для этого типа). Он должен создать новый объект, т.к. возвращается ссылка, а она
  должна на что-то указывать.
* Из-за такого поведения `[]` не работают на `const map`, поэтому в таком случае нужно
  использовать `.at()` (и ловить несуществующие ключи либо обработчиком, либо `.count()`).

**`lower_bound`/`upper_bound`: параметры, возвращаемое значение**

* Обе функции принимают итератор начала, итератор конца и элемент, который нужно найти. Итератор
  начала - откуда начать бинпоиск, итератор конца - перед каким элементом остановиться (
  полуинтервал)
* Полуинтервал должен быть отсортирован, иначе UB.
* Обе функции возвращают **итератор**, чтобы получить интересующий индекс, надо
  вычесть `container.begin()` из результата.
* `lower_bound():` итератор на первый элемент, который `>=` искомого элемента (предыдущий
  элемент `<`). Если элемента нет, возвращается первый, который строго больше. Если ищем слишком
  большой элемент, возвращается `end()`
  . [Егор](https://github.com/hse-spb-2021-cpp/lectures/blob/master/03-210916/01-extra-stl/05-lower-bound.cpp)
* `upper_bound():` итератор на первый элемент, который `>` искомого элемента (предыдущий `<=`)),
  остальное
  совпадает. [Егор](https://github.com/hse-spb-2021-cpp/lectures/blob/master/03-210916/01-extra-stl/06-upper-bound.cpp)
* Если запустим обе функции на одном элементе, вернется полуинтервал из этого элемента.
* Если запустим обе функции на каком-то массиве, где этого элемента не было, вернётся пустой
  полуинтервал, где этот элемент мог бы находиться.
### Термины

**Свободная функция**

* Функция, не являющаяся функцией-членом (т.е. не принадлежащая никакому классу)

**Функция-член**

* Функция, являющаяся членом какого-либо класса

**Время жизни объекта**

* **Автоматическое ("на стеке")**

    * Просто взяли и объявили локальную переменную, память под неё автоматически выделяется
      компилятором и автоматически же удаляется, когда её больше не видно.
      `Automatic storage duration` относится ко всем локальным переменным, которые не помечены
      как `static` . Если зашедовить переменную, она не умирает.

* **Статическое**
    * Глобальные переменные и всё, что на них похоже. Она создаётся в момент запуска программы и
      живёт до конца её работы. Может существовать только один экземпляр такого объекта. Любая
      глобальная переменная, а так же переменные, помеченные как `static`, 
      обладают `Static storage duration`. Если создать статическую переменную внутри функции, она
      создаётся во время первого прохода по этой функции и дальше живёт. Инициализируется один раз,
      затем для всех вызовов функции значение общее (аналогично поля классов). [Пример](https://github.com/hse-spb-2021-cpp/lectures/blob/master/07-211013/03-storage-duration/04-static-func-ok.cpp)

* **Динамическое ("на куче")**
    * `new`/`delete`. Синтаксис: `foo *f = new foo`, читается как "создай новый объект `foo` где-то
      там на куче и верни на него указатель". Это обычный объект, но с одной важной оговоркой:
      теперь за него нужно отвечать (удалить после использования ручками).

**Undefined Behaviour**

* **Почему у неинициализированной переменной нет никакого значения?**

    * При создании переменной выделяется память, но если за этим не последовала инициализация, туда
      не записывается никакого нового значения. Значит, при обращении к этой переменной можно
      получить ВОТ ВАЩЕ ЧТО УГОДНО, в зависимости от того, что лежало в той ячейке памяти, куда её
      записали. Из-за этого велика вероятность, что от запуска к запуску значение переменной будет
      меняться, причём совершенно рандомным образом.

* **Выход за границы массива**
    * Аналогично: для массива выделяется некоторый участок памяти, где хранятся его значения. При
      попытке обратиться к значению вне этого участка, мы залезем куда-то, где может лежать какой-то
      мусор или информация от другой части программы (или вообще другой программы).

* **Dangling reference (висячая ссылка)**

    * Возникает, когда удалили объект, на который указывала ссылка, но не удалили саму ссылку.
      Память, на которую указывает ссылка, может быть к тому времени уже перераспределена, поэтому
      получаем
      UB. [Пример](https://github.com/hse-spb-2021-cpp/lectures/blob/master/04-210923/06-const-wtf/01-dangling.cpp)

* **Разыменовывание `nullptr`**

    * При разыменовывании указателя мы пытаемся получить значение, лежащее по адресу, на который
      ссылается указатель. У `nullptr` такого адреса нет, поэтому получаем UB (вероятнее - краш
      программы).
    * Из стандарта: Если указателю присвоили некорректное значение, поведение унарного
      оператора * не определено. Среди некорректных значений - нулевой указатель, адрес памяти с
      неверным для типа смещением или адрес удаленного объекта.
# Переменные

**Статическая типизация**

* Каждая переменная (функция, выражение)
  имеет строго заданный тип, который указывается при объявлении переменной и не может быть изменен в
  процессе работы программы (это как раз проверяется на этапе компиляции). Из бонусов: более высокая
  скорость (нет проверок на тип), упорядоченность кода, некоторая часть ошибок может быть выявлена
  заранее на этапе компиляции (но не все, т.к. есть `implicit` преобразования).

**Тип переменной**

* Определяет, сколько места занимает переменная в памяти, нужен ли ей margin для выравнивания, какие
  операции над ней доступны.

**Размер переменной, размер типа**

* Переменная может занимать несколько байт памяти, это зависит от её типа. Переменные тривиальных
  типов обычно занимают столько байт, сколько занимает их тип, а переменные составных
  типов (`std::string`, пользовательские классы и т.п.) занимают различное количество памяти в
  зависимости от того, из каких типов состоят.

**Типы `int`, `char`, их размеры на `Linux x86_64` под `GCC`**

* В общем: `int` - 4 байта, `char` - 1 байт.
* Подробнее:
  * `int:` 
    * По стандарту, `short` - минимум 16, `int` - минимум 16, `long` - минимум 32, `long long` -
      минимум 64.
    * В документации `GCC` единственное отличие - `int` занимает 32 бита вместо 16.
  * `char:`
    * `UTF-8` - 8 бит, `UTF-16` - 16 бит и `UTF-32` - 32 бита. 
    * В `GCC` всё совпадает.
